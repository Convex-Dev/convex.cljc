(call *registry*
      (cns-update 'convex.run.client
                  *address*))

(call *registry*
      (register {:description ["Performing client operations, notably queries and transactions."
                               "Uses the fast and secure binary client from the Convex toolset."]
                 :name        "Client operations"}))


;;;;;;;;;; Values


(def $.kp

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.run.key-pair)))



(def *running?*

  ^{:doc {:description ["True if the client is connected to a peer."
                        "False otherwise."]}}

  false)


;;;;;;;;;; Predicate functions


(defn host?

  ^{:doc {:description ["Returns true if the given argument looks like a host argument (i.e. non-empty string or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (str? x)
           (not (empty? x)))))



(defn port?

  ^{:doc {:description ["Returns true if the given argument looks like a port (number between 0 and 65535 inclusive or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (number? x)
           (<= 0
               x
               65535))))


(defn sequence-id?

  ^{:doc {:description ["Returns true if the given argument is a valid sequence id (see `sequence-id`)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (and (number? x)
       (> x
          0)))



(defn timeout?

  ^{:doc {:description ["Returns true if the given argument is a valid timeout value (i.e. number > 0 or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (number? x)
           (> x
              0))))


;;;;;;;;;; Core API

(defn close

  ^{:doc {:description ["Closes the currently connected client (if any)."
                        "Client can be reconnected again if required."]
          :examples    [{:code "($.client/close)"}]
          :signature   [{:params []}]}}

  []

  (when *running?*
   [:cvm.sreq :client.close]))



(defn connect

  ^{:callable? true
    :doc       {:description ["Connects the client to a peer."
                              "Fails if already connected. ; see `close`."
                              "Options can be provided in a map:"
                              "  :host -> string designating the host (default is \"localhost\", testnet is \"convex.world\")"
                              "  :port -> port to use (default is 18888)"]
                :examples    [{:code "($.client/connect {:host \"convex.world\" :port 18888})"}]
                :signature   [{:params []}
                              {:params [options]}]}}

  ([]

   (connect nil))


  ([options]

   (if (= *address*
          ~*address*)
     (do
       (when *running?*
         (fail :STATE
               "Client is already connected to a peer"))
       (assert (host? (:host options)))
       (assert (port? (:port options)))
       (def *running?*
            true)
       [:cvm.sreq :client.connect options])
     (call ~*address*
           (connect options)))))



(defn query

  ^{:doc {:description ["Performs a query."
                        "Client must be connected to a peer ; see `connect`."
                        "Code is executed by the peer as a read-only operation ; any result or alteration is discarded."
                        "Hence, code can be executed under any account since no harm can be done."
                        "Remember to quote code so that is is not executed right away but on the peer."
                        "Argument 1 is the address under which the code should be executed."
                        "Argument 2 is the code to execute."
                        "Argument 3 is an optional map of options:"
                        "  :timeout -> timeout in milliseconds, query is canceled afterwards (unlimited by default)"]
          :examples    [{:code "($.client/query #2 '(+ 2 2))"}
                        {:code "($.client/query #2 '(+ 2 2) {:timeout 2000})"}]
          :signature   [{:params [address code]}
                        {:params [address code options]}]}}


  ([address code]

   ((lookup ~*address*
            query)
     address
     code
     nil))


  ([address code options]

   (assert *running?*)
   (assert (address? address))
   (assert (timeout? (:timeout options)))
   [:cvm.sreq :client.query address code options]))



(defn sequence-id

  ^{:doc {:description ["Returns code that can be submitted via a query for retrieving the sequence id of an account."
                        "A sequence id is a mandatory value attached to an account on chain meant to prevent replay attacks on transactions."
                        "This number is incremented on each and every transaction executed for an account."
                        "When submitting a transaction, the sequence id must be the current sequence id of the executing account, incremented by 1."
                        "If an address is submitted as argument, returned code will be specific to that address."
                        "Otherwise, standard symbol `*address*` is used."]
          :examples    [{:code "($.client/sequence-id)"}
                        {:code "($.client/sequence-id #10)"}
                        {:code "($.client/query #10 ($.client/sequence-id))"}]
          :params      [{:params []}
                        {:params [address]}]}}


 ([]

  '(:sequence (account *address*)))


 ([address]

  `(:sequence (account ~address))))



(defn transact

  ^{:doc {:description ""
          :examples    []
          :params      []}}


  ([address key-pair sequence-id code]

   (transact address
             key-pair
             sequence-id
             code
             nil))
  
  ([address key-pair sequence-id code options]

   (assert *running?*)
   (assert (address? address))
   (assert ($.kp/key-pair? key-pair))
   (assert (sequence-id? sequence-id))
   (assert (timeout? (:timeout options)))
   [:cvm.sreq :client.transact address key-pair sequence-id code options]))
