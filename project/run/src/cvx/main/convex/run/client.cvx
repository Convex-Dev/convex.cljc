(call *registry*
      (cns-update 'convex.run.client
                  *address*))

(call *registry*
      (register {:description ["Performing client operations, notably queries and transactions."
                               "Uses the fast and secure binary client from the Convex toolset."]
                 :name        "Client operations"}))


;;;;;;;;;; Dependencies


(def $.kp

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.run.key-pair)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.run.trx)))


;;;;;;;;;; Values


(def -*cache-seq-id*

  ^{:private? true}

  {})



(def *running?*

  ^{:doc {:description ["True if the client is connected to a peer."
                        "False otherwise."]}}

  false)


;;;;;;;;;; Predicate functions


(defn host?

  ^{:doc {:description ["Returns true if the given argument looks like a host argument (i.e. non-empty string or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (str? x)
           (not (empty? x)))))



(defn port?

  ^{:doc {:description ["Returns true if the given argument looks like a port (number between 0 and 65535 inclusive or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (number? x)
           (<= 0
               x
               65535))))


(defn sequence-id?

  ^{:doc {:description ["Returns true if the given argument is a valid sequence id (see `sequence-id`)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (and (number? x)
       (> x
          0)))



(defn timeout?

  ^{:doc {:description ["Returns true if the given argument is a valid timeout value (i.e. number > 0 or nil)."
                        "Returns false otherwise."]
          :signature   [{:params [x]}]}}

  [x]

  (or (nil? x)
      (and (number? x)
           (> x
              0))))


;;;;;;;;;; Core API

(defn close

  ^{:doc {:description ["Closes the currently connected client (if any)."
                        "Client can be reconnected again if required."]
          :examples    [{:code "($.client/close)"}]
          :signature   [{:params []}]}}

  []

  (when *running?*
   [:cvm.sreq :client.close]))



(defn connect

  ^{:callable? true
    :doc       {:description ["Connects the client to a peer."
                              "Fails if already connected. ; see `close`."
                              "Options can be provided in a map:"
                              "  :host -> string designating the host (default is \"localhost\", testnet is \"convex.world\")"
                              "  :port -> port to use (default is 18888)"]
                :examples    [{:code "($.client/connect {:host \"convex.world\" :port 18888})"}]
                :signature   [{:params []}
                              {:params [options]}]}}

  ([]

   (connect nil))


  ([options]

   (if (= *address*
          ~*address*)
     (do
       (when *running?*
         (fail :STATE
               "Client is already connected to a peer"))
       (assert (host? (:host options)))
       (assert (port? (:port options)))
       (def *running?*
            true)
       [:cvm.sreq :client.connect (or options {})])
     (call ~*address*
           (connect options)))))



(defn query

  ^{:doc {:description ["Performs a query."
                        "Client must be connected to a peer ; see `connect`."
                        "Code is executed by the peer as a read-only operation ; any result or alteration is discarded."
                        "Hence, code can be executed under any account since no harm can be done."
                        "Remember to quote code so that is is not executed right away but on the peer."
                        "Argument 1 is the address under which the code should be executed."
                        "Argument 2 is the code to execute."
                        "Argument 3 is an optional map of options:"
                        "  :timeout -> timeout in milliseconds, query is canceled afterwards (unlimited by default)"]
          :examples    [{:code "($.client/query #2 '(+ 2 2))"}
                        {:code "($.client/query #2 '(+ 2 2) {:timeout 2000})"}]
          :signature   [{:params [address code]}
                        {:params [address code options]}]}}


  ([address code]

   ((lookup ~*address*
            query)
     address
     code
     nil))


  ([address code options]

   (assert *running?*)
   (assert (address? address))
   (assert (timeout? (:timeout options)))
   [:cvm.sreq :client.query address code options]))



(defn sequence-id

  ^{:doc {:description ["Returns code that can be submitted via a query for retrieving the sequence id of an account."
                        "A sequence id is a mandatory value attached to an account on chain meant to prevent replay attacks on transactions."
                        "This number is incremented on each and every transaction executed for an account."
                        "When submitting a transaction, the sequence id must be the current sequence id of the executing account, incremented by 1."
                        "If an address is submitted as argument, returned code will be specific to that address."
                        "Otherwise, standard symbol `*address*` is used."]
          :examples    [{:code "($.client/sequence-id)"}
                        {:code "($.client/sequence-id #10)"}
                        {:code "($.client/query #10 ($.client/sequence-id))"}]
          :params      [{:params []}
                        {:params [address]}]}}


 ([]

  '(:sequence (account *address*)))


 ([address]

  `(:sequence (account ~address))))



(defn transact

  ^{:callable? true
    :doc       {:description ["Performs a transaction."
                              "Unlike queries, transactions have the power to alter state on the network."
                              "Hence, they are executed in the context of an account and the transaction needs to be signed by the key pair matching that account."
                              "Additionally, the proper sequence id is required ; see `sequence-id`."
                              "When the sequence id is not provided, it is automatically retrieved via a `query` using `sequence-id`, as a convenience."
                              "Furthermore, sequence ids are cached so that they need to be retrieved from the chain at most once for each account using a `query`."
                              "Argument 1 is the address under which the code should be executed."
                              "Argument 2 is the key pair matching the address ; see the `$.kp` library."
                              "Argument 3 is the code to execute ; quoted so that is not executed right away."
                              "Argument 4 is an optional map of options:"
                              "  :sequence-id -> sequence id used for this transaction"
                              "  :timeout     -> timeout in milliseconds, query is canceled afterwards (unlimited by default)"]
                :examples    [{:code "($.client/transact #42 my-key-pair '(def foo 42))"}
                              {:code "($.client/transact #42 my-key-pair '(def foo 42) {:timeout 5000})"}]
                :params      [{:params [address key-pair code]}
                              {:params [address key-pair code options]}]}}


  ([address key-pair code]

   (transact address
             key-pair
             code
             nil))
  
  ([address key-pair code options]

   (if (= *address*
          ~*address*)
     (do
       (assert *running?*)
       (assert (address? address))
       (assert ($.kp/key-pair? key-pair))
       (assert (timeout? (:timeout options)))
       (let [sequence-id   (:sequence-id options)
             sequence-id-2 (if sequence-id
                             (do
                               (assert (sequence-id? sequence-id))
                               sequence-id)
                             (get -*cache-seq-id*
                                  address))]
         (if sequence-id-2
           (do
             (def -*cache-seq-id*
                  (assoc -*cache-seq-id*
                         address
                         (inc sequence-id-2)))
             [:cvm.sreq :client.transact address key-pair sequence-id-2 code options])
           ($.trx/precat `(($.client/query ~address
                                           ($.client/sequence-id))
                           ($.client/transact ~address
                                              ~key-pair
                                              (quote ~code)
                                              (assoc ~options
                                                     :sequence-id
                                                     (inc (:result $/*result*)))))))))
     (call ~*address*
           (transact address
                     key-pair
                     code
                     options)))))
