;;
;;
;; Testing `convex.shell.file`.
;;
;;


;;;;;;;;;;


(def T
     $.test)


;;;;;;;;;; Test suites


(defn suite.copy

  ^{:doc {:description "Copying files."}}

  []

  (let [assert+ (fn [test-path path-source path-destination path-verify]
                  (T/group `((T/path.conj (quote ~test-path))
                              
                             ($.file/!.copy ~path-source
                                            ~path-destination)
                             (T/trx '(nil? $/*result*)
                                    {:description "Copying returns nil."})

                             ($.file/!.read ~path-verify)
                             (T/trx '(= (first $/*result*)
                                        cell)
                                    {:description "Content has been copid."})

                             ($.file/!.exists? ~path-source)
                             (T/trx '$/*result*
                                    {:description "Original path still exists."}))))]
    (T/group `((T/path.conj 'copy)

               ($.file/!.tmp)
               (def path
                    $/*result*)

               (def cell
                    [:foo :bar])
               ($.file/!.write path
                               cell)

               ($.file/!.tmp)
               (~assert+ 'file-to-file
                         path
                         $/*result*
                         $/*result*)

               ($.file/!.tmp-dir)
               (def path-directory
                    $/*result*)
               (def path-file-in-directory
                    (str path-directory
                         "/foo.cvx"))
               (~assert+ 'file-to-file-in-dir
                         path
                         path-file-in-directory
                         path-file-in-directory)


               ($.file/!.tmp-dir)
               (~assert+ 'ok
                         path-file-in-directory
                         $/*result*
                         (str $/*result*
                              "/foo.cvx"))))))



(defn suite.delete

  ^{:doc {:description "Deleting files."}}

  []

  (let [assert+ (fn [test-path filename]
                  (T/group `((T/path.conj (quote ~test-path))
                              
                             (T/trx '($.trx/precat '(($.file/!.delete ~filename)
                                                     $/*result*))
                                    {:description "Path deleted."})

                             (T/trx '($.trx/precat '(($.file/!.delete ~filename)
                                                     (not $/*result*)))
                                    {:description "Cannot delete the path a second time."}))))]
    (T/group `((T/path.conj 'delete)

               ($.file/!.delete "azerazerazerazerazerazerazerzaer")
               (T/trx '(not $/*result*)
                      {:description "Cannot delete a inexistent file."})
  
               ($.file/!.tmp)
               (~assert+ 'file
                         $/*result*)

               ($.file/!.tmp-dir)
               (~assert+ 'directory
                         $/*result*)))))



(defn suite.exists?

  ^{:doc {:description "Testing the existence of a file or a directory."}}

  []

  (let [assert+ (fn [test-path filename]
                  (T/group `((T/path.conj (quote ~test-path))
                              
                             ($.file/!.exists? ~filename)
                             (T/trx '$/*result*
                                    {:description "Freshly created path must exist."})

                             ($.file/!.delete ~filename)
                             ($.file/!.exists? ~filename)
                             (T/trx '(not $/*result*)
                                    {:description "Path cannot exist after being deleted."}))))]
    (T/group `((T/path.conj 'exists?)

               ($.file/!.exists? "azerazerazerazerazerazerazer")
               (T/trx '(not $/*result*)
                      {:description "Random file cannot exist"})

               ($.file/!.tmp)
               (~assert+ 'file
                         $/*result*)

               ($.file/!.tmp-dir)
               (~assert+ 'directory
                         $/*result*)))))



(defn suite.line

  ^{:doc {:description "Reading files line by line as cells or text."}}

  []

  (T/group '((T/path.conj 'line)

             ($.file/!.tmp)
             (def path
                  $/*result*)

             ($.file/!.stream.out path)

             (def out
                  $/*result*)

             ($.stream/!.outln out
                               :one)
             ($.stream/!.outln out
                               :two)
             ($.stream/!.out out
                             :three)
             ($.stream/!.txt.out out
                                 " ")
             ($.stream/!.out out
                             :four)
             ($.stream/!.flush out)
             ($.stream/!.close out)

             (T/group '((T/path.conj 'cell)

                        ($.file/!.stream.in path)
                        (def in
                             $/*result*)

                        ($.stream/!.line in)
                        (T/trx '(= '(:one)
                                   $/*result*)
                               {:description "Line 1"})

                        ($.stream/!.line in)
                        (T/trx '(= '(:two)
                                   $/*result*)
                               {:description "Line 2"})

                        ($.stream/!.line in)
                        (T/trx '(= '(:three :four)
                                   $/*result*)
                               {:description "Line 3"})

                        ($.stream/!.line in)
                        (T/trx '(= nil
                                   $/*result*)
                               {:description "End is reached"})

                        ($.stream/!.open? in)
                        (T/trx '(not $/*result*)
                               {:description "Input stream closed automatically when end is reached"})))

             (T/group '((T/path.conj 'txt)

                        ($.file/!.stream.in path)
                        (def in
                             $/*result*)

                        ($.stream/!.txt.line in)
                        (T/trx '(= ":one"
                                   $/*result*)
                               {:description "Line 1"})

                        ($.stream/!.txt.line in)
                        (T/trx '(= ":two"
                                   $/*result*)
                               {:description "Line 2"})

                        ($.stream/!.txt.line in)
                        (T/trx '(= ":three :four"
                                   $/*result*)
                               {:description "Line 3"})

                        ($.stream/!.txt.line in)
                        (T/trx '(= nil
                                   $/*result*)
                               {:description "End is reached"})

                        ($.stream/!.open? in)
                        (T/trx '(not $/*result*)
                               {:description "Input stream closed automatically when end is reached"}))))))



(defn suite.rw

  ^{:doc {:description "One-shot reading and writing."}}

  []

  (T/group '((T/path.conj 'rw)

             (def cell
                  '(def x
                        {:foo :bar}))

             ($.file/!.tmp)

             (def path
                  $/*result*)

             (T/trx '($.trx/precat '(($.file/!.write path
                                                     cell)
                                     ($.file/!.read path)
                                     (= cell
                                        (first $/*result*))))
                    {:description "Reading after writing."})

             ($.file/!.exec path)

             (T/trx '($.trx/precat '(($.file/!.exec path)
                                     (= {:foo :bar}
                                        x)))
                    {:description "File executed."}))))



(defn suite.txt.rw

  ^{:doc {:description "Like [[suite.rw]] but in text mode."}}

  []

  (T/group '((T/path.conj 'rw.txt)

             ($.file/!.tmp)

             (def path
                  $/*result*)

             ($.file/!.write path
                             "test")

             ($.file/!.read path)

             (T/trx '(= '("test")
                        $/*result*)
                    {:description "Written as cell"})

             ($.file/!.txt.write path
                                 "test")

             ($.file/!.read path)

             (T/trx '(= '(test)
                        $/*result*)
                    {:description "Written as text"}))))



(defn suite.txt.in


  ^{:doc {:description "Reading a wnole stream as text."}}

  []

  (T/group '((T/path.conj 'txt.in)

             (def txt
                  "foo\nbar")

             ($.file/!.tmp)
             (def path
                  $/*result*)

             ($.file/!.txt.write path
                                 txt)

             ($.file/!.txt.read path)
             (T/trx '(= txt
                        $/*result*)
                    {:description "Everything read at once as text"}))))



(defn suite.stream

  ^{:doc {:description ["Low-level stream utilities."
                        "Complements tests for `convex.shell.streams`."]}}

  []

  (T/group '((T/path.conj 'stream)

             ($.file/!.tmp)

             (def path
                  $/*result*)

             ($.file/!.stream.out path)

             (def stream.out
                  $/*result*)

             ($.stream/!.outln stream.out
                               :foo)

             ($.stream/!.outln stream.out
                               :bar)

             ($.stream/!.flush stream.out)

             ($.stream/!.open? stream.out)
             (T/trx '$/*result*
                    {:description "Output stream is open"})

             ($.stream/!.close stream.out)

             ($.stream/!.open? stream.out)
             (T/trx '(not $/*result*)
                    {:description "Output stream is indeed closed"})

             (T/fail.code #{:STREAM}
                          '($.stream/!.outln stream.out
                                             :baz)
                          {:description "Cannot write to closed stream."})

             ($.file/!.stream.in path)

             (def stream.in
                  $/*result*)

             (T/trx '($.trx/precat '(($.stream/!.in+ stream.in)
                                     (= '(:foo :bar)
                                        $/*result*)))
                    {:description "Ensures write was successful by reading back."})

             (T/fail.code #{:STREAM}
                          '($.stream/!.in+ stream.in)
                          {:description "Input stream autoclosed, cannot read again."})

             ($.file/!.stream.in path)

             (def stream.line
                  $/*result*)

             (T/trx '($.trx/precat '(($.stream/!.line stream.line)
                                     (= '(:foo)
                                        $/*result*)))
                    {:description "Read only first line."}))))



(defn suite.tmp

  ^{:doc {:description "Creating temporary files and directories."}}

  []

  (let [assert+ (fn [test-path filename]
                  (T/group `((T/path.conj (quote ~test-path))
                             (def cell
                                  [:foo :bar])
                             ($.file/!.write ~filename
                                             cell)
                             ($.file/!.read ~filename)
                             (T/trx '(= (first $/*result*)
                                        cell)
                                    {:description "Able to write and read using the given path."}))))]
    (T/group `((T/path.conj 'tmp)

               ($.file/!.tmp)
               (~assert+ 'file
                         $/*result*)

               ($.file/!.tmp-dir)
               (~assert+ 'directory
                         (str $/*result*
                              "/"
                              "foo.cvx"))))))


;;;


(defn suite.main

  ^{:doc {:description ["Main test suite gathering other suites."]}}

  []

  (T/group '((T/path.conj 'convex.shell.file)
             (suite.tmp)
             (suite.exists?)
             (suite.delete)
             (suite.copy)
             ;; Most logical order.
             (suite.stream)
             (suite.line)
             (suite.rw)
             (suite.txt.rw)
             (suite.txt.in)
             )))


;;;


(suite.main)
(T/print "convex.shell.file")
