;;
;; CONVEX SHELL LIBRARY
;;
;; Unlocks all the extra features offered by the Shell through `.shell.invoke`.
;;


;;;;;;;;;; Miscellaneous helpers, private and public


(defn .docoll

  ^:private?

  [f coll]

  (let [n (count coll)]
    (loop [i 0]
      (if (< i
             n)
        (do
          (f (nth coll
                  i))
          (recur (inc i)))
        nil))))



(defn .every?

  ^:private?

  [f coll]

  (reduce (fn [_ x]
            (or (f x)
                (reduced false)))
          true
          coll))



(defn .prn

  ^{:doc {:description "Prints arguments in a vector using `.stream.outln`."
          :examples    [{:code (.prn :a :b :c)}]
          :signature   [{:params [& arg+]}]}}

  [& arg+]

  (.stream.outln arg+))



(defn .trunc.str

  ^:private?


  ([string]

   (.trunc.str nil
               string))


  ([n.char string]

   (let [n.char-2 (or n.char
                      100)
         string-2 (str string)]
     (if (> (count string-2)
            n.char-2)
        (str (slice string-2
                    0
                    97)
             (.term.bold)
             "..."
             (.term.reset))
       string-2))))


;;;;;;;;;; Async


(def .a

  ^{:private?      true
    :shell.section ["Utilities for async programming."]}

  nil)



(defn .a.take

  ^{:doc {:description ["Awaits an async value."
                        ""
                        "Optionally, a timeout in milliseconds may be provided."
                        "If this tiemout is reached, the timeout value is returned."]
          :examples    [{:code (.a.take (.a.do* (inc 42)))}
                        {:code (.a.take (.a.do* (.time.sleep 1000) 42) 5000 :timeout)}]
          :signature   [{:params [async-value]}
                        {:params [async-value timeout.millis timeout.value]}]}}


  ([async-value]

   (.shell.invoke '.a.take
                  async-value))


  ([async-value timeout.millis timeout.value]

   (.shell.invoke '.a.take.timeout
                  async-value
                  timeout.millis
                  timeout.value)))



(defn .a.do

  ^{:doc {:description ["Executes the given no-arg function in parallel, in a new thread."
                        "Returns an async value that can be awaited with `.a.take`."
                        ""
                        "Trying to open an Etch instance in this function will throw."
                        "If Etch is required, it should be open behorehand."
                        ""
                        "If `.sys.vthread?` is set to `true`, it means this Shell can probably"
                        "handle hundreds of thousands if not millions of concurrent threads."
                        ""
                        "See `.a.do*` for a convenience macro."]
          :examples    [{:code (.a.take (.a.do (fn [] (.time.sleep 1000) 42)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.a.do
                 f))



(defmacro .a.do*

  ^{:doc {:description ["Convenience macro over `.a.do`."
                        "Code to execute is provided as-is, without wrapping it in a function."]
          :examples    [{:code (.a.do* (.time.sleep 1000) 42)}]
          :signature   [{:params [& body]}]}}

  [& body]

  `(.a.do ~(concat '(fn [])
                   body)))


;;;;;;;;;; Account


(def .account

  ^{:private?      true
    :shell.section ["Utilities centered on Convex accounts."
                    "Notably, see `.account.switch`."]}

  nil)



(def .account.0-key

  ^{:doc {:description "Fake key, useful for turning an actor into a user account with `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(def .account.core

  ^{:doc {:description "Address of the core account where all core functions are defined."}}

  .account.core)



(defn .account.key?

  ^{:doc {:description "Returns true if `x` is a 32-byte blob that can act as a key."
          :examples    [{:code (.account.key? $.account/fake-key)}
                        {:code (.account.key? 42)}]
          :signature   [{:params [x]}]}}

  [x]

  (and (blob? x)
       (= (count x)
          32)))



(def .account.genesis

  ^{:doc {:description "Address of the account used when starting the Shell."}}

  .account.genesis)



(defn .account.switch

  ^{:doc {:description ["Switches the execution context to the given address."]
          :examples    [{:code (.account.switch #3)}]
          :signature   [{:params [address]}]}}

  [address]

  (.shell.invoke '.account.switch
                 address))


;;;;;;;;;; Benchmarking


(def .bench

  ^{:private?      true
    :shell.section ["Micro-benchmarking utilities."]}

  nil)



(defn .bench.eval

  ^{:doc {:description ["Benchmarks the mean execution time of evaluating the given code."
                        "Any state change is reverted each time."
                        ""
                        "Returns a map with:"
                        ""
                        "  :avg"
                        "    Average execution time (seconds)"
                        ""
                        "  :Hz"
                        "    Frequency, 1 divided by `:avg`."
                        ""
                        "  :stddev"
                        "    Standard deviation (seconds)"
                        ""
                        "Executed a high number of times for accurate measurement."
                        ""
                        "Highly experimental and subject to change, probably useful for CVM developers only."
                        "Depending on the given code, usually takes between one and several minutes to complete."]
          :examples    [{:code (.bench.eval '(+ 2 2))}
                        {:code (.bench.eval (compile '(+ 2 2)))}]
          :signature   [{:params [code]}]}}


  [code]

  (.shell.invoke '.bench.eval
                 code))



(defn .bench.trx

  ^{:doc {:description ["Exactly like `.bench.eval` but executes a actual transaction,"
                        "which also accounts for other concerns such as juice accounting."
                        ""
                        "`:Hz` is effectively TPS (Transactions-Per-Second)."
                        ""
                        "See `(?.shell '.trx)` about transactions"]
          :examples    [{:code (.bench.trx (.trx.new.transfer *address* #12345 1000))}]
          :signature   [{:params [trx]}]}}


  [trx]

  (.shell.invoke '.bench.trx
                 trx))




(defn .bench.trx.gen

  ^{:doc {:description ["Similar to `.bench.trx` but works with a transaction generator."
                        "The "
                        ""
                        "See `(?.shell '.gen)` about generators and `(?.shell '.trx)` about"
                        "transactions".]
          :examples    [{:code (.bench.trx.gen (.gen.fmap (fn [amount] (.trx.new.transfer *address* #12345 amount)) (.gen.long.uniform 0 1000)))}]
          :signature   [{:params [gen]}
                        {:params [gen option+]}]}}


  ([gen]

   (.bench.trx.gen gen
                   nil))


   ([gen option+]

    (.shell.invoke '.bench.trx.gen
                   gen
                   (or (:sample.count option+)
                       60)
                   (or (:sample.time option+)
                       1000000000))))


;;;;;;;;;; Cell utilities


(def .cell

  ^{:private?      true
    :shell.section ["Developer utilities centered on cells."
                    "Meant for more advanced users."]}

  nil)



;; Removed for now as it does not work with recent Convex changes.
;
; (defn .cell.compile
; 
;   ^{:doc {:description ["Compiles the given `cell` for the given `address`, even when no account"
;                         "exist for that address in the current Shell."
;                         ""
;                         "Typically used for pre-compiling code for a transaction targeting a network"
;                         "where that account exists, as a way of saving on transaction fees (on-chain"
;                         "compilation is more expensive than executing precompiled code)."
;                         ""
;                         "User must think carefully about macros since the cell will be expanded against"
;                         "the given `state` (defaults to `*state*`)."]
;           :examples    [{:code (.cell.compile #1234567890 '(def foo (inc bar)))}
;                         {:code (.cell.compile (.state.genesis) #1234567890 '(def foo (inc bar)))}]
;           :signature   [{:params [address cell]}
;                         {:params [state address cell]}]}}
; 
; 
;   ([address cell]
; 
;    (.cell.compile nil
;                   address
;                   cell))
; 
; 
;   ([state address cell]
; 
;    (.shell.invoke '.cell.compile
;                   (or state
;                       *state*)
;                   address
;                   cell)))



(defn .cell.ref.stat

  ^{:doc {:description ["Given a cell (cannot be `nil`), returns a map where:"
                        ""
                        "  :direct"
                        "    Number of direct refs."
                        ""
                        "  :embedded"
                        "    Number of embedded cells."
                        ""
                        "  :persisted"
                        "    Number of refs marked as persisted."
                        ""
                        "  :soft"
                        "    Number of soft refs."
                        ""
                        "  :total"
                        "    Total number of refs."
                        ""
                        "This is an advanced feature meant for CVM developers familiar"
                        "with the notion of cell references."]
          :examples    [{:code (.cell.ref.stat *state*)}]
          :signature   [{:params [cell]}]}}

  [cell]

  (when (nil? cell)
    (fail :ARGUMENT
          "Cell cannot be `nil`"))
  (.shell.invoke '.cell.ref.stat
                 cell))



(defn .cell.size

  ^{:doc {:description ["In bytes, returns the memory size of the given `cell`."
                        "Accounts for the encoding of the `cell` as well as any of"
                        "its children (if any)."
                        ""
                        "Cell cannot be `nil`."]
          :examples    [{:code (.cell.size [:a :b])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.cell.size
                 cell))



(defn .cell.str

  ^{:doc {:description ["Stringifies `cell`."
                        ""
                        "There are 2 major differences from standard `str`:"
                        ""
                        "  - `str` controls for the size of the produced string in bytes and"
                        "    does not print the full cell is it is too large (fairly small limit)."
                        "    This function has no limit by default."
                        ""
                        "  - `str` stringifies characters and strings so that they can be concatenated."
                        "     E.g. `\\a` -> `\"a\"`"
                        "     This function prints them in their proper cell form."
                        "     E.g. `\\a` -> `\"\\a\"`"]
          :examples    [{:code (.cell.str *state*)}
                        {:code (.cell.str 20 *state*)}]
          :signature   [{:params [cell]}
                        {:params [limit cell]}]}}

  ([cell]

   (.cell.str nil
              cell))


  ([limit cell]

   (.shell.invoke '.cell.str
                  (or limit
                      9223372036854775807) 
                  cell)))


;;;;;;;;;; Binary client


(def .client

  ^{:private?      true
    :shell.section ["The binary client allows for connecting to a peer for the purpose"
                    "of issuing queries and transactions."]}

  nil)



(defn .client.close

  ^{:doc {:description ["Closes the given `client`."
                        "See `.client.connect`."]
          :examples    [{:code (.client.close (.client.connect)) }]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.close
                 client))



(defn .client.connect

  ^{:doc {:description ["Returns a client connected to the requested peer."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :host"
                        "    Peer URL (String)."
                        "    Defaults to `\"localhost\"`."
                        ""
                        "  :port"
                        "    Port exposed by `:host` (Long)."
                        "    Defaults to `.peer.default.port`."
                        ""
                        "Also see `.client.close`."]
          :examples    [{:code (.client.connect)}
                        {:code (.client.connect {:host "convex.world", :port 18888})}]
          :signature   [{:params []}
                        {:params [option+]}]}}


  ([]

   (.client.connect nil))


  ([option+]

   (.shell.invoke '.client.connect
                  (or (:host option+)
                      "localhost")
                  (or (:port option+)
                      .peer.default.port))))



(defn .client.peer.endpoint

  ^{:doc {:description ["Given a `client`, returns a Map such as:"
                        ""
                        "  :host"
                        "    Host of the peer this client is connected to (String)."
                        ""
                        "  :port"
                        "    Port of the peer this client is connected to (Long)."]
          :examples    [{:code (.client.peer.endpoint (.client.connect {:host "convex.world"}))}]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.peer.endpoint
                 client))



(defn .client.peer.status

  ^{:doc {:description ["Retrieves the current status of the peer this `client` is connected to."
                        ""
                        "Advanced feature."
                        ""
                        "Returns an async value resolving to a Map such as:"
                        ""
                        "  :hash.belief"
                        "    Hash of the current Belief this peer has."
                        ""
                        "  :hash.state+"
                        "    Hash of all the States this peer has."
                        ""
                        "  :hash.state.consensus"
                        "    Hash of the current consensus State."
                        ""
                        "  :hash.state.genesis"
                        "    Hash of the genesis State."
                        ""
                        "  :n.block"
                        "    Number of blocks this peer has in its ordering."
                        ""
                        "  :point.consensus"
                        "    Current consensus point of this peer."
                        ""
                        "  :point.proposal"
                        "    Current proposal point of this peer."
                        ""
                        "  :pubkey+"
                        "    Public key of this peer."]
          :examples    [{:code (.a.take (.client.peer.status (.client.connect {:host "convex.world"})))}]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.peer.status
                 client))



(defn .client.query

  ^{:doc {:description ["Issues a query for executing `code` in the context of `address`."
                        ""
                        "Queries are a dry run: executed only by the target peer, without"
                        "consensus, and any state change is eventually discarded."
                        "They are read-only operations and do not incur fees in Convex Coins."
                        ""
                        "Returns an async value that can be awaited with `.a.take`."
                        "Will resolve to a map such as:"
                        ""
                        "  :error"
                        "    Error code if an exception was thrown (`nil` otherwise)."
                        ""
                        "  :id"
                        "    Long incremented by the client on each query or transaction."
                        ""
                        ""
                        "  :info"
                        "    In case of success, `nil`."
                        "    In case of `:error`, a map such as:"
                        ""
                        "      :address"
                        "        Address of the account where the exception was thrown."
                        ""
                        "      :trace"
                        "        Trace of the exception."
                        ""
                        "  :result"
                        "    In case of success, the result from executing `code`."
                        "    In case of `:error`, the exception message."
                        ""
                        "An Etch instance must be open (see `.db.open`)."]
                        :examples    [{:code (.a.take (.client.query (.client.connect {:host "convex.world"}) #2 '*balance*))}]
          :signature   [{:params [client address code]}]}}

  [client address code]

  (.shell.invoke '.client.query
                 client
                 address
                 code))



(defn .client.query.state

  ^{:doc {:description ["Queries the current `*state*` of the peer."
                        "Returns an async value that can be awaited with `.a.take`."
                        ""
                        "This operation could take anywhere from seconds to hours depending on the size"
                        "of the state."]
          :examples    [{:code (.a.take (.client.query.state (.client.connect {:host "convex.world"})))}]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.query.state
                 client))



(defn .client.resolve

  ^:private?

  ;; Seems to have trouble with hashes that do no point to existing data.
  ;; Will be fixed.

  [client hash]

  (.shell.invoke '.client.resolve
                 client
                 hash))



(defn .client.repl

  ^{:doc {:description ["Like `.repl` but connects to a Convex peer."
                        ""
                        "Each line of code provided interactively will executed depending on the"
                        "current mode. Five modes are supported:"
                        ""
                        "  :local"
                        "    All input code is executed locally in the Shell."
                        "    Result from the last execution is available under `$`."
                        ""
                        "  :query"
                        "    Input code is issued to the peer as a query (read-only operation without"
                        "    consensus, only executed by the peer, discarding any change at the end)."
                        ""
                        "  :query.prepare"
                        "    Combination between `:local` and `:query`."
                        "    Input code is first executed locally and the result is then issued to"
                        "    the peer as a query."
                        ""
                        "  :transact"
                        "    Input code is issued to the peer as a transaction."
                        ""
                        "  :transact.prepare"
                        "    Combination between `:local` and `:transact`."
                        "    Input code is first executed locally and the result is then issued to"
                        "    the peer as a transaction."
                        "    Useful when transactions must be somehow prepared (e.g. fetch source"
                        "    for a smart contract from a file)."
                        ""
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :address"
                        "    Address of the account issuing transactions."
                        "    If not provided and if `:host` is `\"convex.world\"` (public testnet),"
                        "    a new account will be created."
                        ""
                        "  :key-pair"
                        "    Key pair for signing transactions."
                        "    Mandatory if `:address` is provided."
                        ""
                        "  :host"
                        "    Peer URL (String)."
                        "    Defaults to `\"convex.world\"` (public testnet)."
                        ""
                        "  :rtt?"
                        "    When `true`, tracks and print the round-trip time of each query and"
                        "    transaction (delta between sending a request and getting a result)."
                        "    Defaults to `true`."
                        ""
                        "  :port"
                        "    Port exposed by `:host` (Long)."
                        "    Defaults to `.peer.default.port`."
                        ""
                        "  :timeout"
                        "    Timeout in milliseconds used for network requests."
                        "    Defaults to `10000`."
                        "    E.g. if a transaction takes longer than this, returns `:timeout`."
                        ""
                        "For other options, see `.repl`."
                        ""
                        ""
                        "Automatically opens an Etch instance if none is detected (see `.db.open`)."
                        ""
                        "To quit, enter `:q` or `:quit`."
                        "Returns a map with `:address`, `:key-pair`, and `:result` (last result)."]
          :examples    [{:code (.client.repl)}
                        {:code (.client.repl {:address #42, :key-pair matching-key-pair, :host "localhost"})}]
          :signature   [{:params []}
                        {:params [option+]}]}}

  ([]

   (.client.repl {}))
 

  ([option+]

   (.stream.txt.outln "")
   (let [host    (or (:host option+)
                     "convex.world")
         port    (or (:port option+)
                     .peer.default.port)
         addr    (:address option+)
         kp      (:key-pair option+)
         timeout (or (:timeout option+)
                     10000)]
     (when-not (and (long? timeout)
                    (>= timeout
                        0))
       (fail :ARGUMENT
             "Timeout must be a Long >= 0"))
     (when (and addr
                (not kp))
       (fail :ARGUMENT
             "Address provided without matching key pair"))
     (when (and kp
                (not addr))
       (fail :ARGUMENT
             "Key pair provided without an address"))
     (let [out     (or (:stream.out option+)
                       (.stream.stdout))
           [addr-2
            kp-2]  (if (and addr
                            kp)
                     [addr
                      kp]
                     (if (= host
                            "convex.world")
                       (let [kp-2   (.kp.create)
                             _      (do
                                      (.stream.txt.out out
                                                       "Creating a new account on `convex.world`")
                                      (.stream.flush out))
                             addr-2 (.a.take (.testnet.create-account (.kp.pubkey kp-2))
                                             timeout
                                             :client.repl.timeout)
                             _      (if (= addr-2
                                             :client.repl.timeout)
                                      (fail :SHELL.CLIENT.REPL
                                            "Timeout while creating a new account")
                                      (.stream.txt.outln out
                                                         (str ": "
                                                              addr-2)))
                             _      (do
                                      (.stream.txt.out out
                                                       "Provisioning Convex Coins to new account")
                                      (.stream.flush out))
                             amount (.a.take (.testnet.faucet addr-2
                                                              100000000)
                                             timeout
                                             :client.repl.timeout)
                             _      (if (= amount
                                           :client.repl.timeout)
                                      (fail :SHELL.CLIENT.REPL
                                            "Timeout while provisioning funds")
                                      (.stream.txt.outln out
                                                         (str ": "
                                                              amount)))]
                         [addr-2
                          kp-2])
                       (fail :ARGUMENT
                             "Unless the peer is `convex.world`, must provid an address and a key pair")))]
       (when (nil? (.db.path))
         (let [db-path (.fs.tmp "convex-shell-"
                                ".etch")]
           (.stream.txt.outln (str "Opening Etch instance at `"
                                   db-path
                                   "`"))
           (.db.open db-path)))
       (.stream.txt.outln (str "Connecting to `"
                               host
                               ":"
                               port
                               "`"))
       (.stream.txt.outln "")
       (let [client   (.client.connect {:host host
                                        :port port})
             sequence (.a.take (.client.sequence client
                                                 addr-2))
             _        (when (nil? sequence)
                        (fail :SHELL.CLIENT
                              "Unable to retrieve sequence ID"))
             [ok?
              x]      (.state.safe (fn []
                                     (.repl (merge option+
                                                   {:client.repl.address  addr-2
                                                    :client.repl.client   client
                                                    :client.repl.host     host
                                                    :client.repl.key-pair kp-2
                                                    :client.repl.mode     :transact
                                                    :client.repl.port     port
                                                    :client.repl.sequence sequence
                                                    :client.repl.timeout  timeout
                                                    :eval                 .client.repl.eval
                                                    :on.prompt            .client.repl.on.prompt}))))]
         (.client.close client)
         (if ok?
           {:address  addr-2
            :key-pair kp-2
            :result   (:result x)}
           (.ex.rethrow x)))))))



(defn .client.repl.eval

  ^:private?

  [env]

  (let [form+  (:form+ env)
        form-1 (first form+)]
    (if (contains-key? #{:local
                         :query
                         :query.prepare
                         :transact
                         :transact.prepare}
                       form-1)
        (let [env-2 (assoc env
                           :client.repl.mode form-1
                           :result           form-1)]
          (if (contains-key? #{:local
                               :query.prepare
                               :transact.prepare}
                             form-1)
            (assoc env-2
                   :client.repl.local.result
                   (:result env))
            env-2))
      (let [code (if (= (count form+)
                        1)
                   form-1
                   (cons 'do
                         form+))
            eval  (get {:local            .client.repl.local
                        :query            .client.repl.query
                        :query.prepare    .client.repl.query.prepare
                        :transact         .client.repl.transact
                        :transact.prepare .client.repl.transact.prepare}
                       (:client.repl.mode env))]
        (eval env
              code)))))



(defn .client.repl.local

  ^:private?

  [env code]

  (.repl.eval (assoc (if (contains-key? env
                                        :client.repl.local.result)
                       (assoc (dissoc env
                                      :client.repl.local.result)
                              :result
                              (:client.repl.local.result env))
                       env)
                     :form+
                     (list `(let [$.address  ~(:client.repl.address env)
                                  $.key-pair ~(:client.repl.key-pair env)]
                              ~code)))))



(defn .client.repl.query

  ^:private?

  [env code]

  (.client.repl.remote.result env
                              (.client.query (:client.repl.client env)
                                             (:client.repl.address env)
                                             code)))



(defn .client.repl.query.prepare

  ^:private?

  [env code]

  (let [env-2 (.client.repl.local env
                                  code)]
    (.client.repl.query env-2
                        (:result env-2))))



(defn .client.repl.remote.result

  ^:private?

  [env async-result]

  (let [t        (.time.nano)
        client   (:client.repl.client env)
        result   (.a.take async-result
                          (:client.repl.timeout env)
                          client)
        nano+    (- (.time.nano)
                    t)
        timeout? (= result
                    client)]
    (when-not (= (:rtt? env)
                 false)
      (let [out (:stream.out env)]
        (.stream.txt.outln out
                           (str .sys.eol
                                (.term.fg.green)
                                "RTT: "
                                (if timeout?
                                  "timeout"
                                  (str (/ nano+
                                          1e6)
                                       " millis"))
                                (.term.reset)))))
    (if timeout?
      (assoc env
             :result
             :client.repl.timeout)
      (if-let [error (:error result)]
        (assoc env
               :exception? true
               :result     (assoc (:info result)
                                  :code    error
                                  :message (:result result)))
        (assoc env
               :result
               (:result result))))))



(defn .client.repl.transact

  ^:private?

  [env code]

  (let [sequence (:client.repl.sequence env)]
    (.client.repl.remote.result (assoc env
                                       :client.repl.sequence
                                       (inc sequence))
                                (.client.transact (:client.repl.client env)
                                                  (:client.repl.key-pair env)
                                                  (.trx.new.invoke (:client.repl.address env)
                                                                   code 
                                                                   {:sequence sequence})))))




(defn .client.repl.transact.prepare

  ^:private?

  [env code]

  (let [env-2 (.client.repl.local env
                                  code)]
    (.client.repl.transact env-2
                           (:result env-2))))



(defn .client.repl.on.prompt

  ^:private?

  [env]

  (let [out (:stream.out env)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          (:client.repl.host env)
                          ":"
                          (:client.repl.port env)
                          "~"
                          (:client.repl.address env)
                          (:client.repl.mode env)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  env)



(defn .client.sequence

  ^{:doc {:description ["Queries the next `*sequence*` of an address."
                        "Returns an async value that can be awaited with `.a.take`."
                        "The resolved value is the sequence ID that should be used in the next"
                        "transaction for that account."
                        ""
                        "Resolves to `nil` in case of a problem (e.g. account does not exist)."]
          :examples    [{:code (.a.take (.client.sequence (.client.connect {:host "convex.world"}) #11))}]
          :signature   [{:params [client address]}]}}

  [client address]

  (.shell.invoke '.client.sequence
                 client
                 address))



(defn .client.transact

  ^{:doc {:description ["Issues the given transaction."
                        ""
                        "If the transaction has not been pre-signed with `.kp.sign`, `key-pair`"
                        "must be provided."
                        ""
                        "Transactions require consensus and incur fees in Convex Coins."
                        ""
                        "Returns the exact same value as `.client.query`."
                        ""
                        "For more information about transaction, see `(?.shell '.trx)`."
                        ""
                        "If the `client` is connected to the testnet hosted by `convex.world`,"
                        "see `(?.shell '.testnet)` for creating an account and provisioning funds."]
          :signature   [{:params [client signed-transaction]}
                        {:params [client key-pair transaction]}]}}


  ([client signed-transaction]

   (.shell.invoke '.client.transact.signed
                  client
                  signed-transaction))


  ([client key-pair transaction]

   (.shell.invoke '.client.transact
                  client
                  key-pair
                  transaction)))


;;;;;;;;;; CVM log operations


(def .cvmlog

  ^{:private?      true
    :shell.section ["The core `log` functions allows for saving Convex data"
                    "for off-chain use. For instance, a peer might issue off-chain"
                    "notifications based on what is being logged."
                    ""
                    "On-chain, logged data is inaccessible. These few functions"
                    "allowing for inspecting it in the Shell."]}

  nil)



(defn .cvmlog.clear

  ^{:doc {:description ["Clears the CVM log."
                        "Also see `.cvmlog.get`."]
          :examples    [{:code (.cvmlog.clear)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.cvmlog.clear))



(defn .cvmlog.get

  ^{:doc {:description ["Returns the current CVM log."
                        "Values can be logged using the core `log` function."
                        ""
                        "Also see `.cvmlog.clear`."]
          :examples    [{:code (.cvmlog.get)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.cvmlog.get))



;;;;;;;;;; Dependency management


(def .dep
  
  ^{:private?      true
    :shell.section ["Experimental dependency management framework."
                    ""
                    "Convex Lisp dependencies are expressed in a `project.cvx` file"
                    "residing in the root directory of your project."
                    ""
                    "Currently, 3 types of dependencies are supported:"
                    ""
                    "  :relative"
                    "    Project files relative to your `project.cvx` file."
                    "    Expressed as a vector `[:relative \"./path/inside/project\"]`."
                    ""
                    "  :local"
                    "    Local directory containing its own `project.cvx` file."
                    "    Expressed as a vector `[:local \"/path/to/another-project\"]`."
                    ""
                    "  :git"
                    "    Git repository containing its own `project.cvx` file."
                    "    Those will be cloned in a local cached found in `.shell.*root*`."
                    "    Expressed as a vector `[:git \"URL\" \"FULL_COMMIT_SHA\"]`."
                    ""
                    ""
                    "Here is an example of a `project.cvx` file showcasing those 3 types:"
                    ""
                    "  {:deps {main            [:relative \"./src/main\"]"
                    "          another-project [:local \"/home/foo/another-project\"]"
                    "          some-lib        [:git \"https://github.com/foo/bar\""
                    "                                \"38a44d086c95c7b190f47ea17712da130906495f\"]}}"
                    ""
                    "  `main`"
                    "     indicates that the project files can be found under `./src/main`."
                    ""
                    "  `another-project`"
                    "     points to a directory which should contain its own `project.cvx`,"
                    "     typically defining its own relative dependencies."
                    ""
                    "  `some-lib`"
                    "     points to a foreign Git repository that will be cloned locally if not"
                    "     found in the local cache, and that specific commit will be used."
                    ""
                    ""
                    "Inside a relative directory, files meant to be deployed in the Shell as"
                    "actors can be referred to by following the directory hierarchy. This is known"
                    "as the \"actor path\", expressed as a list."
                    ""
                    "E.g. Suppose the above example project defines a file at `./src/main/a/b.cvx`."
                    "     Its actor path would be: (main a b)"
                    "     Now, any other files in your project can require it by adding a similar map"
                    "     as a header which specifies a \"deploy vector\":"
                    ""
                    "        {:deploy [a.b (main a b)]}"
                    ""
                    "     In the requiring file, this will instruct the Shell to deploy `(main a b)` as"
                    "     an actor and its address will be bound to the chosen symbol, `a.b` in this case."
                    "     Such a deploy vector can refer to any number of actor paths."
                    ""
                    "Actor paths are recursive. If `some-lib`, in its own `project.cvx`, defines a relative"
                    "dependency called `lib` with a file `math.cvx`, you could require it similarly to:"
                    ""
                    "        {:deploy [a.b  (main a b)"
                    "                  math (some-lib lib math)]}"
                    ""]}

  nil)



(defn .dep.deploy

  ^{:doc {:description ["Deploys requested actors in the Shell."
                        "Expects a \"deploy vector\"."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map where each symbol from the deploy vector points"
                        "to the address of its corresponding deployed actor."]
          :examples    [{:code (.dep.deploy '[some-alias (path to actor)])}]
          :signature   [{:params [deploy-vector]}]}}

  [deploy-vector]

  (.shell.invoke '.dep.deploy
                 deploy-vector))



(defn .dep.exec

  ^{:doc {:description ["Given an actor path, deploys all dependencies in its deploy"
                        "vector using `.dep.deploy` and defines in the current account"
                        "all deployed addesses under their corresponding symbols."
                        ""
                        "The source of the actor then runs through `eval`, in the current"
                        "account."
                        "Very useful when used alongside `.repl` during development."

                        "See `(?.shell '.dep)`."]
          :examples    [{:code (.dep.exec '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  [actor-path]

  (when-not (list? actor-path)
    (fail :ARGUMENT
          "Requires an actor path"))
  (let [file     (.dep.read actor-path)
        required (:deploy file)]
    (when required
      (reduce (fn [_ [sym addr]]
                (eval `(def ~sym
                            ~addr))
                nil)
              nil
              (.dep.deploy required)))
    (eval (cons 'do
                (:src file)))))



(defn .dep.fetch

  ^{:doc {:description ["Fetches all dependencies required by the given actor path"
                        "or deploy vector."
                        "Does not deploy anything in the Shell but ensures everything"
                        "is available locally."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns some analysis data that is subject to change while"
                        "this dependency management framework is stabilized."]
          :examples    [{:code (.dep.fetch '(main foo bar))}
                        {:code (.dep.fetch '[foo.bar (main foo bar)])}]
          :signature   [{:params [required]}]}}

  [required]

  (.shell.invoke '.dep.fetch
                  (if (list? required)
                    ['_ required]
                    required)))



(defn .dep.read

  ^{:doc {:description ["Reads the content of a file by actor path."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map with"
                        ""
                        "  :deploy"
                        "    Deploy vector of this actor if there is one."
                        ""
                        "  :filename"
                        "    Filename to the file."
                        ""
                        "  :src"
                        "    List of cells representing the source code of this actor."]
          :examples    [{:code (.dep.read '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.

  [actor-path]

  (let [required actor-path]
    (if (list? required)
      (do
        (when (empty? required)
          (fail :ARGUMENT
                "Actor path is empty"))
        (get (.shell.invoke '.dep.read
                            ['x required])
             'x))
      (.shell.invoke '.dep.read
                     required))))



(defn .dep.require.filter

  ^:private?

  [f required]

  (let [n (count required)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (let [sym  (get required
                               i)
                     path (get required
                               (inc i))]
                 (if (f sym
                        path)
                   (conj acc
                         sym
                         path)
                   acc))
               (+ i
                  2))
        acc))))
                      


(defn .dep.test

  ^{:doc {:description ["Executes unit tests by actor path."
                        "The actor is effectively a test suite which specifies all files"
                        "to test in its deploy vector."
                        ""
                        "A map of options map be provided with:"
                        ""
                        "  :focus"
                        "    Vector of metadata keywords, actors by alias, or individual tests to"
                        "    focus. Meaning only corresponding tests will run while other ones will"
                        "    be skipped."
                        ""
                        "  :skip"
                        "    Just like `:focus` but behaves in the opposite way: everything else will run"
                        "    but what is specified in this vector."
                        ""
                        "E.g. These options will run only actors A and B, as aliased in the deploy vector,"
                        "     and skip all tests which have `{:slow? true}` in their metadata:"
                        ""
                        "        {:focus [A B]"
                        "         :skip  [:slow?]}"
                        ""
                        ""
                        "See:"
                        "  (?.shell '.dep)"
                        "  (?.shell '.t)"]
          :examples    [{:code (.dep.test '(test foo bar))}
                        {:code (.dep.test '(test foo bar) {:skip [:slow?]})}]
          :signature   [{:params [actor-path]}
                        {:params [actor-path option+]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.


  ([actor-path]

   (.dep.test actor-path
              nil))


  ([actor-path option+]

   (let [test            (if .*dev?*
                           .t.dev
                           .t.main)
         required        actor-path
         required-2      (if (list? required)
                           (:deploy (.dep.read required))
                           required)
         focus           (:focus option+)
         focus.test      (reduce (fn [actor-sym->test+ x]
                                   (if (and (list? x)
                                            (not (empty? x))
                                            (= (first x)
                                               'lookup))
                                     (let [actor-sym (second x)]
                                       (assoc actor-sym->test+
                                              actor-sym
                                              (conj (or (get actor-sym->test+
                                                             actor-sym)
                                                        #{})
                                                    (nth x
                                                         2))))
                                     actor-sym->test+))
                                 {}
                                 focus)
         option-2+       (assoc option+
                                :focus.test
                                focus.test)
         focus-actor+    (union (set (filter symbol?
                                             focus))
                                (set (keys focus.test)))

         required-3      (if (empty? focus-actor+)
                           required-2
                           (.dep.require.filter (fn [sym _path]
                                                  (contains-key? focus-actor+
                                                                 sym))
                                                required-2))
         skip            (:skip option+)
         skip-actor+     (set (filter symbol?
                                      skip))
         required-4      (if (empty? skip-actor+)
                           required-3
                           (.dep.require.filter (fn [sym _path]
                                                  (not (contains-key? skip-actor+
                                                                      sym)))
                                                required-3))
         option-3+       (assoc option-2+
                                :skip.test
                                (reduce (fn [skip.test x]
                                          (if (and (list? x)
                                                   (not (empty? x))
                                                   (= (first x)
                                                      'lookup))
                                            (let [actor-sym (second x)]
                                              (assoc skip.test
                                                     actor-sym
                                                     (conj (or (get skip.test
                                                                    actor-sym)
                                                               #{})
                                                           (nth x
                                                                2))))
                                            skip.test))
                                        {}
                                        skip))
                         ]
     (test (.dep.deploy required-4)
           (assoc option-3+
                  :focus.meta (set (filter keyword?
                                           focus))
                  :order      (filter symbol?
                                      required-4)
                  :skip.meta  (set (filter keyword?
                                           skip)))))))


;;;;;;;;;; Dev


(def .*dev?*

  ^{:doc {:description ["Boolean indicating if the Shell is in dev mode."
                        "Some utilities uses this value to change behavior."
                        ""
                        "E.g. `.dep.test` will not terminate the process if this value is `false`."]}}

  false)



(defn .dev.set

  ^{:callable? true
    :doc       {:description ["Sets `.*dev*`."]
                :examples    [{:code (.dev.set true)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         .account.core)
    (def .*dev?*
         (boolean enable?))
    (call .account.core
          (.dev.set enable?))))


;;;;;;;;; Etch


(def .db

  ^{:private?      true
    :shell.section ["Etch is a fast, immutable database for Convex data."
                    ""
                    "Writing a cell returns the hash of that cell whereas reading"
                    "requiring a hash and returns the corresponding cell."
                    ""
                    "Only one instance can be open per Shell."
                    "See `.db.open`."]}

  nil)
 
 

(defn .db.flush

  ^{:doc {:description ["Flushes the current Etch instance."
                        ""
                        "Happens automatically when the process terminates gracefully."
                        "Good idea to flush manually once in a while to ensure data"
                        "is persisted on disk."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.flush))



(defn .db.open

  ^{:doc {:description ["Opens an Etch instance."
                        ""
                        "Must be called before calling any other DB function."
                        "Not providing a path will create an instance in a temporary file."
                        "File is created if it does not exist."
                        ""
                        "Attention, only one instance can be open per Shell."]
          :examples    [{:code (.db.open "path/to/file.etch")}]
          :signature   [{:params [path]}]}}


  ([]

   (.db.open nil))


  ([path]

   (.shell.invoke '.db.open
                  (or path
                      (.fs.tmp "convex-shell-"
                               ".etch")))))



(defn .db.path

  ^{:doc {:description ["Returns the path of the current Etch instance (or nil if"
                        "no instance has been open)."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.path))



(defn .db.read
  
  ^{:doc {:description ["Reads a cell by hash from the current Etch instance."
                        "Returns `nil` if no cell is found for that hash."
                        ""
                        "Also see `.db.write`."]
          :examples    [{:code (.db.read 0x1fa0dd51b167d4cca60177d13d731c461eae9cdb4ecd75e1e8f2158251968c66)}]
          :signature   [{:params [hash]}]}}

  [hash]

  (.shell.invoke '.db.read
                 hash))



(defn .db.root.read

  ^{:doc {:description ["Reads the root cell from the current Etch instance."
                        "Returns `nil` if no cell has been persisted to the root."
                        ""
                        "Also see `.db.root.write`."]
          :examples    [{:code (.db.root.read)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.root.read))



(defn .db.root.write

  ^{:doc {:description ["Writes the given `cell` to the root of the current Etch instance."
                        "Otherwise, behaves exactly like `.db.write`."
                        ""
                        "Also see `.db.root.read`."]
          :examples    [{:code (.db.root.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.root.write
                 cell))



(defn .db.size

  ^{:doc {:description ["Returns the full size of the current Etch instance in bytes."
                        ""
                        "Etch always allocates extra room in its instance file whereas"
                        "this value reflects the actual size of the data persisted."
                        ""
                        "E.g. Writing data will increase the data size but not always the"
                        "     filesize."]
          :examples    [{:code (.db.size)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.size))



(defn .db.write

  ^{:doc {:description ["Writes the given `cell` to the current Etch instance."
                        "Returns a new version of that cell."
                        ""
                        "If the cell is needed for more work, the old version should be discarded in favor of"
                        "that new version. This offers 2 main benefits:"
                        ""
                        "  - For more complex cells such as collections, part of the data can be garbage collected"
                        "    in case of memory pressure and retrieved transparently when needed again. Peers use"
                        "    this principle for storing and handling `*state*`s that are even bigger than memory."
                        "    The user does not have anything else to do but discard the old version and work with"
                        "    the new one."
                        ""
                        "  - Subsequent writes involving that cell directly or indirectly are optimized."
                        ""
                        "If the returned value is `nil`, it means the cell was not persisted."
                        "This happens only with a few basic cell types for optimization reasons."
                        "Precisely, those that are so simple they are usually embedded in more complex values:"
                        ""
                        "  - Addresses"
                        "  - Empty collections"
                        "  - Primitives (booleans, bytes, doubles, longs)"
                        "  - Symbolic (keywords and symbols)"
                        ""
                        "Also see `.db.read`."]
          :examples    [{:code (.db.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.write
                 cell))


;;;;;;;;;; Exceptions


(defn .ex.print

  ^{:doc {:description ["Pretty prints the given exception (by default to STDOUT, see `.stream.stdout`)."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.print {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}
                        {:params [stream ex]}]}}

  ([ex]

   (.ex.print nil
              ex))


  ([stream ex]

   (let [msg        (:message ex)
         msg-2      (when (map? msg)
                      (:message msg))
         extra-data (when msg-2
                      (dissoc msg
                              :message))
         trace      (:trace ex)
         trace-2    trace]
     (.stream.txt.outln
       stream
       (str .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Exception code:"
            (.term.reset)
            .sys.eol
            "  "
            (.term.bold)
            (:code ex)
            (.term.bold)
            (.term.fg.red)
            .sys.eol
            "Executing address:"
            (.term.reset)
            .sys.eol
            "  "
            (:address ex)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Message:"
            (.term.reset)
            .sys.eol
            "  "
            (or msg-2
                msg)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Trace:"
            (.term.reset)
            (if (empty? trace-2)
              (str .sys.eol
                   "  None.")
              (apply str
                     (reduce (fn [acc entry]
                               (conj acc
                                     .sys.eol
                                     "  "
                                     (.trunc.str entry)))
                             []
                             trace-2)))
            (if (and extra-data
                     (not (empty? extra-data)))
              (str .sys.eol
                   (.term.bold)
                   (.term.fg.red)
                   "Extra data:"
                   (.term.reset)
                   .sys.eol
                   "  "
                   extra-data)
              ""))))))



(defn .ex.rethrow
  ^{:doc {:description ["Rethrow the given exception."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.rethrow {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}]}}

  [ex]

  (.shell.invoke '.ex.rethrow
                 ex))


;;;;;;;;;; File operations


(def .file

  ^{:private?      true
    :shell.section ["High-level utilities for reading and writing files,"
                    "either as text or as Convex data."
                    ""
                    "Builds on the stream utilities offered by the Shell."
                    "See `(?.shell '.stream)`."]}

  nil)



(defn .file.-handle

  ^:private?

  [x path]

  (if (nil? x)
    [(.gensym "file-")
     (.fs.resolve path)]
    x))



(defn .file.-read

  ^:private?

  [f-in path]

  (let [handle (.file.stream.in path)
        [ok?
         x]    (.state.safe (fn []
                              (f-in handle)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))



(defn .file.-write

  ^:private?

  [f-out path cell option+]

  (let [handle (.file.stream.out path
                                  option+)
        [ok?
         x]    (.state.safe (fn []
                              (f-out handle
                                     cell)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))


;;;


(defn .file.exec

  ^{:doc {:description ["Like `.file.read` but also applies `eval`."]
          :examples    [{:code (.file.exec "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (eval (cons 'do
              (.file.read path))))



(defn .file.lock

  ^{:doc {:description ["Blocks until able to return an exclusive lock on the file at"
                        "the given `path`."
                        ""
                        "Returns `nil` if the lock cannot be acquired, for instance if this"
                        "Shell already holds a lock to the given `path`. This function should"
                        "be used for coordinating different processes."]
          :examples    [{:code (.file.lock "/tmp/some_file")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.file.lock
                 path))



(defn .file.lock.release

  ^{:doc {:description ["Releases a `file-lock` previously obtained with `.file.lock`."]
          :examples    [{:code (.file.lock.release (.file.lock "/tmp/some_file"))}]
          :signature   [{:params [file-lock]}]}}

  [file-lock]

  (.shell.invoke '.file.lock.release
                 file-lock))



(defn .file.read

  ^{:doc {:description ["Returns a list of cells resulting from reading the given file."
                        "Also see `.file.txt.read`."]
          :examples    [{:code (.file.read "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  (.file.-read .stream.in+
               path))



(defn .file.stream.in

  ^{:doc {:description ["Returns a handle to an input stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."]
          :examples    [{:code (.file.stream.in "./my/file.cvx")}]
          :signature   [{:params [path]}]}}


  [path]

  (.shell.invoke '.file.stream.in
                 (.fs.resolve path)
                 path))



(defn .file.stream.out

  ^{:doc {:description ["Returns a handle to an output stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code (.file.stream.out "./my/file.cvx")}
                        {:code (.file.stream.out "./my/file.cvx" {:append? true})}]
          :signature   [{:params [path]}
                        {:params [path option+]}]}}


  ([path]

   (.file.stream.out path
                     nil))


  ([path option+]

   (.shell.invoke '.file.stream.out
                  path
                  (boolean (:append? option+)))))



(defn .file.txt.read

  ^{:doc {:description ["Returns the content of the given file as a string."
                        "Also see `.file.read`."]
          :examples    [{:code (.file.txt.read "some/file.txt")}]
          :signature   [{:params [path]}]}}

  [path]

  (.file.-read .stream.txt.in
               path))



(defn .file.txt.write

  ^{:doc {:description ["Writes the given cell to the given file as a string."
                        "Same options as `.file.stream.out`."
                        ""
                        "Also see `.file.write`."]
          :examples    [{:code (.file.txt.write "some/file.txt" "Some text")}
                        {:code (.file.txt.write "some/file.txt" "Some text" {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.txt.write path
                    cell
                    nil))


  ([path cell option+]

   (.file.-write .stream.txt.outln
                 path
                 cell
                 option+)))



(defn .file.write

  ^{:doc {:description ["Writes the given cell to the given file."
                        "Same options as `.file.stream.out`."
                        "Can be read back as cells with `.file.read`."
                        ""
                        "Also see `.file.txt.write`."]
          :examples    [{:code (.file.write "some/file.cvx" [:a :b])}
                        {:code (.file.write "some/file.cvx" [:a :b] {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.write path
                cell
                nil))


  ([path cell option+]

   (.file.-write .stream.outln
                 path
                 cell
                 option+)))


;;;;;;;;;; Filesystem operations


(def .fs
 
  ^{:private?      true
    :shell.section ["Simple filesystem utilities."]}

  nil)



(defn .fs.copy

  ^{:doc {:description ["Copies the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code (.file.copy "some_dir/foo.txt" "another_dir")}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (.shell.invoke '.fs.copy
                 path-source
                 path-destination))



(defn .fs.delete

  ^{:doc {:description "Deletes the file or the empty folder at the given `path`."
          :examples    [{:code (.file.delete "some-file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.delete
                 path))



(defn .fs.dir?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing directory."]
          :examples    [{:code (.fs.dir? "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.dir?
                 path))



(defn .fs.exists?

  ^{:doc {:description ["Returns `true` if a file or directory exists at the given path."]
          :examples    [{:code (.file.exists? "some_dir/some_file.txt")}]
          :signatures  [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.exists?
                 path))



(defn .fs.file?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing regular file."]
          :examples    [{:code (.fs.file? "some/path")}]
          :signature   [{:params [path]}]}}
  [path]

  (.shell.invoke '.fs.file?
                 path))



(defn .fs.resolve

  ^{:doc {:description ["Returns the given path fully resolved as an absolute path."
                        "Follows symlinks."]
          :examples    [{:code (.fs.resolve "some/../../path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.resolve
                 path))



(defn .fs.size

  ^{:doc {:description ["Returns the size of the file at the given path (in bytes)."
                        "Returns `nil` if the file does not exist."]
          :examples    [{:code (.fs.size "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.size
                 path))



(defn .fs.tmp

  ^{:doc {:description ["Creates a temporary file."
                        "`prefix` and `suffix` for the filename are both optional."]
          :examples    [{:code (.file.tmp)}
                        {:code (.file.tmp ".cvx")}
                        {:code (.file.tmp "some-project_" ".cvx")}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (.fs.tmp nil
            nil))


  ([suffix]

   (.fs.tmp nil
            suffix))


  ([prefix suffix]

   (.shell.invoke '.fs.tmp
                  (or prefix
                      "")
                  (or suffix
                      ""))))



(defn .fs.tmp.dir

  ^{:doc {:description ["Creates a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code (.file.tmp.dir)}
                        {:code (.file.tmp-dir "some-prefix")}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (.fs.tmp.dir nil))


  ([prefix]

   (.shell.invoke '.fs.tmp.dir
                  (or prefix
                      ""))))


;;;;;;;;;; Generators


(defn .gen

  ^{:doc           {:description ["Generates a value given a generator."
                                  ""
                                  "A map of options may be provided:"
                                  ""
                                  "  :seed"
                                  "    Long value."
                                  "    Given the same generator and the same seed, the exact same value"
                                  "    will always be generated."
                                  ""
                                  "  :size"
                                  "    Long >= 0."
                                  "    Impacts the complexity of the generated value."
                                  "    Defaults to 30."
                                  "    E.g. When generating collections, a bigger number will result in"
                                  "         more items on average."
                                  ""
                                  "See `(?.shell '.gen)`."]
                    :examples    [{:code (.gen (.gen.long))}
                                  {:code (.gen (.gen.long) {:seed 42})}
                                  {:code (.gen (.gen.any.vector) {:size 100})}]
                    :signature   [{:params [generator]}
                                  {:params [generator option+]}]}
    :shell.section ["Generating random values in a controlled way."
                    "Excellent for generative testing."
                    ""
                    "See `.gen` for generating values using generators built with the"
                    "`.gen.*` functions."
                    ""
                    "Those generators are considered as resources external to the CVM."
                    "They cannot be persisted in Etch (see `(?.shell '.db)`) and it is"
                    "best not `def`ining them in the environment to be safe."]}


  ([generator]

   (.gen generator
         nil))


  ([generator option+]

   (.shell.invoke '.gen
                  generator
                  (or (:size option+)
                      30)
                  (:seed option+))))



(defn .gen.address

  ^{:doc {:description ["Returns a generator for Addresses."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.address))



(defn .gen.address.actor

  ^{:doc {:description ["Returns a generator for Addresses of existing actors."
                        ""
                        "Throws an exception when failing to do so after 100 trials."
                        "This behavior can be adjusted with the `max-try` argument."]
          :signature   [{:params []}
                        {:params [max-try]}]}}

  ([]

   (.gen.address.actor nil))


  ([max-try]

   (.gen.such-that max-try
                   actor?
                   (.gen.address.existing))))



(defn .gen.address.existing

  ^{:doc {:description ["Returns a generator for existing Addresses."]
          :signature   [{:params []}]}}

  []

  (.gen.bind (.gen.always nil)
             (fn [_]
               (.gen.fmap address
                          (.gen.long.uniform 0
                                             (dec (count (:accounts *state*))))))))



(defn .gen.address.user

  ^{:doc {:description ["Returns a generator for Addresses of users."]
          :signature   [{:params []}]}}

  ([]

   (.gen.address.user nil))


  ([max-try]

   (.gen.such-that max-try
                   (fn [addr]
                     (not (actor? addr))) 
                   (.gen.address.existing))))



(defn .gen.always

  ^{:doc {:description ["Returns a generator that will always generate `x`."]
          :examples    [{:code (.gen.always 42)}]
          :signature   [{:params [x]}]}}
  [x]

  (.shell.invoke '.gen.always
                 x))



(defn .gen.any

  ^{:doc {:description ["Returns a generator for any kind of cell."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any))



(defn .gen.any.coll

  ^{:doc {:description ["Returns a generator for any kind of collection containing"
                        "any kind of values."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any.coll))



(defn .gen.any.list

  ^{:doc {:description ["Returns a generator for Lists containing any kind of values."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any.list))



(defn .gen.any.map

  ^{:doc {:description ["Returns a generator for Maps containing any kind of values."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any.map))



(defn .gen.any.set

  ^{:doc {:description ["Returns a generator for Sets containing any kind of values."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any.set))



(defn .gen.any.vector

  ^{:doc {:description ["Returns a generator for Vectors containing any kind of values."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.any.vector))



(defn .gen.bigint

  ^{:doc {:description ["Returns a generator for BigIntegers."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.bigint))



(defn .gen.bind

  ^{:doc {:description ["Returns a generator that will generate a value from the given"
                        "generator and pass it to the Function `f`. This Function must"
                        "return another generator that will be used to produce the final"
                        "value."
                        ""
                        "Any state change performed in the Function is reversed afterwards."
                        ""
                        "Rarely used but very useful when needed."]
          :signature   [{:params [generator f]}]}}

  [generator f]

  (.shell.invoke '.gen.bind
                 generator
                 f))



(defn .gen.blob

  ^{:doc {:description ["Returns a generator for Blobs."
                        ""
                        "Depending on arguments, the length of these Blobs will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` bytes"
                        "  - Range between `min` and `max` bytes (inclusive)"]
          :signature   [{:params []}
                        {:params [n]}
                        {:params [min max]}]}}

  ([]

   (.shell.invoke '.gen.blob))


  ([n]

   (.shell.invoke '.gen.blob.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.blob.bounded
                  min
                  max)))



(defn .gen.blob-32

  ^{:doc {:description ["Returns a generator for 32-byte Blobs."
                        ""
                        "That length is very common (keys, hashes,...)"]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.blob-32))



(defn .gen.blob-map

  ^{:doc {:description ["Returns a generator for BlobMaps."
                        ""
                        "`generator-key` must be a generator for any kind of Blob."
                        "`generator-value` can be a generator for anything."
                        ""
                        "Depending on arguments, the size of those Blobs will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` key-values"
                        "  - Range between `min` and `max` key-values (inclusive)"]
          :examples    [{:code (.gen (.gen.blob-map (.gen.address) (.gen.long)))}]
          :signature   [{:params [generator-key generator-value]}
                        {:params [generator-key generator-value n]}
                        {:params [generator-key generator-value min max]}]}}

  ([generator-key generator-value]

   (.shell.invoke '.gen.blob-map
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.blob-map.fixed
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.blob-map.bounded
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.boolean

  ^{:doc {:description ["Returns a generator for Booleans."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.boolean))



(defn .gen.char

  ^{:doc {:description ["Returns a generator for Characters."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.char))



(defn .gen.char.alphanum

  ^{:doc {:description ["Returns a generator for alphanumeric Characters."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.char.alphanum))



(defn .gen.check

  ^{:doc {:description ["Generative assertion to be used with `.t.is`."
                        ""
                        "Generative testing is a very powerful tool since it automatically generates"
                        "required values according to the given Vector of generators and ensures the"
                        "given Function always hold true for those values."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :size.max"
                        "    Size is automatically grown with trials until this maximum."
                        "    Defaults to `.gen.check.max.size`."
                        ""
                        "  :n.trial"
                        "    How many trials per run."
                        "    Defaults to `.gen.check.n.trial`."
                        ""
                        "  :seed"
                        "    Seed to start with."
                        "    Ensures the test is always reproducible"]
          :examples    [{:code (.t.is [(.gen.long)] (fn [n] (= n (+ n 0))))}]
          :signature   [{:params [generator+ f]}
                        {:params [generator+ f option+]}]}}

  ([generator+ f]

   (.gen.check generator+
               f
               nil))


  ([generator+ f option+]

   (.shell.invoke '.gen.check
                  generator+
                  f
                  (or (:size.max option+)
                      .gen.check.size.max)
                  (or (:n.trial option+)
                      .gen.check.n.trial)
                  (or (:seed option+)
                      (.time.unix)))))



(def .gen.check.n.trial

  ^{:doc {:description ["Default number of trials when using `.gen.check`."]}}

  100)



(def .gen.check.size.max

  ^{:doc {:description ["Maximum size tested when using `.gen.check`."]}}

  200)



(defn .gen.double

  ^{:doc {:description ["Returns a generator for Doubles."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.double))



(defn .gen.double.bounded

  ^{:doc {:description ["Returns a generator for Doubles conforming to options:"
                        ""
                        "  :infinite?"
                        "    Can the generator produce `##Inf` and `##-Inf`?"
                        "    Defaults to `true`."
                        ""
                        "  :max"
                        "    Maximum value this generator can produce."
                        ""
                        "  :min"
                        "    Minimum value this generator can produce."
                        ""
                        "  :NaN?"
                        "    Can this gnerator produce `##NaN`?"
                        "    Defaults to `true`."]
          :examples    [{:code (.gen (.gen.double.bounded {:max 42.42 :NaN? false}))}]
          :signature   [{:params [option+]}]}}

  [option+]

  (.shell.invoke '.gen.double.bounded
                 (:min option+)
                 (:max option+)
                 (:infinite? option+
                             true)
                 (:NaN? option+
                        true)))



(defn .gen.falsy

  ^{:doc {:description ["Returns a generator for either `false` or `nil`."]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.falsy))



(defn .gen.fmap

  ^{:doc {:description ["Returns a generator such that:"
                        ""
                        "  - First, a value is generated with `generator`"
                        "  - Final value is produced by passing the first one to Function `f`"
                        ""
                        "Any state change performed in the Function is reversed afterwards."
                        ""
                        "See example below about a generator which, based on a generator for Doubles,"
                        "will output tuples where the first item is a Double and the second item is that"
                        "same value as a Long."]
          :examples    [{:code (.gen (.gen.fmap (fn [d] [d (long d)]) (.gen.double)))}]
          :signature   [{:params [f generator]}]}}

  [f generator]

  (.shell.invoke '.gen.fmap
                 f
                 generator))



(defn .gen.freq


  ^{:doc {:description ["Returns a generator which, given a Vector of pairs associating a frequencies"
                        "with generators, will produce values according to those generators by respecting"
                        "those frequencies."
                        ""
                        "See example below about a generator that will, on average, output 9 Booleans"
                        "for every Long."]
          :examples    [{:code (.gen (.gen.freq [[9 (.gen.boolean)] [1 (.gen.long)]]))}]
          :signature   [{:params [pair+]}]}}
  [pair+]

  (.shell.invoke '.gen.freq
                 pair+))



(defn .gen.hex-string

  ^{:doc {:description ["Returns a generator for hex-strings."
                        ""
                        "Depending on arguments, the size of those hex-strings will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` bytes"
                        "  - Range between `min` and `max` bytes"]
          :examples    [{:code (.gen (.gen.hex-string 2 10))}]
          :signature   [{:params []}
                        {:params [n]}
                        {:params [min max]}]}}

  ([]

   (.shell.invoke '.gen.hex-string))


  ([n]

   (.shell.invoke '.gen.hex-string.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.hex-string.bounded
                  min
                  max)))



(defn .gen.keyword

  ^{:doc {:description ["Returns a generator for Keywords."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.keyword))



(defn .gen.list

  ^{:doc {:description ["Returns a generator for Lists where items will be produced using"
                        "the given `generator`."
                        ""
                        "Depending on arguments, the size of those Lists will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` values"
                        "  - Range between `min` and `max` values (inclusive)"]
          :examples    [{:code (.gen (.gen.list (.gen.long) 4))}]
          :signature   [{:params [generator]}
                        {:params [generator n]}
                        {:params [generator min max]}]}}

  ([generator]

   (.shell.invoke '.gen.list
                  generator))


  ([generator n]

   (.shell.invoke '.gen.list.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.list.bounded
                  generator
                  min
                  max)))



(defn .gen.long

  ^{:doc {:description ["Returns a generator for Longs."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.long))



(defn .gen.long.bounded

  ^{:doc {:description ["Returns a generator for Longs conforming to options:"
                        ""
                        "  :max"
                        "    Maximum value this generator can produce."
                        ""
                        "  :min"
                        "    Minimum value this generator can produce."]
          :examples    [{:code (.gen (.gen.long.bounded {:max 42}))}]
          :signature   [{:params [option+]}]}}

  [option+]

  (.shell.invoke '.gen.long.bounded
                 (:min option+)
                 (:max option+)))



(defn .gen.long.uniform

  ^{:doc {:description ["Returns a generator for Longs uniformely selected between `min`"
                        "and `max` (inclusive)."
                        ""
                        "Size will have no effect on this generator."]
          :examples    [{:code (.gen (.gen.long.uniform 0 10))}]
          :signature   [{:params [min max]}]}}

  [min max]

  (.shell.invoke '.gen.long.uniform
                 min
                 max))



(defn .gen.number

  ^{:doc {:description ["Returns a generator for any kind of Number."]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.gen.number))



(defn .gen.map

  ^{:doc {:description ["Returns a generator for Maps where keys will be produced using"
                        "the `generator-key` and values using `generator-values`."
                        ""
                        "Depending on arguments, the size of those Maps will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` key-values"
                        "  - Range between `min` and `max` key-values (inclusive)"]
          :examples    [{:code (.gen (.gen.map (.gen.keyword) (.gen.boolean)))}]
          :signature   [{:params [generator-key generator-value]}
                        {:params [generator-key generator-value n]}
                        {:params [generator-key generator-value min max]}]}}

  ([generator-key generator-value]

   (.shell.invoke '.gen.map
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.map.fixed
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.map.bounded
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.nil

  ^{:doc {:description ["Returns a generator always producing `nil`."]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.nil))



(defn .gen.or

  ^{:doc {:description ["Returns a generator producing values by picking a generator"
                        "from the given Vector."]
          :examples    [{:code (.gen (.gen.or [(.gen.boolean) (.gen.long)]))}]
          :signature   [{:params [generator+]}]}}

  [generator+]

  (.shell.invoke '.gen.or
                 generator+))



(defn .gen.pick

  ^{:doc {:description ["Returns a generator always producing a value by picking one"
                        "from the given Vector."]
          :examples    [{:code (.gen (.gen.pick [:a :b :c]))}]
          :signature   [{:params [x+]}]}}
  [x+]

  (.shell.invoke '.gen.pick
                 x+))



(defn .gen.quoted

  ^{:doc {:description ["Returns a generator that will quote values produced by the"
                        "given generator."]
          :examples    [{:code (.gen (.gen.quoted (.gen.symbol)))}]
          :signature   [{:params [generator]}]}}

  [generator]

  (.shell.invoke '.gen.quoted
                 generator))



(defn .gen.record

  ^{:doc {:description ["Returns a generator producing Maps by following the given"
                        "Map of keys to generators."
                        ""
                        "Typically used for producing record-like Maps."]
          :examples    [{:code (.gen (.gen.record {:age (.gen.long.uniform 0 100) :name (.gen.string)}))}]
          :signature   [{:params [k->gen]}]}}

  [k->gen]

  (let [k+ (keys k->gen)
        n  (count k+)]
    (.gen.fmap (fn [v+]
                 (loop [i      0
                        record {}]
                   (if (< i
                          n)
                     (recur (inc i)
                            (assoc record
                                   (get k+
                                        i)
                                   (get v+
                                        i)))
                     record)))
               (.gen.tuple (values k->gen)))))



(defn .gen.scalar

  ^{:doc {:description ["Returns a generator for producing values that are not collections"]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.scalar))



(defn .gen.set

  ^{:doc {:description ["Returns a generator for Sets where items will be produced using"
                        "the given `generator`."
                        ""
                        "Depending on arguments, the size of those Sets will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` values"
                        "  - Range between `min` and `max` values (inclusive)"]
          :examples    [{:code (.gen (.gen.set (.gen.long) 4))}]
          :signature   [{:params [generator]}
                        {:params [generator n]}
                        {:params [generator min max]}]}}

  ([generator]

   (.shell.invoke '.gen.set
                  generator))


  ([generator n]

   (.shell.invoke '.gen.set.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.set.bounded
                  generator
                  min
                  max)))



(defn .gen.string

  ^{:doc {:description ["Returns a generator for Strings."
                        ""
                        "Depending on arguments, the size of those Strings will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` Characters"
                        "  - Range between `min` and `max` Characters (inclusive)"]
          :examples    [{:code (.gen (.gen.set (.gen.long) 4))}]
          :signature   [{:params []}
                        {:params [n]}
                        {:params [min max]}]}}

  ([]

   (.shell.invoke '.gen.string))


  ([n]

   (.shell.invoke '.gen.string.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.string.bounded
                  min
                  max)))



(defn .gen.string.alphanum

  ^{:doc {:description ["Like `.gen.string` but uses only alphanumeric Characters."]
          :examples    [{:code (.gen (.gen.string.alphanum 10))}]
          :signature   [{:params []}
                        {:params [n]}
                        {:params [min max]}]}}

  ([]

   (.shell.invoke '.gen.string.alphanum))


  ([n]

   (.shell.invoke '.gen.string.alphanum.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.string.alphanum.bounded
                  min
                  max)))



(defn .gen.such-that

  ^{:doc {:description ["Returns a generator for producing values out of the given"
                        "generator that only return `true` on the given `pred`icate"
                        "Function."
                        ""
                        "Throws an exception if `pred` cannot be satisfied after a 100 trials."
                        "This behavior can be adjusted with the `n-max` argument."
                        ""
                        "See example below about a generator that only produces even Longs."]
          :examples    [{:code (.gen (.gen.such-that (fn [n] (zero? (mod n 2))) (.gen.long)))}]
          :signature   [{:params [pred generator]}
                        {:params [max-try pred generator]}]}}

  ([pred generator]

   (.gen.such-that nil
                   pred
                   generator))


  ([max-try pred generator]

   (.shell.invoke '.gen.such-that
                  (or max-try
                      1000)
                  pred
                  generator)))



(defn .gen.symbol

  ^{:doc {:description ["Returns a generator for Symbols."]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.symbol))



(defn .gen.syntax

  ^{:doc {:description ["Returns a generator for producing Syntax objects."
                        ""
                        "Values are produced with `generator-value` (defaults to `.gen.any`)."
                        "Metadata are produced with `generator-meta` (defaults to `.gen.any.map`)."
                        ""
                        "Rarely used."]
          :examples    [{:code (.gen.syntax (.gen.long))}]
          :signature   [{:params []}
                        {:params [generator-value]}
                        {:params [generator-value generator-meta]}]}}

  ([]

   (.shell.invoke '.gen.syntax))


  ([generator-value]

   (.shell.invoke '.gen.syntax.with-value
                  generator-value))


  ([generator-value generator-meta]

   (.shell.invoke '.gen.syntax.with-meta
                  generator-value
                  generator-meta)))



(defn .gen.truthy

  ^{:doc {:description ["Returns a generator for producing any value but `nil` and `false`."]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.gen.truthy))



(defn .gen.tuple

  ^{:doc {:description ["Returns a generator for producing Vector where each value is generated"
                        "from the corresponding position in the given Vector of generators."]
          :examples    [{:code (.gen (.gen.tuple [(.gen.boolean) (.gen.long)]))}]
          :signature   [{:params [generator+]}]}}

  [generator+]

  (.shell.invoke '.gen.tuple
                 generator+))



(defn .gen.vector

  ^{:doc {:description ["Returns a generator for Vectors where items will be produced using"
                        "the given `generator`."
                        ""
                        "Depending on arguments, the size of those Vectors will either:"
                        ""
                        "  - Depend on the size used with `.gen`"
                        "  - Be fixed at `n` values"
                        "  - Range between `min` and `max` values (inclusive)"]
          :examples    [{:code (.gen (.gen.vector (.gen.long) 4))}]
          :signature   [{:params [generator]}
                        {:params [generator n]}
                        {:params [generator min max]}]}}

  ([generator]

   (.shell.invoke '.gen.vector
                  generator))


  ([generator n]

   (.shell.invoke '.gen.vector.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.vector.bounded
                  generator
                  min
                  max)))


;;;;;;;;;; Gensym


(def .*gensym*

  ^:private?

  0)



(defn .gensym

  ^{:callable? true
    :doc       {:description ["Returns a symbol guaranteed to be unique relative to other symbols generated"
                              "with this function in the context of a single process."
                              ""
                              "A prefix string may be provided (default to \"G_\")."
                              ""
                              "Useful for metaprogramming."]
                :examples    [{:code (.gensym)}
                              {:code ($.gensym "some-prefix-")}]
                :signature   [{:params []}
                              {:params [prefix]}]}}

  
  ([]

   (.gensym nil))


  ([prefix]

   (if (= *address*
          .account.core)
     (do
       (let [id .*gensym*]
         (def .*gensym*
              (inc id))
         (symbol (str (or prefix
                          "G_")
                      id
                      "_"
                      (.time.nano)))))
     (call .account.core
           (.gensym prefix)))))


;;;;;;;;;; Juice operations


(def .juice

  ^{:private?      true
    :shell.section ["Juice is the computational unit of Convex."
                    "All operations in a transaction, such as calling a function,"
                    "are measured in this unit."
                    ""
                    "Currently consumed juice can be retrieved with `*juice*`."
                    ""
                    "A `:JUICE` exception is thrown when there is not any left"]}

  nil)



(defn .juice.refill

  ^{:doc {:description ["Refills `*juice*` by setting it to `0`."
                        "Useful to call once in a while when running long operations."]
          :examples    [{:code (.juice.refill)}]
          :signature   [{:params []}]}}

  []

  (.juice.set 0))



(defn .juice.set

  ^{:doc {:description ["Sets `*juice*` to an exact amount."
                        "Useful when there is a need for limiting an operation."]
          :examples    [{:code (.juice.set 10000000)}]
          :signature   [{:params [n-unit]}]}}

  [n-unit]

  (.shell.invoke '.juice.set
                 n-unit))



(defn .juice.track

  ^{:doc {:description ["Tracks the juice consumption of the given transaction."
                        "Any state change is reverted."
                        ""
                        "Returns a vector of 4 elements:"
                        ""
                        "  0: Transaction result"
                        "  1: Juice cost when running as is"
                        "  2: Juice cost after `compile`"
                        "  3: Juice cost after `expand`"]
          :examples    [{:code (.juice.track '(if :a :b :c))}
                        {:code (.juice.track (compile '(if :a :b :c)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (conj (.shell.invoke '.juice.track
                       trx)
        (second (.shell.invoke '.juice.track
                               (compile trx)))
        (second (.shell.invoke '.juice.track
                               (expand trx)))))


;;;;;;;;;; Key pairs


(def .kp

  ^{:private?      true
    :shell.section ["Utilities for creating and handling key pairs (Ed25519)."
                    ""
                    "All user accounts are bounded to a key pair. The public key of an account"
                    "is kept on-chain (e.g. `(:key (account *address*))`). Whoever is holding"
                    "the matching private key can transact with that account."]}

  nil)



(defn .kp.create

  ^{:doc {:description ["Creates a key pair from a seed (32-byte Blob)."
                        "A random seed will be generated if none is provided."]
          :examples    [{:code (.kp.create)}
                        {:code (.kp.create 0xae09224a6683aa86ea7e3eaabc06fe9e8b056b0da5fa741677b11983ad2116c6)}]
          :signature   [{:params []}
                        {:params [seed]}]}}

  ([]

   (.shell.invoke '.kp.create))


  ([seed]

   (.shell.invoke '.kp.create.from-seed
                  seed)))



(defn .kp.pubkey

  ^{:doc {:description ["Extracts the public key from the given `key-pair`."]
          :examples    [{:code (.kp.public-key (.kp.create))}]
          :signature   [{:params [key-pair]}]}}

  [key-pair]

  (.shell.invoke '.kp.pubkey
                 key-pair))



(defn .kp.seed

  ^{:doc {:description ["Extracts the seed from the given `key-pair`."
                        "It can be used in `.kp.create` for recreating the key pair."
                        ""
                        "Attention, it follows that seeds are absolutely confidential."
                        "Anyone with a seed can recreate the exact same key pair."
                        ""
                        "You should NEVER share a seed with anyone unless you know exactly"
                        "what you are doing and what it means."]
          :examples    [{:code (.kp.seed (.kp.create))}]
          :signature   [{:params [key-pair]}]}}

  [key-pair]

  (.shell.invoke '.kp.seed
                 key-pair))



(defn .kp.seed.dev

  ^{:doc {:description ["Given an address, returns a reproducible seed for creating"
                        "a key pair."
                        ""
                        "Attention, this should only be used for dev and testing."
                        ""
                        "See `.kp.create`."]
          :examples    [{:code (.kp.seed.dev #12)}]
          :signature   [{:params [address]}]}}

  [address]

  (.gen (.gen.blob-32)
        {:seed (long address)}))



(defn .kp.sign

  ^{:doc {:description ["Returns a signature of `value` (any cell) by this `key-pair`."
                        ""
                        "More precisely, a record where:"
                        ""
                        "  :public-key"
                        "    Public key matching the private key that signed the value."
                        ""
                        "  :signature"
                        "    Actual signature as a Blob."
                        ""
                        "  :value"
                        "    Cell that was signed."
                        ""
                        "See `.kp.verify` for verifying signatures."]
          :examples    [{:code (.kp.sign (.kp.create) :some-cell)}]
          :signature   [{:params [key-pair value]}]}}

  [key-pair x]

  (.shell.invoke '.kp.sign
                 key-pair
                 x))



(defn .kp.verify

  ^{:doc {:description ["Returns `true` if the `signature` matches `x` for the given `public-key`."
                        ""
                        "See `.kp.sign` for signing data in the first place."]
          :examples    [{:code (.kp.verify (.kp.sign (.kp.create) :foo))}]
          :signature   [{:params [signed data]}
                        {:params [signature public-key value]}]}}


  ([signed-data]

   (.kp.verify (:signature signed-data)
               (:public-key signed-data)
               (:value signed-data)))


  ([signature public-key x]

   (.shell.invoke '.kp.verify
                  signature
                  public-key
                  x)))


;;;;;;;;;; Logging


(def .log

  ^{:private?      true
    :shell.section ["Logging utilities."
                    ""
                    "Logged values are printed as a Vector:"
                    ""
                    "  0: DateTime as an ISO 8601 UTC String (also see `.time.iso`)"
                    "  1: Log level"
                    "  2: Address of current account"
                    "  3: Logged value"
                    ""
                    "Those entries can thus be read back with `.reader.form+`."
                    ""
                    "For logging level and their importance (higher number -> higher order),"
                    "see `.log.level.num`. Values are only logged if the level is >= current level."
                    ""
                    "See `.log.level` for retrieving the current level and `.log.level.set` for"
                    "setting it."
                    ""
                    "See `.log.level.set` for setting an output stream (defaults to STDOUT)."
                    ""
                    "See the various `.log.LEVEL*` macros for logging values depending on the"
                    "current level. Values are computed only they can be logged according to"
                    "the current level."]}

  nil)



(defn .log.level

  ^{:doc {:description ["Returns the current log level or nil if logging is disabled."]
          :examples    [{:code (.log.level)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.log.level))



(defn .log.level.can?

  ^:private?

  [target]

  (if-let [level (.log.level)]
    (<= (get .log.level.num
             level)
        target)
    false))



(defn .log.level.set

  ^{:doc {:description ["Sets the current log level or disables logging by providing `nil`."]
          :examples    [{:code (.log.level.set :debug)}]
          :signature   [{:params [level]}]}}

  [level]

  (.shell.invoke '.log.level.set
                 level))


(def .log.level.num

  ^{:doc {:description ["Map of log levels to order."]}}

  {:trace  0
   :debug  1
   :info   2
   :warn   3
   :error  4
   :fatal  5
   :report 6})



(defn .log.out

  ^{:doc {:description ["Returns the current output stream for logging values."]
          :examples    [{:code (.log.out)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.log.out))



(defn .log.out.set

  ^{:doc {:description ["Sets the output stream to use when logging values."
                        ""
                        "See `(?.shell '.stream)` about streams."]
          :examples    [{:code (.log.out.set (.file.stream.output "/tmp/log.cvx"))}]
          :signature   [{:params [stream]}]}}

  [stream]

  (.shell.invoke '.log.out.set
                 stream))


;;;


(defmacro .log.trace*

  ^{:doc {:description ["Macro for logging `x` at `:trace` level."]
          :examples    [{:code (.log.trace* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 0)
     (.shell.invoke '.log
                    :trace
                    ~x)))



(defmacro .log.debug*

  ^{:doc {:description ["Macro for logging `x` at `:debug` level."]
          :examples    [{:code (.log.debug* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 1)
     (.shell.invoke '.log
                    :debug
                    ~x)))



(defmacro .log.info*

  ^{:doc {:description ["Macro for logging `x` at `:info` level."]
          :examples    [{:code (.log.info* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 2)
     (.shell.invoke '.log
                    :info
                    ~x)))



(defmacro .log.warn*

  ^{:doc {:description ["Macro for logging `x` at `:warn` level."]
          :examples    [{:code (.log.warn* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 3)
     (.shell.invoke '.log
                    :warn
                    ~x)))



(defmacro .log.error*

  ^{:doc {:description ["Macro for logging `x` at `:error` level."]
          :examples    [{:code (.log.error* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 4)
     (.shell.invoke '.log
                    :error
                    ~x)))



(defmacro .log.fatal*

  ^{:doc {:description ["Macro for logging `x` at `:fatal` level."]
          :examples    [{:code (.log.fatal* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 5)
     (.shell.invoke '.log
                    :fatal
                    ~x)))



(defmacro .log.report*

  ^{:doc {:description ["Macro for logging `x` at `:report` level."]
          :examples    [{:code (.log.report* 42)}]
          :signature   [{:params [x]}]}}
  [x]

  `(when (.log.level.can? 6)
     (.shell.invoke '.log
                    :report
                    ~x)))


;;;;;;;;;; Peers


(def .peer

  ^{:private?      true
    :shell.section ["Running Convex peers and networks."
                    ""
                    "See `.peer.init` and `.peer.init.sync` for creating peers."]}

  nil)



(defn .peer.connection+

  ^{:doc {:description ["Returns a Set containing the public keys of the peers the"
                        "given `peer` is currently connected to."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.connection+
                 peer))



(defn .peer.controller

  ^{:doc {:description ["Returns the Address of the account controlling the given `peer`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.controller
                 peer))



(defn .peer.data

  ^{:doc {:description ["Returns a map containing the current data maintained by the given"
                        "`peer` such as the current State."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.data
                 peer))



(def .peer.default.port

  ^{:doc {:description ["Default port used by peers."]}}

  18888)



(defn .peer.endpoint

  ^{:doc {:description ["Returns a map containing the `:host` and the `:port` used"
                        "by the given `peer`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.endpoint
                 peer))



(defn .peer.init

  ^{:doc {:description ["Initializes and returns a `peer`."
                        ""
                        "Requires the key pair of the account that will control the peer."
                        "Controller will be deduced from the `:state` option."
                        "See `(?.shell 'kp)` about key pairs."
                        ""
                        "Requires an Etch instance."
                        "See `(?.shell '.db) about Etch."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :delay.poll"
                        "    Interval in milliseconds at which this peer will poll beliefs from other peers"
                        "    as an anti-entropy measure."
                        ""
                        "  :host"
                        "    Host this peer will bind to when started."
                        "    Defaults to `\"localhost\"`."
                        ""
                        "  :n.max.sibling"
                        "    Maximum number of connections to other peers this peer can maintain."
                        "    Defaults to `10`."
                        ""
                        "  :port"
                        "    Port this peer will bind to when started."
                        "    Defaults to `.peer.default.port`."
                        ""
                        "  :state"
                        "    A State to use as the Genesis State."
                        "    When not provided, will be read from the current Etch instance according to"
                        "    the `:root-key` option."
                        ""
                        "  :root-key"
                        "    Assuming the root of Etch is a Map, all peer data will be stored and maintained"
                        "    under this key."
                        "    Defaults to `nil` meaning the data will be stored directly at the root."
                        ""
                        "  :url"
                        "    When provided, the controller will automatically transact to save this URL"
                        "    as the public URL of the peer."
                        ""
                        "See `.peer.start` for actually starting the peer."
                        "Also see `.peer.init.sync`."]
          :examples    [{:code (.peer.init some-kp {:state (.state.genesis)})}]
          :signature   [{:params [key-pair]}
                        {:params [key-pair option+]}]}}


  ([key-pair]

   (recur key-pair
          nil))


  ([key-pair option+]

   (let [host          (or (:host option+)
                           "localhost")
         n.max.sibling (or (:n.max.sibling option+)
                           10)
         port          (or (:port option+)
                           .peer.default.port)
         state         (:state option+)
         poll-delay    (or (:delay.poll option+)
                           2000)
         root-key      (:root-key option+)
         url           (:url option+)]
     (if state
       (.shell.invoke '.peer.init.state
                      state
                      key-pair
                      host
                      n.max.sibling
                      poll-delay
                      port
                      root-key
                      url)
       (.shell.invoke '.peer.init.db
                      key-pair
                      host
                      n.max.sibling
                      poll-delay
                      port
                      root-key
                      url)))))



(defn .peer.init.sync

  ^{:doc {:description ["Similar to `.peer.init` but the peer will sync the current State of"
                        "the network from another peer."
                        ""
                        "Common options are:"
                        ""
                        "  :delay.poll"
                        "  :host"
                        "  :n.max.sibling"
                        "  :port"
                        "  :root-key"
                        "  :url"
                        ""
                        ""
                        "Custom options are:"
                        ""
                        ":remote.host"
                        "  Host of the remote peer to sync to."
                        "  Defaults to `\"localhost\"`."
                        ""
                        ":remote.port"
                        "  Port of the remote peer to sync to."
                        "  Defaults to `.peer.default.port`."]
          :examples    [{:code (.peer.init.sync some-kp {:remote.host "42.123.24.321"})}]
          :signature   [{:params [key-pair]}
                        {:params [key-pair option+]}]}}


  ([key-pair]

   (recur key-pair
          nil))


  ([key-pair option+]

   (.shell.invoke '.peer.init.sync
                  (or (:remote.host option+)
                      "localhost")
                  (or (:remote.port option+)
                      .peer.default.port)
                  key-pair
                  (or (:host option+)
                      "localhost")
                  (or (:n.max.sibling option+)
                      10)
                  (or (:delay.poll option+)
                      2000)
                  (or (:port option+)
                      .peer.default.port)
                  (:root-key option+)
                  (:url option+))))



(defn .peer.n.belief.received

  ^{:doc {:description ["Returns the number of beliefs the given `peer` has received."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.n.belief.received
                 peer))



(defn .peer.n.belief.sent

  ^{:doc {:description ["Returns the number of beliefs the given `peer` has sent."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.n.belief.sent
                 peer))



(defn .peer.order

  ^{:doc {:description ["Returns the current Order of the given `peer`."]
          :signature   [{:params [peer]}]}}


  ([peer]

   (.peer.order peer
                nil))
   

  ([peer pubkey]

   (get-in (.peer.data peer)
           [:belief
            :orders
            (or pubkey
                (.peer.pubkey peer))
            :value])))



(defn .peer.persist

  ^{:doc {:description ["Persists the current peer data to Etch."
                        ""
                        "Done automatically when stopping the peer or when cleanly shutting down"
                        "the Shell."
                        ""
                        "See `.db.flush` to fully flush everything."
                        "Also see `.peer.data`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.persist
                 peer))



(defn .peer.pubkey

  ^{:doc {:description ["Returns the public key of the given `peer`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.pubkey
                 peer))



(defn .peer.start

  ^{:doc {:description ["Starts the given `peer`."
                        ""
                        "See `.peer.init` and `.peer.init.sync` for creating them"
                        "in the first place."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.start
                 peer))



(defn .peer.state

  ^{:doc {:description ["Returns the current network State according to the given `peer`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.state
                 peer))



(defn .peer.status

  ^{:doc {:description ["Returns a Vector describing the current status of the given `peer`."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.status
                 peer))



(defn .peer.stop

  ^{:doc {:description ["Stops the given `peer`."
                        ""
                        "Attention, cannot be restarted with `.peer.start`."
                        "Simply recreate the peer if needed."]
          :signature   [{:params [peer]}]}}

  [peer]

  (.shell.invoke '.peer.stop
                 peer))


;;;;;;;;;; PFX stores


(def .pfx

  ^{:private?      true
    :shell.section ["PFX stores securely index key pairs in flat files by alias (strings)."
                    ""
                    "They can be protected by a passphrase (optional) and each key in a store"
                    "is additionally protected by its own passphrase (mandatory)."
                    ""
                    "All `.pfx.*` functions may throw in case of error."
                    ""
                    "See `(?.shell '.kp)` about key pairs."]}

  nil)



(defn .pfx.alias+

  ^{:doc {:description ["Returns a set of aliases available in the given `store`."]
          :examples    [{:code (.pfx.alias+ (.pfx.create "/tmp/store.pfx"))}]
          :signature   [{:params [store]}]}}

  [store]

  (.shell.invoke '.pfx.alias+
                 store))



(defn .pfx.create

  ^{:doc {:description ["Creates a new PFX store, optionally protected by a `passphrase` (string)."
                        "Already stores it at the given `path`."
                        "Also see `.pfx.load` and `.pfx.save`."]
          :examples    [{:code (.pfx.create "/tmp/store.pfx")}
                        {:code (.pfx.create "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [path]}
                        {:params [path passphrase]}]}}

  ([path]

   (.pfx.create path
                nil))


  ([path passphrase]

   (.shell.invoke '.pfx.create
                  path
                  (or passphrase
                      ""))))



(defn .pfx.kp.get

  ^{:doc {:description ["Retrieves a key pair from the given `store` by `alias`."
                        ""
                        "Returns `nil` if the alias does not exist and throws an exception"
                        "if the passphrase does not match."
                        ""
                        "Also see `.pfx.kp.set`."]
          :examples    [{:code (.pfx.kp.get some-store "some-alias" "my-passphrase")}]
          :signature   [{:params [store alias passphrase]}]}}

  [store alias passphrase]

  (.shell.invoke '.pfx.kp.get
                 store
                 (str alias)
                 passphrase))



(defn .pfx.kp.rm

  ^{:doc {:description ["Removes a key pair from the given `store` by `alias`."
                        "Returns `store`."]
          :examples    [{:code (.pfx.kp.rm some-store "some-alias")}]
          :signature   [{:params [store alias]}]}}

  [store alias]

  (.shell.invoke '.pfx.kp.rm
                 store
                 alias))



(defn .pfx.kp.set

  ^{:doc {:description ["Adds the given `key-pair` to the given `store` under `alias`."
                        "Alias will be the public key of `key-pair` if not provided."
                        "Returns `store`."
                        "Also see `.pfx.kp.get`."]
          :examples    [{:code (.pfx.kp.set some-store (.kp.create) "my-passphrase")}
                        {:code (.pfx.kp.set some-some "some-alias" (.kp.create) "my-passphrase")}]
          :signature   [{:params [store key-pair passphrase]}
                        {:params [store alias key-pair passphrase]}]}}


  ([store key-pair passphrase]

   (.pfx.kp.set store
                (str (.kp.pubkey key-pair))
                key-pair
                passphrase))


  ([store alias key-pair passphrase]

   (.shell.invoke '.pfx.kp.set
                  store
                  (str alias)
                  key-pair
                  passphrase)))



(defn .pfx.load

  ^{:doc {:description ["Loads an existing store from the given `path`, which"
                        "may be protected by a passphrase."
                        ""
                        "Also see `.pfx.save`."]
          :examples    [{:code (.pfx.load "/tmp/store.pfx")}
                        {:code (.pfx.load "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [path]}
                        {:params [path passphrase]}]}}


  ([path]

   (.pfx.load path
              nil))


  ([path passphrase]

   (.shell.invoke '.pfx.load
                  path
                  (or passphrase
                      ""))))



(defn .pfx.save

  ^{:doc {:description ["Saves the given `store` to the file at the given `path`, optionally"
                        "protected by a `passphrase`."
                        ""
                        "Also see `.pfx.load`."]
          :examples    [{:code (.pfx.save some-store "/tmp/store.pfx")}
                        {:code (.pfx.save some-store "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [store path]}
                        {:params [store path passphrase]}]}}


  ([store path]

   (.pfx.save store
              path
              nil))


  ([store path passphrase]

   (.shell.invoke '.pfx.save
                  store
                  path
                  (or passphrase
                      ""))))


;;;;;;;;;; Processes


(def .process

  ^{:private? true
    :shell.section ["Shelling out processes."]}

  nil)



(defn .process.kill

  ^{:doc {:description ["Kills a process started with `.process.run`."]
          :signature   [{:params [process]}]}}

  [process]

  (.shell.invoke '.process.kill
                 (:process process)))



(defn .process.run

  ^{:doc {:description ["Runs a process by providing a command."
                        ""
                        "A command is a Vector of Strings where the first item"
                        "is the program to invoke and other items are arguments."
                        "All arguments must be separated Strings."
                        ""
                        ""
                        "A Map of options may be provided:"
                        ""
                        "  :dir"
                        "    Working directory."
                        "    Defaults to `(.sys.cwd)`."
                        ""
                        "  :env"
                        "    Environment Map to use for the process (String -> String)."
                        "    Defaults to the current environment."
                        "    Usually, the `:env.extra` option is preferred."
                        ""
                        "  :env.extra"
                        "    Similar to the `:env` option but those key-values will be merged into"
                        "    the current environment and passed to the process."
                        ""
                        "  :err"
                        "    Output stream to use as STDERR for the process."
                        ""
                        "  :in"
                        "    Output stream to use as STDIN for the process."
                        ""
                        "  :out"
                        "    Output stream to use as STDOUT for the process."
                        ""
                        ""
                        "Returns a process Map:"
                        ""
                        "  :err"
                        "    STDERR stream of the process."
                        "    Can be read as an input stream unless it has been provided as an option."
                        ""
                        "  :exit"
                        "    Async value resolving to the exit code of the process."
                        "    `0` means the process terminated normally."
                        "    Can be awaited with `.a.take`."
                        "    See also `.process.success?`."
                        ""
                        "  :in"
                        "    STDIN stream of the process."
                        "    Can be written to as an output stream unless it has been provided as an option."
                        ""
                        "  :out"
                        "    STDOUT stream of the process."
                        "    Can be read as an input stream unless it has been provided as an option."
                        ""
                        "See `(!.shell '.stream)` about streams."]
          :examples    [{:code (.stream.txt.in (:out (.process.run ["echo" "Convex rocks"])))}]
          :signature   [{:params [command]}
                        {:params [command option+]}]}}


  ([command]

   (.process.run command
                 nil))


  ([command option+]

   (.shell.invoke '.process.run
                  (map (fn [x]
                         (if (str? x)
                           x
                           (.cell.str x)))
                       command)
                  (:dir option+)
                  (:env option+)
                  (:env.extra option+)
                  (:err option+)
                  (:in option+)
                  (:out option+))))



(defn .process.success?

  ^{:doc {:description ["Awaits the given `process` (started with `.process.run`) and"
                        "returns `true` if the exit code is `0`."
                        ""
                        "An optional timeout in milliseconds can be provided."
                        "If the process does not terminate before this timeout elapses,"
                        "`:timeout` is returned."]
          :signature   [{:params [process]}
                        {:params [process millis]}]}}


  ([process]

   (zero? (.a.take (:exit process))))


  ([process millis]

   (let [x (.a.take (:exit process)
                    millis
                    :timeout)]
     (and (not (= x
                  :timeout))
          (zero? x)))))


;;;;;;;;;; Project files


(def .project.*dir*

  ^{:doc {:description ["Path to the directory containing `project.cvx`."
                        "Also see `.project.dir.set`."]}}

  "./")



(defn .project.dir.set

  ^{:callable? true
    :doc       {:description ["Points `.project.*dir*` to another directory."]
                :examples    [{:code (.project.dir.set "some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         .account.core)
    (do
      (when-not (.fs.dir? dir)
        (fail :ARGUMENT
              "Given path is not a directory"))
      (def .project.*dir*
           dir))
    (call .account.core
          (.project.dir.set dir))))


;;;;;;;;;; Reader


(def .reader

  ^{:private?      true
    :shell.section ["Section relating to reading cells from text."
                    "Might grow in the future."]}

  nil)



(defn .reader.form+

  ^{:doc {:description ["Returns a list of cells read from the given string."]
          :examples    [{:code (.reader.form+ ":a :b :c")}]
          :signature   [{:params [string]}]}}
  [string]

  (.shell.invoke '.reader.form+
                 string))


;;;;;;;;;; REPL


(defn .repl

  ^{:doc {:description ["Starts a Read-Eval-Print-Loop for working interactively."
                        ""
                        "By default, a prompt is printed and the user can introduce a lines of cells to evaluate."
                        "Results and exceptions are printed."
                        "By default, stops when the user enter `:q` or `:quit`."
                        "The result of the previous command is made available under `$`."
                        ""
                        "A map of options may be provided to alter the behavior of the REPL."
                        "Functions in this map takes an \"env\" map and must returns it, altered or not."
                        "The env map starts with those options. Users may want to attach additional information."
                        ""
                        "Tweaking these option may lead to interesting ways of doing inter-process communication"
                        "through STDIO."
                        ""
                        "Options may be:"
                        ""
                        "  :eval"
                        "    Function for producing a result given cells attached under `:result`."
                        "    Defaults to `.repl.eval`."
                        "    If the result is a caught exception, `:exception?` can be set to `true`"
                        "    to pretty print it."
                        ""
                        "  :on.ex"
                        "    Function for acting when `:eval` throws an exception."
                        "    Exception is attached under `:result`."
                        "    Defaults to `.repl.on.ex`."
                        ""
                        "  :on.ex.reader"
                        "    Function for acting on reader errors, when an input line is not valid Convex data."
                        "    Besides the env map, also takes the message of the reader exception."
                        "    Defaults to `.repl.on.ex.reader`."
                        ""
                        "  :on.prompt"
                        "    Function for acting prior to asking for input (e.g. print a prompt)."
                        "    Defaults to `.repl.on.prompt`."
                        ""
                        "  :on.result"
                        "     Function for acting when a result is produced."
                        "     Defaults to `.repl.on.result`."
                        ""
                        "  :stop?"
                        "    Function for deciding if the REPL should stop after reading a line but before evaluating it."
                        "    Defaults to `.repl.stop?`."
                        ""
                        "  :stream.in"
                        "    Input stream for reading lines of cells."
                        "    Defaults to STDIN (returned by `.stream.stdin`)."
                        ""
                        "  :stream.out"
                        "    Output stream for printing results."
                        "    Defaults to STDOUT (returned by `.stream.stdout`)."
                        ""
                        "  :stream.out.limit"
                        "    The `:on.result` function may use for truncating the output, useful for ensuring that"
                        "    printing large results does not block everything."
                        "    See `.repl.on.result`, the default for `:on.result`."]
          :examples    [{:code (.repl)}]
          :signature   [{:params []}
                        {:params [option+]}]}
    :shell.section ["See `(? '.repl)` for driving an interactive workflow."
                    "The REPL is started automatically when the Shell is started"
                    "without instructions."]}


  ([]

   (.repl nil))


  ([option+]

   (loop [env (merge {:eval         .repl.eval
                      :on.ex        .repl.on.ex
                      :on.ex.reader .repl.on.ex.reader
                      :on.prompt    .repl.on.prompt
                      :on.result    .repl.on.result
                      :stop?        .repl.stop?
                      :stream.in    (.stream.stdin)
                      :stream.out   (.stream.stdout)}
                     option+)]
     (let [env-2 ((:on.prompt env) env)
           [read?
            x]    (.state.safe (fn []
                                 (.stream.line (:stream.in env-2))))]
       (if read?
         ;;
         ;; Successful read.
         ;;
         (let [form+   x
               env-3 (assoc env-2
                            :form+
                            form+)]
           (cond
             ;;
             (nil? form+)
             env-3
             ;;
             (empty? form+)
             (recur env-3)
             ;;
             ((:stop? env-3) env-3)
             env-3
             ;;
             (let [[ok?
                    x]   (.state.safe (fn []
                                        ((:eval env-3) (assoc (dissoc env-3
                                                                      :exception?)
                                                              :form+
                                                              form+))))
                   env-4 (if ok?
                             (let [env-4 x]
                               ((:on.result env-4) env-4))
                             (let [ex x]
                               ((:on.ex env) (assoc env-3
                                                    :result
                                                    ex))))]
               (if (contains-key? env-4
                                  :result)
                 (recur env-4)
                 env-4))))
         ;;
         ;; Reading input failed.
         ;;
         (let [ex x]
           (if (= (:code ex)
                  :READER)
             (recur ((:on.ex.reader env) env
                                         (:message ex)))
             (.ex.rethrow ex))))))))



(defn .repl.eval

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, applies `:form+` to `eval` and attaches the result"
                        "under `:result`."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (assoc env
         :result
         (eval (concat `(let [$ (quote ~(:result env))])
               (:form+ env)))))



(defn .repl.on.ex

  ^{:doc {:description ["See `.repl`."
                        "Pretty-prints the exception found under `:result` in the REPL env."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (let [out (:stream.out env)
        ex  (:result env)]
    (.ex.print out
               ex)
    (.stream.txt.outln out
                       ""))
  env)



(defn .repl.on.ex.reader

  ^{:doc {:description ["See `.repl`."
                        "Prints the reader error that occured when the REPL was parsing input."]
          :signature   [{:params [repl-env error-message]}]}}

  [env message]

  (.stream.txt.outln (:stream.out env)
                     (str .sys.eol
                          (.term.fg.red)
                          (.term.bold)
                          "Input cannot be parsed as Convex Lisp:"
                          (.term.reset)
                          .sys.eol
                          "  "
                          message
                          .sys.eol))
  env)



(defn .repl.on.prompt

  ^{:doc {:description ["See `.repl`."
                        "Prints a simple prompt."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (let [out (:stream.out env)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          (or (:name env)
                              "")
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  env)



(defn .repl.on.result

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, prints `:result` to `:stream.out`."
                        ""
                        "Truncates output towards `:stream.out.limit` in `:env` (if"
                        "provided"]
          :signature   [{:params [repl-env]}]}}

  [env]

  (if (:exception? env)
    ((:on.ex env) env)
    (let [limit  (:stream.out.limit env)
          out    (:stream.out env)
          result (:result env)]
      (.stream.txt.out out
                       .sys.eol)
      (if limit
        (.stream.txt.out out
                         (.cell.str limit
                                    result))
        (.stream.out out
                     result))
      (.stream.txt.out out
                       .sys.eol)
      (.stream.txt.out out
                       .sys.eol)
      (.stream.flush out)))
  env)



(defn .repl.stop?

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, returns `true` if the first cell in"
                        "`:form+` is `:q` or `:quit`."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (contains-key? #{:q
                   :quit}
                 (first (:form+ env))))


;;;;;;;;;; Shell


(def .shell

  ^{:private?      true
    :shell.section ["Shell configuration, such as selectively removing some of"
                    "the extra features it offers."]}

  nil)



(defn .shell.inspect

  ^{:doc {:description ["Returns a set of symbols expressing features offered by the Shell."
                        "Those symbols often relates directly to functions and are not native"
                        "to the regular Convex Virtual Machine."
                        ""
                        "See also `.shell.limit`."]
          :examples    [{:code (.shell.inspect)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.shell.inspect))



(def .shell.invoke

  ^{:doc {:description ["Main entry point for accessing features offered by the Shell."
                        "Aka the \"invoker\"."
                        "Shell functions often delegates to it."
                        ""
                        "The regular user should never have to call this function directly."
                        "For experts only."]
          :examples    [{:code (.shell.invoke '.time.unix)}]
          :signature   [{:params [feature & arg+]}]}}

  ;; Injected from Clojure.

  ^:private?

  nil)



(defn .shell.limit

  ^{:doc {:description ["Limits the features offered by the Shell."
                        ""
                        "See `.shell.inspect` about getting the set of currently available features."
                        "This function takes a similar set and will limit `.shell.invoke` to those only."
                        ""
                        "Thus, an empty set removes all Shell features, resulting in a pure Convex Virtual Machine."
                        ""
                        "A common pattern is to call `.shell.limit` inside `.state.tmp*`, so that the Shell"
                        "is limited only temporarily."]
          :examples    [{:code (.shell.limit #{})}
                        {:code (.shell.limit (disj (.shell.inspect) '.time.unix))}]
          :signature   [{:params [feature-set]}]}}

  [feature-set]

  (.shell.invoke '.shell.limit
                 feature-set))



(defn .shell.main

  ^:private?

  [src]

  (let [[ok?
         x]  (.state.safe (fn []
                            (.reader.form+ src)))]
    (cond
      ;;
      ok?
      (let [form+ x]
        (if (empty? form+)
          (do
            (.dev.set true)
            (.stream.txt.outln
              (str (.term.fg.blue)
                   (.term.bold)
                   "Convex Shell (REPL mode)"
                   (.term.reset)
                   .sys.eol
                   "Enter transactions and build a new world."
                   .sys.eol
                   .sys.eol
                   "Powered by Protosens SRL and collaborators."
                   .sys.eol
                   "For help, type: "
                   (.term.bold)
                   "(?)"
                   (.term.reset)
                   .sys.eol))
            (.repl)
            nil)
          (eval (cons 'do
                      form+))))
      ;;
      (= (:code x)
         :READER)
      (do
        (.stream.txt.errln
           (str .sys.eol
                (.term.fg.red)
                (.term.bold)
                "Input cannot be parsed as Convex Lisp:"
                (.term.reset)
                .sys.eol
                "  "
                (:message x)
                .sys.eol))
        (.sys.exit 4))
      ;;
      (fail :SHELL.FATAL
            {:message "Initialization problem while reading input"}))))



(def .shell.*root*

  ^{:doc {:description ["Root directory used by the Shell."
                        "E.g. This is where `.dep.fetch` caches foreign dependencies."
                        ""
                        "Also see `.shell.root.set`."]}}

  "~/.convex-shell")



(defn .shell.root.set

  ^{:callable? true
    :doc       {:description ["Points `.shell.*root*` to another directory."
                              "Given path must point to an existing one."]
                :examples    [{:code (.shell.root.set "./some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         .account.core)
    (do
      (when-not (str? dir)
        (fail :ARGUMENT
              "Given path is not a string"))
      (def .shell.*root*
           dir))
    (call .account.core
          (.shell.root.set dir))))


;;;;;;;;;; Creating and handling states


(def .state

  ^{:private?      true
    :shell.section ["Convex transactions alter the global state of the network."
                    "In Convex Lisp, the current state is available under `*state*`."
                    ""
                    "The Shell offers extra features such as `.state.switch` which allows"
                    "jumping to another state. For instance, one that has been loaded"
                    "from the Etch database (see `(?.shell '.db)`)."]}

  nil)



(defn .state.core.vanilla

  ^{:doc {:description ["Returns `state` with the environment and the metadata of the core"
                        "account (see `.account.core`) restored to genesis without any of"
                        "the extra utilities provided by the Convex Shell."]
          :examples    [{:code (.state.core.vanilla *state*)}]
          :signature   [{:params [state]}]}}

  [state]

  (.shell.invoke '.state.core.vanilla
                 state))



(defn .state.do

  ^{:doc {:description ["Like `.state.safe` but returns only a boolean, where `false` indicates"
                        "that an exception was thrown (and the state reverted)."
                        ""
                        "This is mostly used for particular situations such as benchmarking to avoid"
                        "unnecessary work done by the Shell when forwarding exceptions to the user"
                        "as in `.state.safe`."
                        ""
                        "See `.state.do*` for a convenience macro."]
          :examples    [{:code (.state.do (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.do
                 f))



(defmacro .state.do*

  ^{:doc {:description ["Executes the given code exactly like `.state.do`."
                        "More convenient to use."]
          :examples    [{:code (.state.do* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}
  [& form+]

  `(.state.do ~(concat '(fn [])
                       form+)))



(defn .state.genesis

  ^{:doc {:description ["Generates and returns a genesis state."
                        ""
                        "The genesis state is the original state used by a Convex network"
                        "to bootstrap. Such a state does not have any of the features offered"
                        "by the Shell."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :peer+"
                        "    Vector of maps describing peers such as:"
                        ""
                        "      :host"
                        "        Host to advertise in the URL of that peer."
                        "        Defaults to `\"localhost\"."
                        ""
                        "      :key (mandatory)"
                        "        Public key identifying the peer and its controller."
                        "        Must be unique."
                        ""
                        "      :metadata"
                        "        Map of metadata for that peer."
                        ""
                        "      :port"
                        "        Port to advertise the URL of that peer."
                        "        Defaults to `.peer.default.port`)."
                        ""
                        "      :stake"
                        "        Custom stake the controller will put on this peer."
                        "        Defaults to 1 / 3 of the initial controller funds."
                        ""
                        ""
                        "If `:peer+` is not provided, a single peer is created using the public key"
                        "of `(.kp.create .account.0-key)`."
                        ""
                        "Based on the provided public keys (which MUST be distinct):"
                        ""
                        "  - A special genesis user is created with 50% of available user funds,"
                        "    associated with the first public key"
                        "  - For the address of that special genesis user, see `.account.genesis`"
                        "  - For each public key, an additional user is created, sharing the remaining"
                        "    user funds equally"
                        "  - Each additional user becomes the controller of a declared peers (see the"
                        "    `:peers` key in the state)"
                        "  - Each peer uses the same public key as its controller"
                        "  - Each user stakes 1 / 3 of its balance on its peer"
                        ""
                        ""
                        "See `(?.shell '.kp)` about creating key pairs."]
          :examples    [{:code (.state.genesis)}
                        {:code (.state.genesis {:peer+ [{:key (.kp.pubkey (.kp.create))}]})}]
          :signature   [{:params []}
                        {:params [option+]}]}}

  ([]

   (.state.genesis nil))


  ([option+]

   (let [peer+       (or (:peer+ option+)
                         [{:key (.kp.pubkey (.kp.create .account.0-key))}])
         state       (.shell.invoke '.state.genesis
                                    (map :key
                                         peer+))
         addr.offset (inc (long .account.genesis))
         n.peer      (count peer+)
         [ok?
          x]         (.state.tmp
                       (fn []
                         (.state.core.vanilla
                           (do
                             (.state.switch .account.genesis
                                            state)
                             (loop [i.peer 0]
                               (if (< i.peer
                                      n.peer)
                                 (let [peer (get peer+
                                                 i.peer)]
                                   (.account.switch (address (+ addr.offset
                                                                i.peer)))
                                   (let [pubkey (get peer
                                                     :key)]
                                     (set-peer-data pubkey
                                                    (assoc (get-in peer+
                                                                   [i.peer
                                                                    :metadata])
                                                           :url
                                                           (str (or (:host peer)
                                                                    "localhost")
                                                                ":"
                                                                (or (:port peer)
                                                                    .peer.default.port))))
                                     (when-let [stake (:stake peer)]
                                       (set-peer-stake pubkey
                                                       stake)))
                                   (recur (inc i.peer))))
                                 *state*)))))]
     (when-not ok?
       (.ex.rethrow x))
     x)))



(defn .state.safe

  ^{:doc {:description ["Executes the given function in a safe, atomic way."
                        "Returns a vector of 2 elements."
                        ""
                        "First item is a boolean indicating if the function ran without throwing"
                        "an exception."
                        ""
                        "If `true`, second item is the returned result."
                        "If `false`, second item is the thrown exception and `*state*` is reverted."
                        ""
                        "Usually, prefer the `.state.safe*` macro for convenience."]
          :examples    [{:code (.state.safe (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}
  [f]

  (.shell.invoke '.state.safe
                 f))



(defmacro .state.safe*

  ^{:doc {:description ["Executes the given code exactly like `.state.safe`."
                        "More convenient to use."]
          :examples    [{:code (.state.safe* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(.account.core/.state.safe (fn []
                                ~(cons 'do
                                       form+))))
 


(defn .state.switch

  ^{:doc {:description ["Switches `*state*` to the given one."
                        "For instance, a state produced with `.state.genesis` or a state"
                        "retrieved from Etch."
                        ""
                        "Provided address must point to an account in the target state."
                        "By default, current `*address*` is used."
                        ""
                        "Attention, beware of consequences."
                        "E.g. Switching in a middle of an actor call who was working under"
                        "     assumptions relating to the old `*state*`."]
          :examples    [{:code (.state.switch (.state.genesis))}
                        {:code (.state.switch #12 (.state.genesis))}]
          :signature   [{:params [state]}
                        {:params [address state]}]}}


  ([state]

   (.state.switch nil
                  state))


  ([address state]

   (.shell.invoke '.state.switch
                  (or address
                      *address*)
                  state)))



(defn .state.tmp

  ^{:doc {:description ["Exactly like `.state.safe` but the state is always reverted."
                        "Even if an exception is not thrown."
                        ""
                        "Also see the `.state.tmp*` macro for convenience."]
          :examples    [{:code (.state.tmp (fn [] (def x 42) (inc x)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.tmp
                 f))



(defmacro .state.tmp*

  ^{:doc {:description ["Convenience macro over `.state.tmp`."
                        "Wraps given code into a function."]
          :examples    [{:code (state.tmp* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(.account.core/.state.tmp (fn []
                               ~(cons 'do
                                      form+))))


;;;;;;;;;; Strings


(def .str

  ^{:private?      true
    :shell.section ["Extra string-related utilities not found natively in Convex."]}

  nil)



(defn .str.count

  ^:private?

  [s]

  (let [n-byte (count s)]
    (loop [i      0
           n-char 0]
      (if (< i
             n-byte)
        (recur (inc i)
               (if (nil? (nth s
                              i))
                 n-char
                 (inc n-char)))
        n-char))))

        

(defn .str.pluralize

  ^:private?

  [n s]

  (if (> n
         1)
    (str s
         "s")
    s))



(defn .str.sort

  ^:private?

  [str+]

  (.shell.invoke '.str.sort
                 str+))



(defn .str.stream.in

  ^{:doc {:description ["Wraps the given string in an input stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."]
          :examples    [{:code (.str.stream.in ":a :b :c")}]
          :signature   [{:params [string]}]}}

  [string]

  (.shell.invoke '.str.stream.in
                 string))



(defn .str.stream.out

  ^{:doc {:description ["Wraps the given string in an output stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."
                        ""
                        "Note that `.stream.close` has no effect."
                        ""
                        "See `.str.stream.unwrap` for unwrapping the string inside."]
          :examples    [{:code (.str.stream.out)}]
          :signature   [{:params [string]}]}}

  []

  (.shell.invoke '.str.stream.out))



(defn .str.stream.unwrap

  ^{:doc {:description ["Returns the string wrapped inside the given string output stream."
                        "See `.str.stream.out`."]
          :examples    [{:code (.str.stream.unwrap (.str.stream.out))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.str.stream.unwrap
                 handle))


;;;;;;;;;; Streams


(def .stream

  ^{:private?      true
    :shell.section ["Streams are an abstraction for reading and writing text"
                    "or Convex data."
                    ""
                    "For instance, see the following ways for creating streams"
                    "which can then be used with the various stream utilities:"
                    ""
                    "  .file.stream.in"
                    "  .file.stream.out"
                    "  .str.stream.in"
                    "  .str.stream.out"]}

  nil)



(defn .stream.stderr

  ^{:doc {:description ["Returns the handle for the STDERR stream."]
          :examples    [{:code (.stream.stderr)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stderr))



(defn .stream.stdin

  ^{:doc {:description ["Returns the handle for the STDIN stream."]
          :examples    [{:code (.stream.stdin)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stdin))



(defn .stream.stdout

  ^{:doc {:description ["Returns the handle for the STDOUT stream."]
          :examples    [{:code (.stream.stdout)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stdout))


;;;


(defn .stream.close

  ^{:doc {:description ["Closes the given stream."
                        "Returns `nil`."]
          :examples    [{:code (.stream.close (.str.stream.in ":test"))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.stream.close
                 handle))



(defn .stream.err

  ^{:doc {:description ["Like `.stream.out` but prints the given value to the STDERR (returned"
                        "by `.stream.stderr`)."]
          :examples    [{:code (.stream.err {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.out (.stream.stderr)
               x))



(defn .stream.errln

  ^{:doc {:description ["Like `.stream.outln` but prints the given value to STDERR (returned"
                        "by `.stream.stderr`)."]
          :examples    [{:code (.stream.errln {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.outln (.stream.stderr)
                 x))



(defn .stream.flush

  ^{:doc {:description ["Flushes the given output stream, ensuring all current content is printed."
                        "Defaults to STDOUT (returned by `.stream.stdout`)."
                        "Returns the stream handle."]
          :examples    [{:code (.stream.flush)}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.flush (.stream.stdout)))


  ([handle]

   (.shell.invoke '.stream.flush
                  handle)))



(defn .stream.in+

  ^{:doc {:description ["Reads as cells all content available from the given stream."
                        "Returns a list."
                        "Closes the stream automatically."
                        ""
                        "Reads from STDIN by default (returned by `.stream.stdin`)."]
          :examples    [{:code (.stream.in+ (.str.stream.in ":a :b :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.in+ (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.in+
                  handle)))



(defn .stream.line

  ^{:doc {:description ["Reads a single lines of cells from the given stream."
                        "Returns a list or `nil` if the stream is empty."
                        ""
                        "Once empty, the next read will throw an exception."
                        ""
                        "Reads from STDIN by default (returned by `.stream.stdin`)"]
          :examples    [{:code (.stream.line (.str.stream.in ":a :b \n :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.line (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.line
                  handle)))



(defn .stream.out

  ^{:doc {:description ["Writes the value as a cell to the given output stream."
                        "Prints in such a way that those cells can be read back."
                        ""
                        "Defaults to STDOUT (returned by `.stream.stdout`)."]
          :examples    [{:code (.stream.out :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.out (.stream.stdout)
                x))


  ([handle x]

   (.shell.invoke '.stream.out
                  handle
                  x)))



(defn .stream.outln

  ^{:doc {:description "Exactly like `.stream.out` but also prints a new line and flushes the stream."
          :examples    [{:code (.stream.outln :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.outln (.stream.stdout)
                  x))


  ([handle x]
   
   (.shell.invoke '.stream.outln
                  handle
                  x)))



(defn .stream.txt.err

  ^{:doc {:description ["Like `.stream.txt.out` but prints to STDERR (returned by `.stream.stderr`)."]
          :examples    [{:code (.stream.txt.err "Some error")}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.out (.stream.stderr)
                   x))



(defn .stream.txt.errln

  ^{:doc {:description ["Like `.stream.txt.outln but prints to STDERR (returned by `.stream.stderr`)."]
          :examples    [{:code (.stream.txt.errln "Some error")}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.outln (.stream.stderr)
                     x))



(defn .stream.txt.in

  ^{:doc {:description ["Reads the full content of the given input stream as a string."
                        "Defaults to STDIN (returned by `.stream.stdin`)."
                        "Stream is closed automatically."]
          :examples    [{:code (.stream.txt.in (.str.stream.in "test"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.in (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.txt.in
                  handle)))



(defn .stream.txt.line

  ^{:doc {:description ["Reads a single line from the given input stream as a string."
                        "Defaults to STDIN (returned by `.stream.stdin`)."
                        ""
                        "Like `.stream.in`, returns `nil` when the end of the stream is reached."
                        "Any subsequent read will then throw an exception."]
          :examples    [{:code (.stream.txt.line (.str.stream.in "foo\nbar"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.line (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.txt.line
                  handle)))



(defn .stream.txt.out

  ^{:doc {:description ["Like `.stream.out` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.out "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.out (.stream.stdout)
                    x))


  ([handle x]

   (.shell.invoke '.stream.txt.out
                  handle
                  x)))



(defn .stream.txt.outln

  ^{:doc {:description ["Like `.stream.outln` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.outln "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.outln (.stream.stdout)
                      x))


  ([handle x]

   (.shell.invoke '.stream.txt.outln
                  handle
                  x)))


;;;;;;;;;; System utilities


(def .sys

  ^{:private?      true
    :shell.section ["Basic system utilities."]}

  nil)



(defn .sys.arch

  ^{:doc {:description ["Returns the machine architecture as a string."]
          :examples    [{:code (.sys.arch)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.arch))



(defn .sys.cwd

  ^{:doc {:description ["Returns the current working directory."
                        "In other words, the directory the Shall was started in."
                        "Will not change throught the course of a process."]
          :examples    [{:code (.sys.cwd)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.sys.cwd))



(defn .sys.env

  ^{:doc {:description ["Returns a map of process environment variables."
                        "Also see `.sys.env.var`."]
          :examples    [{:code (.sys.env)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.env))



(defn .sys.env.var

  ^{:doc {:description ["Returns the value for a single process environment variable."
                        "Also see `.sys.env.var."]
          :examples    [{:code (.sys.env.var "SOME_VAR")}]
          :signature   [{:params [var]}]}}
  [var]

  (.shell.invoke '.sys.env.var
                 var))



(def .sys.eol

  ^{:doc {:description "Platform-dependent new line."}}

  .sys.eol)



(defn .sys.exit

  ^{:doc {:description ["Exists the Shell process with the given exit code."
                        "Exit code must be between 0 and 255 (inclusive)."]
          :examples    [{:code (.sys.exit 128)}]
          :signature   [{:params [code]}]}}

  [code]

  (.shell.invoke '.sys.exit
                 code))



(defn .sys.home

  ^{:doc {:description ["Returns the user's home directory."]
          :examples    [{:code (.sys.home)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.home))



(defn .sys.n-cpu

  ^{:doc {:description ["Returns the number of available processors on this machine."]
          :examples    [{:code (.sys.n-cpu)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.sys.n-cpu))



(defn .sys.os

  ^{:doc {:description ["Returns a vector where the first element is the operating"
                        "system and the second is the version."]
          :examples    [{:code (.sys.os)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.os))



(defn .sys.pid

  ^{:doc {:description ["Returns the PID of this process."]
          :examples    [{:code (.sys.pid)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.sys.pid))



(defn .sys.pid.command

  ^{:doc {:description ["Retrieves a running processe by PID and returns as a String the"
                        "command that launched it."
                        ""
                        "Returns Nil if no process is found for that given PID."]
          :examples    [{:code (.sys.pid.commaand 12345)}]
          :signature   [{:params [pid]}]}}
  [pid]

  (.shell.invoke '.sys.pid.command
                 pid))



(def .sys.version.convex

  ^{:doc {:description "Convex version used by this Shell."}}

  .sys.version.convex)



(def .sys.version.java

  ^:private?

  .sys.version.java)



(def .sys.version.shell

  ^{:doc {:description "Version of this Shell."}}

  .sys.version.shell)



(def .sys.vthread?

  ^{:doc {:description ["Set to `true` if this Shell supports virtual threads."
                        "See `.a.do`."]}}

  .sys.vthread?)


;;;;;;;;;; Unit testing


(def .t

  ^{:private?      true
    :shell.section ["Unit testing framework."
                    ""
                    "Tests are functions defined with `.t.def` which should contain"
                    "assertions written with `.t.is`."
                    ""
                    "Also see `.gen.check` for generative testing, a highly effective"
                    "testing technique."
                    ""
                    "See `.dep.test` about how to run them."]}

  nil)



(def .t.*assert+*

  ^:private?

  [])



(defn .t.assert.add

  ^:callable?
  ^:private?

  [assertion]

  (if (= *address*
         ~*address*)
    (def .t.*assert+*
         (conj .t.*assert+*
               assertion))
    (call ~*address*
          (.t.assert.add assertion))))



(defn .t.assert.failed+

  ^:private?

  [assertion+]

  (reduce (fn [acc assertion]
            (let [[ok?
                   x]         (:result assertion)
                  assertion-2 (if ok?
                                (if (syntax? x)
                                  (if-let [status (:test.status (meta x))]
                                    {:fail   (unsyntax x)
                                     :status status}
                                    {:fail   x
                                     :status :fail})
                                  (when-not (= x
                                               true)
                                    {:fail   x
                                     :status :fail}))
                                {:fail   x
                                 :status :exception})]
              (if assertion-2
                (conj acc
                      (assoc assertion-2
                             :form    (:form assertion)
                             :message (:message assertion)))
                acc)))
          []
          assertion+))



(defmacro .t.ex

  ^{:doc {:description ["Used as a form for `.t.is` for testing if an exception was thrown."
                        "Exception code is optional. Without it, the assertion will pass for"
                        "any exception."
                        ""
                        "A good test suite not only proves that things succeed but also that they"
                        "fail when they should."]
          :examples    [{:code (.t.is (.t.ex (assert false)))}
                        {:code (.t.is (.t.ex :ASSERT (assert false)))}]
          :signature   [{:params [form]}
                        {:params [ex-code form]}]}}

  ([form]

   `(.t.ex nil
           ~form))


  ([ex-code form]

   `(let [ex-code ~ex-code
          [ok?
           x]     (.state.safe* ~form)]
      (if ok?
        (syntax x
                {:test.status :fail})
        (if (nil? ex-code)
          true
          (or (= ex-code
                 (:code x))
              (syntax x
                      {:test.status :exception})))))))



(defmacro .t.def

  ^{:doc {:description ["Defines a function that can run as a test."
                        ""
                        "Just like when defining a regular function, metadata can be attached."
                        "This metadata may be useful for focusing on the test or skipping it when"
                        "running tests with `.dep.test`."]
          :examples    [{:code (.t.def some-test ^:slow? (.t.is (< 1 2)))}]
          :signature   [{:params [name & assertion+]}]}}

  [name & assertion+]

  (let [[name-2
         meta-]      (if (syntax? name)
                       [(unsyntax name)
                        (meta name)]
                       [name
                        nil])
        first-assert (when-not (empty? assertion+)
                       (first assertion+))
        meta-2       (if (syntax? first-assert)
                       (merge meta-
                              (meta first-assert))
                       meta-)]
    `(defn ~(syntax name-2
                    (assoc meta-2
                           :test?
                           true))

       []

       ~(cons 'do
               assertion+))))



(defn .t.dev

  ^:private?

  ([required]

   (.t.dev required
           nil))


  ([required state]

   (= (:status (.t.run required
                       state))
      :pass)))



(defn .t.find

  ^:private?

  [state actor-sym actor-address]

  (let [account    (account actor-address)
        meta       (:metadata account)
        env        (:environment account)
        focus.test (get-in state
                           [:focus.test
                             actor-sym])
        skip.test  (get-in state
                           [:skip.test
                            actor-sym])]
    (reduce (fn [acc [sym x]]
              (let [sym-meta (get meta
                                  sym)]
                (if (and (fn? x)
                         (get-in meta
                                 [sym
                                  :test?])
                         (or (not focus.test)
                             (contains-key? focus.test
                                            sym))
                         (or (not skip.test)
                             (not (contains-key? skip.test
                                                 sym)))
                         (reduce (fn [_focus? k-focus]
                                   (if (get sym-meta
                                            k-focus)
                                     (reduced true)
                                     false))
                                 true
                                 (get state
                                      :focus.meta))
                         (reduce (fn [_skip? k-skip]
                                   (if (get sym-meta
                                            k-skip)
                                     (reduced false)
                                     true))
                                 true
                                 (get state
                                      :skip.meta)))
                  (conj acc
                        [sym
                         x])
                  acc)))
            []
            env)))



(defmacro .t.gen

  [gen-binding+ & body]

  (let [n (count gen-binding+)]
    (when-not (zero? (mod n
                          2))
      (fail :ARGUMENT
            "Generators must be provided in bindings like `let`"))
    (let [binding+ (loop [acc []
                          i   0]
                     (if (< i
                            n)
                       (recur (conj acc
                                    (nth gen-binding+
                                         i))
                              (+ i
                                 2))
                       acc))
          gen+     (loop [acc []
                          i   1]
                     (if (< i
                            n)
                       (recur (conj acc
                                    (nth gen-binding+
                                         i))
                              (+ i
                                 2))
                       acc))]
      `(let [result (.gen.check ~gen+
                                ~(concat (list 'fn
                                               binding+)
                                         body)
                                {:n.trial  .t.gen.n.trial
                                 :seed     .t.gen.seed
                                 :size.max .t.gen.size.max})]
         (or (:pass? result)
             (syntax (assoc result
                            :binding+
                            (quote ~binding+))
                     {:test.status :gen}))))))



(defmacro .t.is

  ^{:doc {:description ["Creates a test assertion."
                        "Meant to be used in tests defined with `.t.def`."
                        ""
                        "In order for a test assertion to pass, `form` must return `true`."
                        "An optional message can be provided, making it easier to locate the"
                        "assertion in the test report in case of failure."]
          :examples    [{:code (.t.is (= a b) "A and B must be equal")}]
          :signature   [{:params [form]}
                        {:params [form message]}]}}


  ([form]

   `(.t.is ~form
           nil))


  ([form message]

   `(.t.assert.add {:form    (quote ~form)
                    :message ~message
                    :result  (.state.safe* ~form)})))



(defn .t.main

  ^:private?


  ([required]

   (.t.main required
            nil))


  ([required state]

   (.sys.exit (if (.t.dev required
                          state)
                0
                128))))



(defn .t.on.run.begin

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (str .sys.eol
                          "=========="
                          .sys.eol
                          .sys.eol
                          (.term.bold)
                          "["
                          (.term.reset)))
    (.stream.flush s))
  state)



(defn .t.on.run.end

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            "]"
                            (.term.reset)
                            .sys.eol
                            .sys.eol
                            "=========="
                            .sys.eol))
    (.docoll (fn [test]
               (if-let [f (get {:empty     .t.on.test.empty
                                :exception .t.on.test.ex
                                :fail      .t.on.test.fail}
                               (:status test))]
                 (f state
                    test)
                 nil))
             (:run state))
    (let [status (:status state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (cond
                                (= status
                                   :empty)
                                (str (.term.fg.red)
                                     "NO TESTS FOUND")
                                ;;
                                (= status
                                   :fail)
                                (str (.term.fg.red)
                                     "FAIL")
                                ;;
                                (= status
                                   :pass)
                                (str (.term.fg.green)
                                     "OK"))
                              (.term.bold)
                              .sys.eol)))
    (let [empty-actor+ (:empty-actor+ state)
          n-actor      (:n-actor state)
          n-test       (:n-test state)
          n-test-fail  (:n-test-fail state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              n-test
                              " test"
                              (if (> n-test
                                     1)
                                "s"
                                "")
                              (.term.reset)
                              " run over "
                              (.term.bold)
                              (.term.fg.cyan)
                              n-actor
                              " actor"
                              (if (> n-actor
                                     1)
                                "s"
                               "")
                              (.term.reset)
                              ", "
                              (.term.bold)
                              (if (zero? n-test-fail)
                                (.term.fg.green)
                                (.term.fg.red))
                              n-test-fail
                              " failed"
                              (.term.reset)))
      (when-not (empty? empty-actor+)
        (.stream.txt.outln s
                           (str .sys.eol
                                .sys.eol
                                (.term.bold)
                                (.term.fg.red)
                                "Actors without tests:"
                                (.term.reset)
                                .sys.eol))
        (.docoll (fn [sym-actor]
                   (.stream.txt.outln s
                                      (str "  "
                                           sym-actor)))
                 empty-actor+))))
  state)



(defn .t.on.test.empty

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (.stream.txt.outln (:stream.out state)
                     "No assertions.")
  (.t.print.test.separator state))




(defn .t.on.test.gen

  ^:private?

  [state failed]

  (let [fail   (:fail failed)
        result (:smallest.result fail)
        s      (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            (.term.fg.cyan)
                            "Seed:"
                            (.term.reset)
                            .sys.eol
                            "  "
                            (:seed fail)))
    (.stream.txt.outln s
                       (str (.term.bold)
                            (.term.fg.cyan)
                            "Input:"
                            (.term.reset)))
    (map (fn [sym x]
           (.stream.txt.outln (str "  "
                                   sym
                                   (.term.bold)
                                   " = "
                                   (.term.reset)
                                   x)))
         (:binding+ fail)
         (:smallest fail))
    (cond
      ;;
      (:smallest.ex? fail)
      (.ex.print s
                 result)
      ;;
      (and (syntax? result)
           (= (:test.status (meta result))
              :exception))
      (.ex.print s
                 (unsyntax result))
      ;;
      (and (syntax? result)
           (= (:test.status (meta result))
              :fail))
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              "Result:"
                              (.term.reset)
                              .sys.eol
                              "  "
                              (unsyntax result)))
      ;;
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              "Result:"
                              (.term.reset)
                              .sys.eol
                              "  "
                              result)))))





(defn .t.on.test.ex

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "Exception thrown unexpectedly")
    (.ex.print s
               (:exception test)))
  (.t.print.test.separator state))



(defn .t.on.test.fail

  ^:private?

  [state test]

  (let [s (:stream.out state)]
    (.docoll (fn [failed]
               (.t.print.test.name state
                                   test)
               (when-let [message (:message failed)]
                 (.stream.txt.outln s
                                    (str message
                                         .sys.eol)))
               (.stream.txt.outln s
                                  (str (.term.bold)
                                       (.term.fg.cyan)
                                       "Assertion:"
                                       (.term.reset)
                                       .sys.eol
                                       "  "
                                       (.trunc.str (:form failed))))
               (let [status (:status failed)]
                 (when-not (= status
                              :pass)
                   (cond
                     ;;
                     (= status
                        :fail)
                     (.stream.txt.outln s
                                        (str (.term.bold)
                                             (.term.fg.cyan)
                                             "Result:"
                                             (.term.reset)
                                             .sys.eol
                                             "  "
                                             (:fail failed)))
                     ;;
                     (= status
                        :gen)
                     (.t.on.test.gen state
                                     failed)
                     ;;
                     (= status
                        :exception)
                     (.ex.print s
                                (:fail failed)))
                   (.t.print.test.separator state))))
             (:failed+ test))))



(defn .t.on.test.result

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state result]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (if (= (:status result)
                            :pass)
                       (str (.term.bold)
                            (.term.fg.green)
                            "."
                            (.term.reset))
                       (str (.term.bold)
                            (.term.fg.red)
                            "X"
                            (.term.reset))))
    (.stream.flush s))
  state)



(defn .t.print.test.name

  ^:private?

  [state test]

  (.stream.txt.outln (:stream.out state)
                     (str (.term.bold)
                          (:name test)
                          (.term.reset)
                          .sys.eol))
  nil)



(defn .t.print.test.separator

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "")
    (.stream.txt.outln s
                       "-----")
    (.stream.txt.outln s
                       ""))
  nil)



(defn .t.run

  ^:private?

  [actor-sym->addr state]

  (let [[ok?
         x]
        (.state.tmp
          (fn []
            (let [addr *address*]
              (.account.switch .account.core)
              (def .t.gen.n.trial
                   (or (:gen.n.trial state)
                       .gen.check.n.trial))
              (def .t.gen.seed
                   (or (:gen.seed state)
                       (.time.unix)))
              (def .t.gen.size.max
                   (or (:gen.size.max state)
                       .gen.check.size.max))
              (.account.switch addr))
            (let [state          (merge {:on.run.begin   .t.on.run.begin
                                         :on.run.end     .t.on.run.end
                                         :on.test.result .t.on.test.result
                                         :stream.out     (.stream.stdout)}
                                        state)
                  on.run.begin   (:on.run.begin state)
                  on.run.end     (:on.run.end state)
                  state          (if on.run.begin
                                   (on.run.begin state)
                                   state)
                  state-2        (reduce (fn [state-2 actor-sym]
                                           (.t.run.actor state-2
                                                         actor-sym
                                                         (get actor-sym->addr
                                                              actor-sym)))
                                         (assoc state
                                                :empty-actor+ []
                                                :n-actor      0
                                                :n-test       0
                                                :n-test-fail  0)
                                         (:order state))
                 state-3         (.t.run.finalize state-2)]
             (if on.run.end
               (on.run.end state-3)
               state-3))))]
    (if ok?
      x
      (.ex.rethrow x))))



(defn .t.run.actor

  ^:private?

  [state actor-sym actor-address]

  (let [found (.t.find state
                       actor-sym
                       actor-address)]
    (if (empty? found)
      (assoc state
             :empty-actor+
             (conj (:empty-actor+ state)
                   actor-sym))
      (reduce (fn [state-2 [test-sym test-f]]
                (.t.run.test state-2
                             actor-sym
                             actor-address
                             test-sym
                             test-f))
              (assoc state
                     :n-actor
                     (inc (:n-actor state)))
              found))))



(defn .t.run.finalize

  ^:private?

  [state]

  (assoc state
         :status
         (cond
           ;;
           (zero? (:n-test state))
           :empty
           ;;
           (zero? (:n-test-fail state))
           :pass
           ;;
           :else
           :fail)))



(defn .t.run.test

  ^:private?

  [state actor-sym actor-address test-sym test-f]

  (let [on.test.result (:on.test.result state)
        [ok?
         x]            (.state.tmp (fn []
                                     (.account.switch actor-address)
                                     (test-f)
                                     .t.*assert+*))
        test-result    (if ok?
                         (.t.run.test.finalize x)
                         (let [trace (:trace x)]
                           {:exception (assoc x
                                              :trace
                                              ;; Removing lines relating to calling the test.
                                              (slice trace
                                                     0
                                                     (max 0
                                                          (- (count trace)
                                                             2))))
                            :status    :exception}))
        test-result-2  (assoc test-result
                              :name
                              (str actor-sym
                                   "/"
                                   test-sym))
        state-2        (assoc state
                              :run
                              (conj (:run state)
                                    test-result-2))
        state-3        (assoc state-2
                              :n-test
                              (inc (:n-test state-2)))
        state-4        (if on.test.result
                         (on.test.result state-3
                                         test-result-2)
                         state-3)]
    (if (= (:status test-result-2)
           :pass)
      state-4
      (assoc state-4
             :n-test-fail
             (inc (:n-test-fail state-4))))))



(defn .t.run.test.finalize

  ^:private?

  [assertion+]

  (let [n (count assertion+)]
    (if (zero? n)
      {:status :empty}
      (let [failed+ (.t.assert.failed+ assertion+)
            result  {:n n}]
        (if (empty? failed+)
          (assoc result
                 :status
                 :pass)
          (assoc result
                 :failed+ failed+
                 :status  :fail))))))


;;;;;;;;;; Basic ANSI terminal commands


(def .term

  ^{:private?      true
    :shell.section ["Simples utilities for producing terminal ANSI escape codes, such as"
                    "for coloring strings."
                    ""
                    "Some environments, such as some Windows terminals, or some use cases,"
                    "such as writing files, requires disabling these."
                    "See `.term.style.enable?` which will work for all color-related functions."]}

  nil)



(def .term.*style?*

  ^{:doc {:description ["Boolean indicating if text styling functions like `.term.fg.red` can use ANSI escape codes."
                        "If set to `false`, those functions will return empty strings."
                        "See `.term.style.enable?`."]}}

  true)



(defn .term.style

  ^:private?

  [x]

  (if .term.*style?*
    x
    ""))



(defn .term.style.enable?

  ^{:callable? true
    :doc       {:description ["Sets the value of `.term.*style?*`."
                              "Disabling colors is useful when working in a terminal that does not support ANSI"
                              "escape codes or when printing to files."
                              "See `.term.style.enable?`."]
                :examples    [{:code (.term.style.enable? false)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         ~*address*)
    (def .term.*style?*
         (boolean enable?))
    (call ~*address*
          (.term.style.enable? enable?))))


;; ANSI background colors


(defn .term.bg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (background)."]
          :examples    [{:code (.term.bg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[40m"))



(defn .term.bg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (background)."]
          :examples    [{:code (.term.bg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[44m"))



(defn .term.bg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (background)."]
          :examples    [{:code (.term.bg.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[46m"))



(defn .term.bg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (background)."]
          :examples    [{:code (.term.bg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[42m"))



(defn .term.bg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (background)."]
          :examples    [{:code (.term.bg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[45m"))


(defn .term.bg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (background)."]
          :examples    [{:code (.term.bg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[41m"))



(defn .term.bg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (background)."]
          :examples    [{:code (.term.bg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[47m"))



(defn .term.bg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in (background)."]
          :examples    [{:code (.term.bg.)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[43m"))


;;


(defn .term.bg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (background)."]
          :examples    [{:code (.term.bg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}

  [r g b]

  (if .term.*style?*
    (str "\033[48;2;" r ";" g ";" b "m")
    ""))


;; ANSI foreground colors


(defn .term.fg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (foreground)."]
          :examples    [{:code (.term.fg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[30m"))



(defn .term.fg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (foreground)."]
          :examples    [{:code (.term.fg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[34m"))



(defn .term.fg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (foreground)."]
          :examples    [{:code (.term.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[36m"))



(defn .term.fg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (foreground)."]
          :examples    [{:code (.term.fg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[32m"))



(defn .term.fg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (foreground)."]
          :examples    [{:code (.term.fg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[35m"))



(defn .term.fg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (foreground)."]
          :examples    [{:code (.term.fg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[37m"))



(defn .term.fg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (foreground)."]
          :examples    [{:code (.term.fg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[31m"))



(defn .term.fg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in yellow (foreground)."]
          :examples    [{:code (.term.fg.yellow)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[33m"))


;;


(defn .term.fg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (foreground)."]
          :examples    [{:code (.term.fg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}


  [r g b]

  (if .term.*style?*
    (str "\033[38;2;" r ";" g ";" b "m")
    ""))


;; Terminal effects


(defn .term.bold

  ^{:doc {:description ["Returns the ANSI escape code for bold text."]
          :examples    [{:code (.term.bold)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[1m"))



(defn .term.reset

  ^{:doc {:description ["Returns the ANSI escape code for resetting all colors and effects."]
          :examples    [{:code (.term.reset)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[0m"))



(defn .term.reversed

  ^{:doc {:description ["Returns the ANSI escape code for reversing background and"
                        "foreground colors."]
          :examples    [{:code (.term.reversed)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[7m"))



(defn .term.underline

  ^{:doc {:description ["Returns the ANSI escape code for underlining text."]
          :examples    [{:code (.term.underline)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[4m"))


;;;;;;;;;; Moving


(defn .term.col

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to column `n`."]
          :examples    [{:code (.term.col 42)}]
          :signature   [{:params [n]}]}}

  [n]

  (str "\033[" n "G"))



(def .term.cursor.save

  ^{:doc {:description ["ANSI code for saving current cursor position."
                        "See `cursor.restore`."]}}

  "\033[s")



(def .term.cursor.restore

  ^{:doc {:description ["ANSI escape code for restoring last saved cursor position."
                        "See `cursor.save`."]}}

  "\033[u")



(defn .term.down

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code (.term.down 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down 1))


  ([n]

   (str "\033[" n "B")))



(defn .term.down.begin

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to the beginning"
                        "of the line and then `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code ($.term.down.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down.begin 1))


  ([n]

   (str "\033[" n "E")))



(defn .term.left

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns left."
                        "Defaults to one column."]
          :examples    [{:code (.term.left 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.left 1))


  ([n]

   (str "\033[" n "D")))



(defn .term.right

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns right."
                        "Defaults to one column."]
          :examples    [{:code (.term.right 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.right 1))


  ([n]

   (str "\033[" n "C")))



(defn .term.up

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up 1))


  ([n]

   (str "\033[" n "A")))



(defn .term.up.begin

  ^{:doc {:description ["Returns the ANSI escapecode for moving the cursor to the beginning of the line"
                        "and then `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up.begin 1))


  ([n]

   (str "\033[" n "F")))


;; Screen clearing


(defn .term.clear

  ^{:doc {:description "Returns the ANSI code for clearing the whole screen."
          :examples    [{:code (.term.clear)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[H\033[2J"))


;;


(defn .term.demo

  ^{:doc {:description ["Prints a string to STDOUT producing colored output as demo"
                        "of the different `.term...` functions."]
          :examples    [{:code ($.term/demo)}]
          :signature   [{:params []}]}}
  []

  (.stream.txt.outln
    (str .sys.eol
         (.term.bg.black)
         "BG black"
         (.term.reset)
         .sys.eol
         (.term.bg.blue)
         "BG blue"
         (.term.reset)
         .sys.eol
         (.term.bg.cyan)
         "BG cyan"
         (.term.reset)
         .sys.eol
         (.term.bg.green)
         "BG green"
         (.term.reset)
         .sys.eol
         (.term.bg.magenta)
         "BG magenta"
         (.term.reset)
         .sys.eol
         (.term.bg.red)
         "BG red"
         (.term.reset)
         .sys.eol
         (.term.bg.white)
         (.term.fg.black)
         "BG white"
         (.term.reset)
         .sys.eol
         (.term.bg.yellow)
         "BG yellow"
         (.term.reset)
         .sys.eol
         (.term.bg.rgb 100 200 150)
         "BG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.fg.black)
         "FG black"
         (.term.reset)
         .sys.eol
         (.term.fg.blue)
         "FG blue"
         (.term.reset)
         .sys.eol
         (.term.fg.cyan)
         "FG cyan"
         (.term.reset)
         .sys.eol
         (.term.fg.green)
         "FG green"
         (.term.reset)
         .sys.eol
         (.term.fg.magenta)
         "FG magenta"
         (.term.reset)
         .sys.eol
         (.term.fg.red)
         "FG red"
         (.term.reset)
         .sys.eol
         (.term.fg.white)
         (.term.fg.black)
         "FG white"
         (.term.reset)
         .sys.eol
         (.term.fg.yellow)
         "FG yellow"
         (.term.reset)
         .sys.eol
         (.term.fg.rgb 100 200 150)
         "FG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.bold)
         "Bold text"
         .sys.eol
         (.term.fg.blue)
         "Bold makes also colors brighter"
         (.term.reset)))
  nil)


;;;;;;;;;;


(defn .testnet.create-account

  ^{:doc {:description ["Creates a new account on `convex.world` for the given public key."
                        "Returns the address of that new account."]
          :examples    [{:code (.testnet.create-account (.kp.pubkey (.kp.create)))}]
          :signature   [{:params [public-key]}]}}

  [public-key]

  (.shell.invoke '.testnet.create-account
                 public-key))



(defn .testnet.faucet

  ^{:doc {:description ["Requests Convex Coppers for an account on `convex.world`."
                        "Amount must be >= 0 and <= 100,000,000."]
          :examples    [{:code (.testnet.faucet #42 1000000)}]
          :signature   [{:params [address amount]}]}}

  [address amount]

  (.shell.invoke '.testnet.faucet
                 address
                 amount))


;;;;;;;;;; Time utilities


(def .time

  ^{:private?      true
    :shell.section ["Times related utilities."
                    ""
                    "Note that the Convex Virtual Machine keeps its own time available"
                    "under `*timestamp*` which represents the network time. In the Shell,"
                    "this timestamp can only move forwards via `.time.advance`."
                    ""
                    "Other utilities, such as `.time.unix`, refer to the actual clock"
                    "time of the machine the Shell is running on."]}

  nil)



(defn .time.advance

  ^{:doc {:description ["Advances `*timestamp*`, the timestamp of the Convex Virtual Machine."
                        "Unless calling this function, this timestamp never changes."
                        "Canot go back in time."
                        ""
                        "Useful for triggering transactions that have been scheduled at a"
                        "future time with `schedule`."]
          :examples    [{:code (.time.advance 1000)}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.advance
                 millis))



(defmacro .time.do*

  ^{:doc {:description ["Macro for timing code execution."
                        ""
                        "Returns a vector where:"
                        "  0: Elapsed time in nanoseconds"
                        "  1: Result from executing forms"
                        ""
                        "Uses `.time.nano`."
                        "Might not be accurate enough for tiny operations."]
          :examples    [{:code (.time.do* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}
  [& form+]

  (let [n-form     (count form+)
        sym-result (.gensym)
        sym-time   (.gensym)]
    `(let [~sym-time   (.time.nano)
           ~sym-result ~(cond
                          ;;
                          (= n-form
                             0)
                          nil
                          ;;
                          (= n-form
                             1)
                          (first form+)
                          ;;
                          (cons 'do
                                form+))]
       [(- (.time.nano)
            ~sym-time)
        ~sym-result])))



(defn .time.iso

  ^{:doc {:description ["Returns the current time as an ISO 8601 UTC String."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.iso)}]
          :signature   [{:params []}]}}
  []

  (.time.unix->iso (.time.unix)))



(defn .time.iso->unix

  ^{:doc {:description ["Converts time as an ISO 8601 UTC String into a Unix timestamp."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.iso->unix "2022-09-14T11:43:34.633")}]
          :signature   [{:params [iso-string]}]}}

  [iso-string]

  (.shell.invoke '.time.iso->unix
                 iso-string))



(defn .time.nano

  ^{:doc {:description ["Returns the current value of a high-resolution timer in nanoseconds."
                        ""
                        "Guarantees:"
                        ""
                        "  - Timer is monotonic if the OS supports it"
                        "  - Resolution is at least as good as that of `.time.unix`"
                        ""
                        "Useful for timing things as usually more accurate than `.time.unix`."
                        ""
                        "This timer has no particular, predictable origin. Hence the first value is meaningless."
                        "However, the difference between 2 values from the same process offers a precise interval."
                        "It follows that values from different processes are not comparable."
                        ""
                        "See `.time.do*` for a convenience macro."]
          :examples    [{:code (.time.nano)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.nano))



(defn .time.sleep

  ^{:doc {:description ["Blocks execution for the given interval in milliseconds plus the"
                        "optional number of nanoseconds (defaults to `0`)."
                        ""
                        "Subject to the precision and accuracy of system timers and scheduler."]
          :examples    [{:code (.time.sleep 1000)}
                        {:code (.time.sleep 1000 500000)}]
          :signature   [{:params [millis]}
                        {:params [millis nanos]}]}}


  ([millis]

   (.time.sleep millis
                nil))


  ([millis nanos]

   (.shell.invoke '.time.sleep
                  millis
                  (or nanos
                      0))))



(defn .time.unix

  ^{:doc {:description ["Returns the current Unix time as a Long."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.unix)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.unix))



(defn .time.unix->iso

  ^{:doc {:description ["Converts a Unix timestamp to an ISO 8601 UTC string."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.unix->iso 1663155814633)}]
          :signature   [{:params [unix-timestamp]}]}}

  [unix-timestamp]

  (.shell.invoke '.time.unix->iso
                 unix-timestamp))


;;;;;;;;;; Transactions


(defn .trx

  ^{:doc           {:description ["Applies a transaction."
                                  ""
                                  "This is effectively what a peer does when executing a transaction from"
                                  "a consensus block, after validating its signature."
                                  ""
                                  "Will fail with an exception if:"
                                  ""
                                  "  - Transaction origin is an actor (they cannot transact, only users can)"
                                  "  - Sequence ID is not the current sequence ID for that address + 1"
                                  ""
                                  "Sequence ID is an on-chain number attached to an account. It is incremented on"
                                  "every transaction. A valid transaction must embedded the current sequence ID + 1"
                                  "to avoid replay attacks."
                                  ""
                                  "If not provided when creating a new transaction, will be deduced from the current"
                                  "state. Obviously, this only really works if the transaction is meant to be executed"
                                  "against the current state as opposed to a network."
                                  ""
                                  "E.g.`(:sequence (account *address*))`."]
                    :examples    [{:code (.trx (.trx.new.invoke .account.genesis '(def cool? true)))}]
                    :signature   [{:params [trx]}]}
    :shell.section ["Creating and executing transactions like a peer would."
                    ""
                    "Transactions a special kind of Convex data not directly available to the user"
                    "on-chain. In the Shell, they look and behave like maps but technically are not."]}

  [trx]

  (.shell.invoke '.trx
                 trx))



(defn .trx.new.call

  ^{:doc  {:description ["Creates a transaction for calling an actor that can be executed with `.trx`."
                         ""
                         "Requires:"
                         ""
                         "  - Address of the account issuing the transaction (origin)"
                         "  - Address of the actor being called (target)"
                         "  - Symbol of the function being called"
                         "  - A vector of arguments or `nil`"
                         ""
                         "A map of options may be provided:"
                         ""
                         "  :offer"
                         "    Amount of Convex Coins for paying the actor (defaults to 0)"
                         ""
                         "  :sequence"
                         "    See `.trx` about the sequence ID"]
           :examples    [{:code (.trx.new.call #11 #42 'some-fn [1 2 3])}
                         {:code (.trx.new.call #11 #42 'some-fn [1 2 3] {:offer 10000, :sequence 100})}]
           :signature   [{:params [origin target function-name arg+]}
                         {:params [origin target function-name arg+ option+]}]}}


  ([origin target function-name arg+]

   (.trx.new.call origin
                  target
                  function-name
                  arg+
                  nil))


  ([origin target function-name arg+ option+]

   (.shell.invoke '.trx.new.call
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  target
                  (or (:offer option+)
                      0)
                  function-name
                  arg+)))



(defn .trx.new.invoke

  ^{:doc  {:description ["Creates a transaction for arbitrary code that can be executed with `.trx`."
                         ""
                         "Requires:"
                         ""
                         "  - Address issuing the transaction (origin)"
                         "  - A cell to execute (command)"
                         ""
                         ;; `.cell.compile` has been removed for now.
                         ; "Advanced users may want to precompile the command using `.cell.compile`."
                         ; ""
                         "A map of options may be provided:"
                         ""
                         "  :sequence"
                         "    See `.trx` about the sequence ID"]
           :examples    [{:code (.trx.new.invoke #11 '(def cool? true))}
                         {:code (.trx.new.invoke #11 (compile '(def cool? true)) {:sequence 3})}]
           :signature   [{:params [origin command]}
                         {:params [origin command option+]}]}}


  ([origin command]

    (.trx.new.invoke origin
                     command
                     nil))


  ([origin command option+]

   (.shell.invoke '.trx.new.invoke
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  command)))



(defn .trx.new.transfer

  ^{:doc {:description ["Creates a transaction for a transfer of Convex Coins that can be executed"
                        "with `.trx`."
                        ""
                        "Requires:"
                        ""
                        "  - Address of the sender (origin)"
                        "  - Address of the receiver (target)"
                        "  - Amount of Convex Coins to transfer"
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :sequence"
                        "    See `.trx` about the sequence ID"]
          :examples    [{:code (.trx.new.transfer #11 #42 100000)}
                        {:code (.trx.new.transfer #11 #42 100000 {:sequence 3})}]
          :signature   [{:params [origin target amount]}
                        {:params [origin target amount option+]}]}}


  ([origin target amount]

   (.trx.new.transfer origin
                      target
                      amount
                      nil))


  ([origin target amount option+]

   (.shell.invoke '.trx.new.transfer
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  target
                  amount)))



(defn .trx.noop

  ^{:doc {:description ["Like `.trx` but eventually does not execute the given transaction."
                        ""
                        "Meant for particular situations such as benchmarking, to emulate the overhead"
                        "associated with `.trx` without the cost of execution."
                        ""
                        "For advanced users only."]
          :examples    [{:code (.trx.noop (.trx.new.invoke .account.genesis '(def cool? true)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (.shell.invoke '.trx.noop
                 trx))



(defn .trx.with.sequence

  ^{:doc {:description ["Returns a new transaction which `trx` with the updated `sequence-id`."
                        "See `.trx` about sequence IDs."]
          :examples    [{:code (.trx.with.sequence (.trx.new.invoke #11 '(def cool? true)) 3)}]
          :signature   [{:params [trx sequence-id]}]}}

  [trx sequence-id]

  (.shell.invoke '.trx.with.sequence
                 trx
                 sequence-id))


;;;;;;;;;; Try-catch like helpers


(def .try

  ^{:private?      true
    :shell.section ["By design, the Convex Virtual Machine does not offer any \"try-catch\""
                    "mechanism as commonly found in mainstream languages. A transaction either"
                    "succeeds or fails when an exception is thrown."
                    ""
                    "However, catching exceptions is a common need for development. This section"
                    "contains some helper macros that build over `.state.safe`."]}

  nil)



(defmacro .try*

  ^{:doc {:description ["If `do-good` fails with an exception, state is reverted and `do-fail` is run."]
          :examples    [{:code (.try* (+ 2 2) :fail)}
                        {:code (.try* (assert false) :fail)}]
          :signature   [{:params [do-good do-fail]}]}}

  [do-good do-fail]

  `(let [[ok?
          x]  (.state.safe (fn [] ~do-good))]
     (if ok?
       x
       ~do-fail)))
          


(defmacro .try.resrc*

  ^{:doc {:description ["Safe way of running code with resources such as streams."
                        "Bindings are in a vector, akin to `let`, where each symbol is followed"
                        "by 2 forms."
                        ""
                        "Result of the first form is bound to the symbol, just like in `let`."
                        "Second form is executed when leaving this macro, usually to close the resource."
                        ""
                        "This ensure that resources closed even in case of an exception."]
          :examples    [{:code (.try.resrc* [s (.file.stream.in "foo.cvx") (.stream.close s)] (assert false)) }]
          :signature   [{:params [binding+ & body]}]}}

  [binding+ & body]

  (when-not (and (vector? binding+)
                 (zero? (mod (count binding+)
                             3)))
    (fail :ARGUMENT
          "Bindings must be in a vector consisting of triples"))
  (loop [code (cons 'do
                    body)
         i    (- (count binding+)
                 3)]
    (if (< i
           0)
      code
      (recur
        (let [sym   (get binding+
                         i)
              open  (get binding+
                         (inc i))
              close (get binding+
                         (+ i
                            2))]
          `(let [~sym ~open
                 [ok?
                  x]  (.state.safe* ~code)]
             ~(if (symbol? close)
                (list close
                      sym)
                close)
             (if ok?
               x
               (.ex.rethrow x))))
        (- i
           3)))))


;;;;;;;;;; Workers


(def .worker

  ^{:private?      true
    :shell.section ["Connect to a Convex Shell through STDIO"
                    ""
                    "A worker is a Convex Shell listening for code to execute on STDIN"
                    "and outputting the result to STDOUT (by default)."
                    ""
                    "Alternatively, on Unix systems, named pipes can be used."
                    ""
                    "For instance, a common use case is running a peer and turning the Shell"
                    "into a worker, allowing one to connect to it when needed to inspect data"
                    "or run further operations."
                    ""
                    "For a quick pratical example:"
                    ""
                    "  - In one Shell,   run `(.worker.start {:pipe \"foo\"})`"
                    "  - In another one, run `(.worker.repl {:pipe \"foo\"})`"
                    "  - You have now a REPL for executing code in the first Shell"
                    ""
                    "The underlying protocol is quite simple, see `.worker.exec` and `.worker.result`."]}

  nil)



(defn .worker.exec

  ^{:doc {:description ["Sends a request to a worker for executing code."
                        ""
                        "The worker is modelled as a process, a Map where:"
                        ""
                        "  :in"
                        "    Input stream for that worker, effectively an output stream from our end."
                        ""
                        "  :out"
                        "    Output stream for that worker, effectively an input stream from our end."
                        ""
                        "Note: `.process.run` returns such a Map."
                        ""

                        "The request written to `:in` is a Vector where:"
                        ""
                        "  0: Key, any Cell identifying the request, defaults to `nil`"
                        "  1: Form to execute, the actual code"
                        ""
                        "See `.worker.result` for reading the result."]
          :signature   [{:params [process form]}
                        {:params [key process form]}]}}

  
  ([process form]

   (.worker.exec nil
                 process
                 form))


  ([key process form]

   (let [in  (:in process)
         out (:out process)]
     (.stream.out in
                  key)
     (.stream.txt.out in
                      " ")
     (.stream.outln in
                    form)
     (.stream.txt.out in
                      .sys.eol)
     (.stream.flush in)
     (or (.stream.line out)
         [false
          key
          nil]))))



(defn .worker.pipe+

  ^{:doc {:description ["Used by tooling connecting to workers through Unix pipes instead of"
                        "STDIO."
                        ""
                        "Given a `name` (any String), this function creates 2 pipes in `/tmp`"
                        "if required and returns a Vector where:"
                        ""
                        "  0: Path to the input pipe of the worker"
                        "  1: Path to the output pipe of the worker"]
          :signature   [{:params [name]}]}}

  [name]

  (let [pipe-prefix (str "/tmp/cvx__" name "__")
        pipe-in     (str pipe-prefix "in")
        pipe-out    (str pipe-prefix "out")
        lock        (.file.lock (str pipe-prefix "lock"))
        [ok?
         x]         (.state.tmp
                      (fn []
                        (when-not (.fs.exists? pipe-in)
                          (when-not (.process.success? (.process.run ["mkfifo"
                                                                      pipe-in]))
                            (fail :SHELL.WORKER
                                  "Unable to create input pipe")))
                        (when-not (.fs.exists? pipe-out)
                          (when-not (.process.success? (.process.run ["mkfifo"
                                                                      pipe-out]))
                            (fail :SHELL.WORKER
                                   "Unable to create output pipe")))))]
    (.file.lock.release lock)
    (if ok?
      [pipe-in
       pipe-out]
      (.ex.rethrow x))))
  


(defn .worker.repl

  ^{:doc {:description ["Starts a REPL over a worker started in another Convex Shell."
                        ""
                        "The `process` argument is either:"
                        ""
                        "  - A Map as described in `.worker.exec`"
                        "  - A Map containing only `:pipe` (see `.worker.start`)."
                        ""
                        "Expert users may provide a Map of options for the REPL but"
                        "`:eval` will be overwritten (see `.repl`)."]
          :examples    [{:code (.worker.repl {:pipe "foo"})}]
          :signature   [{:params [process]}
                        {:params [process option+]}]}}


  ([process]

   (.worker.repl process
                 nil))


  ([process option+]

   (let [pipe        (:pipe process)
         [option-2+
          process-2] (if pipe
                       (let [[pipe-in
                              pipe-out] (.worker.pipe+ pipe)]
                         [(if (:name option+)    
                            option+
                            (assoc option+
                                   :name
                                   pipe))
                          {:in  (.file.stream.out pipe-in)
                           :out (.file.stream.in pipe-out)}])
                       [option+
                        process])
         ret         (.repl (merge option-2+
                                   {:eval (fn [env]
                                            (let [[ok?
                                                   x]  (.state.safe
                                                         (fn []
                                                           (.worker.exec process-2
                                                                         (cons 'do
                                                                               (:form+ env)))))]
                                              (if ok?
                                                (let [[ok-2?
                                                       _key
                                                       x-2] x]
                                                  (cond
                                                    ;;
                                                    ok-2?
                                                    (assoc env
                                                           :result
                                                           x-2)
                                                    ;;
                                                    (nil? x-2)
                                                    (dissoc env
                                                            :result)
                                                    ;;
                                                    (map? x-2)
                                                    (assoc env
                                                           :exception? true
                                                           :result     x-2)
                                                    ;;
                                                    (assoc env
                                                           :result
                                                           x-2)))
                                                (let [out (:stream.out env)]
                                                  (.stream.txt.out out
                                                                   .sys.eol)
                                                  (.stream.txt.out out
                                                                   (str (.term.bold)
                                                                        (.term.fg.red)
                                                                        "Stream error while executing command, worker might be dead"
                                                                        .sys.eol
                                                                        "Stopping worker REPL..."
                                                                        (.term.reset)))
                                                  (.stream.txt.out out
                                                                   .sys.eol)
                                                  (.ex.print out
                                                             x)
                                                  (.stream.txt.out out
                                                                   .sys.eol)
                                                  (.stream.flush out)
                                                  (dissoc env
                                                          :result)))))}))]
    (dissoc ret
            :eval
            :form+
            :name
            :on.ex
            :on.ex.reader
            :on.prompt
            :on.result
            :stop?
            :stream.in
            :stream.out))))




(defn .worker.result

  ^{:doc {:description ["Used by `.worker.start` for outputting results for requests"
                        "received by another process conforming to the protocol described"
                        "in `.worker.exec`."
                        ""
                        "A result is printed as a Vector where:"
                        ""
                        "  0: Boolean indicating success, `false` in case of an exception, `true`"
                        "     otherwise"
                        "  1: Key that was sent in the request, identifying it"
                        "  2: Result (exception in case of failyre)"]
          :signature   [{:params [env success? key result]}]}}

  [env success? key result]

  (let [limit  (:stream.out.limit env)
        out    (:stream.out env)
        result (:result env)]
    (.stream.out out
                 success?)
    (.stream.txt.out out
                     " ")
    (.stream.out out
                 key)
    (.stream.txt.out out
                     " ")
    (if limit
      (.stream.txt.out out
                       (.cell.str limit
                                  result))
      (.stream.out out
                   result))
    (.stream.txt.out out
                     .sys.eol)
    (.stream.flush out))
  nil)



(defn .worker.start

  ^{:doc {:description ["Turns this Convex Shell into a worker."
                        ""
                        "See `.worker.repl` about obtaining a REPL to it from another"
                        "Shell."
                        ""
                        ""
                        "A Map of options may be provided:"
                        ""
                        "  :pipe"
                        "    A name that the other Shell can use in `.worker.repl` to connect"
                        "    via named pipes on Unix systems."
                        "    Will use `.worker.pipe+` for creating those pipes and will ignore"
                        "    stream options below."
                        ""
                        "  :stream.in"
                        "    Input stream to use for listening to requests."
                        "    Ignored if named pipes are used."
                        "    Defaults to STDIN otherwise."
                        ""
                        "  :stream.out"
                        "    Output stream to use for writing results."
                        "    Ignored if named pipes are used."
                        "    Defaults to STDOUT otherwise."]
          :examples    [{:code (.worker.start)}
                        {:code (.worker.start {:pipe "foo"})}]
          :signature   [{:params []}
                        {:params [option+]}]}}


  ([]

   (.worker.start nil))


  ([option+]

   (let [option-2+ (merge option+
                          {:eval         (fn [env]
                                           (let [form+ (:form+ env)]
                                             (.repl.eval (assoc env
                                                                :form+      (next form+)
                                                                :worker.key (first form+)))))
                           :on.ex        (fn [env]
                                           (.worker.result env
                                                           false
                                                           (first (:form+ env))
                                                           (:result env))
                                           env)
                           :on.ex.reader (fn [env message]
                                           (.worker.result env
                                                           false
                                                           nil
                                                           [:reader
                                                            message])
                                           env)
                           :on.prompt    (fn [env]
                                           env)
                           :on.result    (fn [env]
                                           (let [result (:result env)]
                                             (.worker.result env
                                                             true
                                                             (:worker.key env)
                                                             result)
                                           (if (= result
                                                  :worker.stop)
                                             (dissoc env
                                                     :result)
                                             env)))})
         pipe      (:pipe option+)
         option-3+ (if pipe
                     (let [[pipe-in
                            pipe-out] (.worker.pipe+ pipe)]
                       (assoc option-2+
                              :stream.in  (.file.stream.in pipe-in)
                              :stream.out (.file.stream.out pipe-out)))
                     option-2+)]
     (.repl option-3+)
     nil)))


;;;;;;;;;; Help


(defn ?

  ^{:doc {:description ["Get help."]
          :examples    [{:code (?)}
                        {:code (? #8)}
                        {:code (? #8 'inc)}
                        {:code (? 'inc)}]
          :signature   [{:params [query]}
                        {:params [address symbol]}]}}

  ([]

   (.stream.txt.outln "")
   (?.title "Information about an account")
   (?.txt "(? address)         ->  (? #8)")
   (?.title "Information about a symbol")
   (?.txt "(? symbol)          ->  (? 'inc)")
   (?.txt "(? address symbol)  ->  (? #8 'inc)")
   (?.title "Information about the Convex Shell")
   (?.txt "(?.shell)")
   (.stream.txt.outln "")
   nil)


  ([query]

   (.stream.txt.outln "")
   (cond
     ;;
     (address? query)
     (?.account query)
     ;;
     (symbol? query)
     (?.sym query)
     ;;
     (.stream.txt.outln "Ask for an address or a symbol."))
   nil)


  ([addr sym]

    (.stream.txt.outln "")
    (?.sym addr
           sym)
    nil))



(defn ?.account

  ^:private?

  [addr]

  (if-let [-account (account addr)]
    (?.print.account (assoc -account
                            :help.addr
                            addr))
    (.stream.txt.outln (str "Account not found for address "
                            addr))))



(defn ?.color

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.blue)
       s
       (.term.reset)))



(defn ?.color-2

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.green)
       s
       (.term.reset)))



(defn ?.print.env

  ^:private?

  [env metadata filt]

  (reduce (fn [n sym-str]
            (let [sym      (symbol sym-str)
                  meta-sym (get metadata
                                sym)]
              (if (and (not (get meta-sym
                                   :private?))
                         (filt sym
                               meta-sym))
                (do
                  (?.txt (?.color-2 sym))
                  (?.txt-2 (when-let [desc (:description (:doc meta-sym))]
                             (let [desc-2 (if (str? desc)
                                            desc
                                            (let [first-line (first desc)]
                                              (if (> (count desc)
                                                     1)
                                                (str first-line
                                                     "..")
                                                first-line)))]
                               (if (> (count desc-2)
                                      80)
                                 (str (slice desc-2
                                             0
                                             77)
                                      "...")
                               desc-2))))
                  (inc n))
                n)))

           0
           (.str.sort (keys env))))



(defn ?.print.account

  ^:private?

  [-account]

  (.stream.txt.outln "")
  (let [addr   (:help.addr -account)
        lookup (call *registry*
                     (lookup addr))]
    (.docoll (fn [[title txt]]
               (?.title title)
               (?.txt txt))
             [["Address"     addr]
              ["Name"        (:name lookup)]
              ["Description" (:description lookup)]
              ["Allowance"   (:allowance -account)]
              ["Balance"     (:balance -account)]
              ["Controller"  (:controller -account)]
              ["Key"         (when-let [key (:key -account)]
                               (str "0x"
                                    key))]])
  
    (?.title "Overview")
    (let [env      (:environment -account)
          metadata (:metadata -account)]
      (if (empty? env)
        (?.txt "Empty environment.")
        (?.print.env env
                     metadata
                     (fn [sym _sym-meta]
                       (let [first-char (first (str sym))]
                         (and (not (= first-char
                                      \.))
                              (not (= first-char
                                      \?))))))))))



(defn ?.print.sym

  ^:private?

  [sym-meta]

  (?.title "Defined in")
  (?.txt (:help.addr sym-meta))
  (let [doc          (:doc sym-meta)
        code->reason (:errors doc)
        example+     (:examples doc)
        signature+   (:signature doc)]
    (?.title "Description")
    (?.txt (:description doc))
    (when-not (empty? signature+)
      (?.title (.str.pluralize (count signature+)
                               "Signature"))
      (.docoll (fn [signature]
                 (.stream.txt.outln (str "  "
                                         (:params signature))))
               signature+))
    (when-not (empty? code->reason)
      (?.title "Throws")
      (.docoll (fn [[code reason]]
                 (?.txt (str code
                             (?.color " <- ")
                             reason)))
               code->reason))
    (when-not (empty? example+)
      (?.title (.str.pluralize (count example+)
                               "Example"))
      (.docoll (fn [example]
                 (?.txt (:code example)))
               example+))))



(defn ?.shell


  ([]
 
   (let [feature (fn [feature description]
                   (str "  "
                        (.term.bold)
                        feature
                        (.term.reset)
                        "  "
                        description))]
     (.docoll .stream.txt.outln
              [""
               "Convex Shell augments the Convex Virtual Machine with additional features"
               "useful for developing smart contracts in Convex Lisp."
               ""
               "These functions and values are prefixed with `.` to be easily recognizable."
               "None of this is available on-chain with the regular Convex Virtual Machine."
               ""
               "Key sets of features are:"
               ""
               (feature ".a      "
                        "Utilities for async programming")
               (feature ".account"
                        "Account management")
               (feature ".bench  "
                        "Benchmarking")
               (feature ".cell   "
                        "Cell-related utilities")
               (feature ".client "
                        "Querying and transacting over peers")
               (feature ".cvmlog "
                        "CVM log management")
               (feature ".db     "
                        "Using Etch, the fast immutable database for cells")
               (feature ".dep    "
                        "Dependency management and file reloading")
               (feature ".file   "
                        "Reading and writing files")
               (feature ".fs     "
                        "Filesystem utilities")
               (feature ".gen    "
                        "Generating random values in a controlled way")
               (feature ".juice  "
                        "Juice operations")
               (feature ".kp     "
                        "Creating and managing key pairs")
               (feature ".log    "
                        "Logging utilities")
               (feature ".peer   "
                        "Running Convex peers and networks")
               (feature ".pfx    "
                        "Safely storing and retrieving key pairs from files")
               (feature ".process"
                        "Shelling out processes")
               (feature ".reader "
                        "Reading cells from Strings")
               (feature ".repl   "
                        "Read-Eval-Print-Loop for interactive work")
               (feature ".shell  "
                        "Shell configuration")
               (feature ".state  "
                        "Convex state management, such as time travel")
               (feature ".str    "
                        "String utilities")
               (feature ".stream "
                        "Generic utilities for reading and writing streams (files and beyond)")
               (feature ".sys    "
                        "System utilities")
               (feature ".t      "
                        "Unit testing library")
               (feature ".term   "
                        "Terminal ANSI escape codes (e.g. colored output)")
               (feature ".testnet"
                        "Utilities for the public testnet hosted by `https://convex.world`")
               (feature ".trx    "
                        "Executing transactions like a peer would")
               (feature ".try    "
                         "Error handling abstractions built over `.state.safe`.")
               (feature ".time   "
                        "Time utilities")
               (feature ".worker "
                        "Connect to a Convex Shell through STDIO")
               ""]))
   (?.title "List everything available in a feature set")
   (?.txt "(?.shell feature-set)  ->  (?.shell '.account)")
   (?.title "List all Shell features")
   (?.txt "(?.shell.list)")
   (?.title "Help about a function or a value")
   (?.txt "(? symbol)             ->  (? '.time.unix)")
   nil)


 ([sym]

   (.stream.txt.outln "")
   (when-let [txt (get-in (account .account.core)
                          [:metadata
                           sym
                           :shell.section])]
     (?.title sym)
     (?.txt txt)
     (.stream.txt.outln ""))
   (?.title (str "Overview of Shell features matching `" sym "`"))
   (let [sym-2     (or (get {'.str '.str.  ;; avoids printing stream utils
                             '.t   '.t.}
                            sym)  ;; avoids printin anything that starts with `.t`
                       sym)
         core      (account .account.core)
         prefix    (str sym-2)
         n-slice   (count prefix)
         n-printed (?.print.env (:environment core)
                                (:metadata core)
                                (fn [sym sym-meta]
                                  (and (?.shell.list.filter sym
                                                            sym-meta)
                                       (let [target (str sym)]
                                         (and (>= (count target)
                                                  n-slice)
                                              (= (slice (str sym)
                                                        0
                                                        n-slice)
                                                 prefix))))))]
     (when (zero? n-printed)
       (?.txt "No matching symbols found.")))
   nil))



(defn ?.shell.list

  []

  (.stream.txt.outln "")
  (?.title "All Shell functions and values")
  (let [core (account .account.core)]
    (?.print.env (:environment core)
                 (:metadata core)
                 ?.shell.list.filter))
  nil)



(defn ?.shell.list.filter

  ^:private?

  [sym _sym-meta]

  (let [first-char (first (str sym))]
    (or (= first-char
           \.)
        (= first-char
           \?))))



(defn ?.sym

  ^:private?

  ([sym]

   (if-let [sym-meta (or (?.sym.meta *address*
                                     sym)
                         (?.sym.meta .account.core
                                     sym))]
     (?.print.sym sym-meta)
     (.stream.txt.outln "Symbol not found in current account nor in core account.")))


  ([addr sym]

   (if-let [sym-meta (?.sym.meta addr
                                 sym)]
     (?.print.sym sym-meta)
     (.stream.txt.outln (str "Symbol not found in account "
                             addr)))))



(defn ?.sym.meta

  ^:private?

  [addr sym]

  (when-let [sym-meta (get-in (account addr)
                              [:metadata
                               sym])]
    (assoc sym-meta
           :help.addr addr
           :help.sym  sym)))



(defn ?.title

  ^:private?

  [s]

  (.stream.txt.outln (?.color (str s
                                   ":"))))



(defn ?.txt

  ^:private?

  [s]

  (if s
    (if (vector? s)
      (.docoll (fn [s]
                 (.stream.txt.outln (str "  "
                                         s)))
               s)
      (.stream.txt.outln (str "  "
                              s)))
    (.stream.txt.outln "  None.")))



(defn ?.txt-2

  ^:private?

  [s]

  (.stream.txt.out "  ")
  (?.txt s))
