;;
;; CONVEX SHELL LIBRARY
;;
;; Unlocks all the extra features offered by the Shell through `.shell.invoke`.
;;


;;;;;;;;;; Miscellaneous helpers, private and public


(defn .docoll

  ^:private?

  [f coll]

  (let [n (count coll)]
    (loop [i 0]
      (if (< i
             n)
        (do
          (f (nth coll
                  i))
          (recur (inc i)))
        nil))))



(defn .every?

  ^:private?

  [f coll]

  (reduce (fn [_ x]
            (or (f x)
                (reduced false)))
          true
          coll))



(defn .prn

  ^{:doc {:description "Prints arguments in a vector using `.stream.outln`."
          :examples    [{:code (.prn :a :b :c)}]
          :signature   [{:params [& arg+]}]}}

  [& arg+]

  (.stream.outln arg+))


;;;;;;;;;; Async


(def .a

  ^{:private?      true
    :shell.section ["Utilities for async programming."]}

  nil)



(defn .a.take

  ^{:doc {:description ["Awaits an async value."
                        ""
                        "Optionally, a timeout in milliseconds may be provided."
                        "If this tiemout is reached, the timeout value is returned."]
          :examples    [{:code (.a.take (.a.do* (inc 42)))}
                        {:code (.a.take (.a.do* (.time.sleep 1000) 42) 5000 :timeout)}]
          :signature   [{:params [async-value]}
                        {:params [async-value timeout.millis timeout.value]}]}}


  ([async-value]

   (.shell.invoke '.a.take
                  async-value))


  ([async-value timeout.millis timeout.value]

   (.shell.invoke '.a.take.timeout
                  async-value
                  timeout.millis
                  timeout.value)))



(defn .a.do

  ^{:doc {:description ["Executes the given no-arg function in parallel."
                        "Returns an async value that can be awaited with `.a.take`."
                        ""
                        "Trying to open an Etch instance in this function will throw."
                        "If Etch is required, it should be open behorehand."
                        ""
                        "See `.a.do*` for a convenience macro."]
          :examples    [{:code (.a.do (fn [] (.time.sleep 1000) 42))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.a.do
                 f))



(defmacro .a.do*

  ^{:doc {:description ["Convenience macro over `.a.do`."
                        "Code to execute is provided as-is, without wrapping it in a function."]
          :examples    [{:code (.a.do* (.time.sleep 1000) 42)}]
          :signature   [{:params [& body]}]}}

  [& body]

  `(.a.do ~(concat '(fn [])
                   body)))


;;;;;;;;;; Account


(def .account

  ^{:private?      true
    :shell.section ["Utilities centered on Convex accounts."
                    "Notably, see `.account.switch`."]}

  nil)



(def .account.0-key

  ^{:doc {:description "Fake key, useful for turning an actor into a user account with `set-key`."}}

  0x0000000000000000000000000000000000000000000000000000000000000000)



(def .account.core

  ^{:doc {:description "Address of the core account where all core functions are defined."}}

  $CORE$)



(defn .account.key?

  ^{:doc {:description "Returns true if `x` is a 32-byte blob that can act as a key."
          :examples    [{:code (.account.key? $.account/fake-key)}
                        {:code (.account.key? 42)}]
          :signature   [{:params [x]}]}}

  [x]

  (and (blob? x)
       (= (count x)
          32)))



(def .account.genesis

  ^{:doc {:description "Address of the account used when starting the Shell."}}

  .account.genesis)



(defn .account.switch

  ^{:doc {:description ["Switches the execution context to the given address."]
          :examples    [{:code (.account.switch #3)}]
          :signature   [{:params [address]}]}}

  [address]

  (.shell.invoke '.account.switch
                 address))


;;;;;;;;;; Benchmarking


(def .bench

  ^{:private?      true
    :shell.section ["Micro-benchmarking utilities."]}

  nil)



(defn .bench.eval

  ^{:doc {:description ["Benchmarks the mean execution time of evaluating the given code."
                        "Any state change is reverted each time."
                        ""
                        "Returns a map with:"
                        ""
                        "  :avg"
                        "    Average execution time (seconds)"
                        ""
                        "  :Hz"
                        "    Frequency, 1 divided by `:avg`."
                        ""
                        "  :stddev"
                        "    Standard deviation (seconds)"
                        ""
                        "Executed a high number of times for accurate measurement."
                        ""
                        "Highly experimental and subject to change, probably useful for CVM developers only."
                        "Depending on the given code, usually takes between one and several minutes to complete."]
          :examples    [{:code (.bench.eval '(+ 2 2))}
                        {:code (.bench.eval (compile '(+ 2 2)))}]
          :signature   [{:params [code]}]}}


  [code]

  (.shell.invoke '.bench.eval
                 code))



(defn .bench.trx

  ^{:doc {:description ["Exactly like `.bench.eval` but executes a actual transaction,"
                        "which also accounts for other concerns such as juice accounting."
                        ""
                        "`:Hz` is effectively TPS (Transactions-Per-Second)."
                        ""
                        "See `(?.shell '.trx)` about transactions"]
          :examples    [{:code (.bench.trx (.trx.new.transfer *address* #12345 1000))}]
          :signature   [{:params [trx]}]}}


  [trx]

  (.shell.invoke '.bench.trx
                 trx))




(defn .bench.trx.gen

  ^{:doc {:description ["Similar to `.bench.trx` but works with a transaction generator."
                        "The "
                        ""
                        "See `(?.shell '.gen)` about generators and `(?.shell '.trx)` about"
                        "transactions".]
          :examples    [{:code (.bench.trx.gen (.gen.fmap (fn [amount] (.trx.new.transfer *address* #12345 amount)) (.gen.long.uniform 0 1000)))}]
          :signature   [{:params [gen]}
                        {:params [gen option+]}]}}


  ([gen]

   (.bench.trx.gen gen
                   nil))


   ([gen option+]

    (.shell.invoke '.bench.trx.gen
                   gen
                   (or (:sample.count option+)
                       60)
                   (or (:sample.time option+)
                       1000000000))))


;;;;;;;;;; Cell utilities


(def .cell

  ^{:private?      true
    :shell.section ["Developer utilities centered on cells."
                    "Meant for more advanced users."]}

  nil)



(defn .cell.compile

  ^{:doc {:description ["Compiles the given `cell` for the given `address`, even when no account"
                        "exist for that address in the current Shell."
                        ""
                        "Typically used for pre-compiling code for a transaction targeting a network"
                        "where that account exists, as a way of saving on transaction fees (on-chain"
                        "compilation is more expensive than executing precompiled code)."
                        ""
                        "User must think carefully about macros since the cell will be expanded against"
                        "the given `state` (defaults to `*state*`)."]
          :examples    [{:code (.cell.compile #1234567890 '(def foo (inc bar)))}
                        {:code (.cell.compile (.state.genesis) #1234567890 '(def foo (inc bar)))}]
          :signature   [{:params [address cell]}
                        {:params [state address cell]}]}}


  ([address cell]

   (.cell.compile nil
                  address
                  cell))


  ([state address cell]

   (.shell.invoke '.cell.compile
                  (or state
                      *state*)
                  address
                  cell)))



(defn .cell.ref.stat

  ^{:doc {:description ["Given a cell (cannot be `nil`), returns a map where:"
                        ""
                        "  :direct"
                        "    Number of direct refs."
                        ""
                        "  :embedded"
                        "    Number of embedded cells."
                        ""
                        "  :persisted"
                        "    Number of refs marked as persisted."
                        ""
                        "  :soft"
                        "    Number of soft refs."
                        ""
                        "  :total"
                        "    Total number of refs."
                        ""
                        "This is an advanced feature meant for CVM developers familiar"
                        "with the notion of cell references."]
          :examples    [{:code (.cell.ref.stat *state*)}]
          :signature   [{:params [cell]}]}}

  [cell]

  (when (nil? cell)
    (fail :ARGUMENT
          "Cell cannot be `nil`"))
  (.shell.invoke '.cell.ref.stat
                 cell))



(defn .cell.size

  ^{:doc {:description ["In bytes, returns the memory size of the given `cell`."
                        "Accounts for the encoding of the `cell` as well as any of"
                        "its children (if any)."
                        ""
                        "Cell cannot be `nil`."]
          :examples    [{:code (.cell.size [:a :b])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.cell.size
                 cell))


;;;;;;;;;; Binary client


(def .client

  ^{:private?      true
    :shell.section ["The binary client allows for connecting to a peer for the purpose"
                    "of issuing queries and transactions."]}

  nil)



(defn .client.close

  ^{:doc {:description ["Closes the given `client`."
                        "See `.client.connect`."]
          :examples    [{:code (.client.close (.client.connect)) }]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.close
                 client))



(defn .client.connect

  ^{:doc {:description ["Returns a client connected to the requested peer."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :host"
                        "    Peer URL (String)."
                        "    Defaults to `\"localhost\"`."
                        ""
                        "  :port"
                        "    Port exposed by `:host` (Long)."
                        "    Defaults to `18888`."
                        ""
                        "Also see `.client.close`."]
          :examples    [{:code (.client.connect)}
                        {:code (.client.connect {:host "convex.world", :port 18888})}]
          :signature   [{:params []}
                        {:params [option+]}]}}


  ([]

   (.client.connect nil))


  ([option+]

   (.shell.invoke '.client.connect
                  (or (:host option+)
                      "localhost")
                  (or (:port option+)
                      18888))))



(defn .client.query

  ^{:doc {:description ["Issues a query for executing `code` in the context of `address`."
                        ""
                        "Queries are a dry run: executed only by the target peer, without"
                        "consensus, and any state change is eventually discarded."
                        "They are read-only operations and do not incur fees in Convex Coins."
                        ""
                        "Returns an async value that can be awaited with `.a.take`."
                        "Will resolve to a map such as:"
                        ""
                        "  :error"
                        "    Error code if an exception was thrown (`nil` otherwise)."
                        ""
                        "  :id"
                        "    Long incremented by the client on each query or transaction."
                        ""
                        ""
                        "  :info"
                        "    In case of success, `nil`."
                        "    In case of `:error`, a map such as:"
                        ""
                        "      :address"
                        "        Address of the account where the exception was thrown."
                        ""
                        "      :trace"
                        "        Trace of the exception."
                        ""
                        "  :result"
                        "    In case of success, the result from executing `code`."
                        "    In case of `:error`, the exception message."
                        ""
                        "An Etch instance must be open (see `.db.open`)."]
                        :examples    [{:code (.a.take (.client.query (.client.connect {:host "convex.world"}) #2 '*balance*))}]
          :signature   [{:params [client address code]}]}}

  [client address code]

  (.shell.invoke '.client.query
                 client
                 address
                 code))



(defn .client.query.state

  ^{:doc {:description ["Queries the current `*state*` of the peer."
                        "Returns an async value that can be awaited with `.a.take`."
                        ""
                        "This operation could take anywhere from seconds to hours depending on the size"
                        "of the state."]
          :examples    [{:code (.a.take (.client.query.state (.client.connect {:host "convex.world"})))}]
          :signature   [{:params [client]}]}}

  [client]

  (.shell.invoke '.client.query.state
                 client))



(defn .client.resolve

  ^:private?

  ;; Seems to have trouble with hashes that do no point to existing data.
  ;; Will be fixed.

  [client hash]

  (.shell.invoke '.client.resolve
                 client
                 hash))



(defn .client.repl

  ^{:doc {:description ["Like `.repl` but connects to a Convex peer."
                        ""
                        "Each line of code provided interactively will executed depending on the"
                        "current mode. Five modes are supported:"
                        ""
                        "  :local"
                        "    All input code is executed locally in the Shell."
                        "    Result from the last execution is available under `$`."
                        ""
                        "  :query"
                        "    Input code is issued to the peer as a query (read-only operation without"
                        "    consensus, only executed by the peer, discarding any change at the end)."
                        ""
                        "  :query.prepare"
                        "    Combination between `:local` and `:query`."
                        "    Input code is first executed locally and the result is then issued to"
                        "    the peer as a query."
                        ""
                        "  :transact"
                        "    Input code is issued to the peer as a transaction."
                        ""
                        "  :transact.prepare"
                        "    Combination between `:local` and `:transact`."
                        "    Input code is first executed locally and the result is then issued to"
                        "    the peer as a transaction."
                        "    Useful when transactions must be somehow prepared (e.g. fetch source"
                        "    for a smart contract from a file)."
                        ""
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :address"
                        "    Address of the account issuing transactions."
                        "    If not provided and if `:host` is `\"convex.world\"` (public testnet),"
                        "    a new account will be created."
                        ""
                        "  :key-pair"
                        "    Key pair for signing transactions."
                        "    Mandatory if `:address` is provided."
                        ""
                        "  :host"
                        "    Peer URL (String)."
                        "    Defaults to `\"convex.world\"` (public testnet)."
                        ""
                        "  :port"
                        "    Port exposed by `:host` (Long)."
                        "    Defaults to `18888`."
                        ""
                        "  :timeout"
                        "    Timeout in milliseconds used for network requests."
                        "    Defaults to `10000`."
                        "    E.g. if a transaction takes longer than this, returns `:timeout`."
                        ""
                        "For other options, see `.repl`."
                        ""
                        ""
                        "Automatically opens an Etch instance if none is detected (see `.db.open`)."
                        ""
                        "To quit, enter `:q` or `:quit`."
                        "Returns a map with `:address`, `:key-pair`, and `:result` (last result)."]
          :examples    [{:code (.client.repl)}
                        {:code (.client.repl {:address #42, :key-pair matching-key-pair, :host "localhost"})}]
          :signature   [{:params []}
                        {:params [option+]}]}}

  ([]

   (.client.repl {}))
 

  ([option+]

   (.stream.txt.outln "")
   (let [host    (or (:host option+)
                     "convex.world")
         port    (or (:port option+)
                     18888)
         addr    (:address option+)
         kp      (:key-pair option+)
         timeout (or (:timeout option+)
                     10000)]
     (when-not (and (long? timeout)
                    (>= timeout
                        0))
       (fail :ARGUMENT
             "Timeout must be a Long >= 0"))
     (when (and addr
                (not kp))
       (fail :ARGUMENT
             "Address provided without matching key pair"))
     (when (and kp
                (not addr))
       (fail :ARGUMENT
             "Key pair provided without an address"))
     (let [out     (or (:stream.out option+)
                       (.stream.stdout))
           [addr-2
            kp-2]  (if (and addr
                            kp)
                     [addr
                      kp]
                     (if (= host
                            "convex.world")
                       (let [kp-2   (.kp.create)
                             _      (do
                                      (.stream.txt.out out
                                                       "Creating a new account on `convex.world`")
                                      (.stream.flush out))
                             addr-2 (.a.take (.testnet.create-account (.kp.pubkey kp-2))
                                             timeout
                                             :client.repl.timeout)
                             _      (if (= addr-2
                                             :client.repl.timeout)
                                      (fail :SHELL.CLIENT.REPL
                                            "Timeout while creating a new account")
                                      (.stream.txt.outln out
                                                         (str ": "
                                                              addr-2)))
                             _      (do
                                      (.stream.txt.out out
                                                       "Provisioning Convex Coins to new account")
                                      (.stream.flush out))
                             amount (.a.take (.testnet.faucet addr-2
                                                              100000000)
                                             timeout
                                             :client.repl.timeout)
                             _      (if (= amount
                                           :client.repl.timeout)
                                      (fail :SHELL.CLIENT.REPL
                                            "Timeout while provisioning funds")
                                      (.stream.txt.outln out
                                                         (str ": "
                                                              amount)))]
                         [addr-2
                          kp-2])
                       (fail :ARGUMENT
                             "Unless the peer is `convex.world`, must provid an address and a key pair")))]
       (when (nil? (.db.path))
         (let [db-path (.fs.tmp "convex-shell-"
                                ".etch")]
           (.stream.txt.outln (str "Opening Etch instance at `"
                                   db-path
                                   "`"))
           (.db.open db-path)))
       (.stream.txt.outln (str "Connecting to `"
                               host
                               ":"
                               port
                               "`"))
       (.stream.txt.outln "")
       (let [client   (.client.connect {:host host
                                        :port port})
             sequence (.a.take (.client.sequence client
                                                 addr-2))
             _        (when (nil? sequence)
                        (fail :SHELL.CLIENT
                              "Unable to retrieve sequence ID"))
             [ok?
              x]      (.state.safe (fn []
                                     (.repl (merge option+
                                                   {:client.repl.address  addr-2
                                                    :client.repl.client   client
                                                    :client.repl.host     host
                                                    :client.repl.key-pair kp-2
                                                    :client.repl.mode     :transact
                                                    :client.repl.port     port
                                                    :client.repl.sequence sequence
                                                    :client.repl.timeout  timeout
                                                    :eval                 .client.repl.eval
                                                    :on.prompt            .client.repl.on.prompt}))))]
         (.client.close client)
         (if ok?
           {:address  addr-2
            :key-pair kp-2
            :result   (:result x)}
           (.ex.rethrow x)))))))



(defn .client.repl.eval

  ^:private?

  [env]

  (let [form+  (:form+ env)
        form-1 (first form+)]
    (if (contains-key? #{:local
                         :query
                         :query.prepare
                         :transact
                         :transact.prepare}
                       form-1)
        (let [env-2 (assoc env
                           :client.repl.mode form-1
                           :result           form-1)]
          (if (contains-key? #{:local
                               :query.prepare
                               :transact.prepare}
                             form-1)
            (assoc env-2
                   :client.repl.local.result
                   (:result env))
            env-2))
      (let [code (if (= (count form+)
                        1)
                   form-1
                   (cons 'do
                         form+))
            eval  (get {:local            .client.repl.local
                        :query            .client.repl.query
                        :query.prepare    .client.repl.query.prepare
                        :transact         .client.repl.transact
                        :transact.prepare .client.repl.transact.prepare}
                       (:client.repl.mode env))]
        (eval env
              code)))))



(defn .client.repl.local

  ^:private?

  [env code]

  (.repl.eval (assoc (if (contains-key? env
                                        :client.repl.local.result)
                       (assoc (dissoc env
                                      :client.repl.local.result)
                              :result
                              (:client.repl.local.result env))
                       env)
                     :form+
                     (list `(let [$.address  ~(:client.repl.address env)
                                  $.key-pair ~(:client.repl.key-pair env)]
                              ~code)))))



(defn .client.repl.query

  ^:private?

  [env code]

  (.client.repl.remote.result env
                              (.client.query (:client.repl.client env)
                                             (:client.repl.address env)
                                             code)))



(defn .client.repl.query.prepare

  ^:private?

  [env code]

  (let [env-2 (.client.repl.local env
                                  code)]
    (.client.repl.query env-2
                        (:result env-2))))



(defn .client.repl.remote.result

  ^:private?

  [env async-result]

  (let [client (:client.repl.client env)
        result (.a.take async-result
                        (:client.repl.timeout env)
                        client)]
    (if (= result
           (:client.repl.client env))
      (assoc env
             :result
             :client.repl.timeout)
      (if-let [error (:error result)]
        (assoc env
               :exception? true
               :result     (assoc (:info result)
                                  :code    error
                                  :message (:result result)))
        (assoc env
               :result
               (:result result))))))



(defn .client.repl.transact

  ^:private?

  [env code]

  (let [sequence (:client.repl.sequence env)]
    (.client.repl.remote.result (assoc env
                                       :client.repl.sequence
                                       (inc sequence))
                                (.client.transact (:client.repl.client env)
                                                  (:client.repl.key-pair env)
                                                  (.trx.new.invoke (:client.repl.address env)
                                                                   code 
                                                                   {:sequence sequence})))))




(defn .client.repl.transact.prepare

  ^:private?

  [env code]

  (let [env-2 (.client.repl.local env
                                  code)]
    (.client.repl.transact env-2
                           (:result env-2))))



(defn .client.repl.on.prompt

  ^:private?

  [env]

  (let [out (:stream.out env)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          (:client.repl.host env)
                          ":"
                          (:client.repl.port env)
                          "~"
                          (:client.repl.address env)
                          (:client.repl.mode env)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  env)



(defn .client.sequence

  ^{:doc {:description ["Queries the next `*sequence*` of an address."
                        "Returns an async value that can be awaited with `.a.take`."
                        "The resolved value is the sequence ID that should be used in the next"
                        "transaction for that account."
                        ""
                        "Resolves to `nil` in case of a problem (e.g. account does not exist)."]
          :examples    [{:code (.a.take (.client.sequence (.client.connect {:host "convex.world"}) #11))}]
          :signature   [{:params [client address]}]}}

  [client address]

  (.shell.invoke '.client.sequence
                 client
                 address))



(defn .client.transact

  ^{:doc {:description ["Issues the given `transaction` after signing it with the provided"
                        "`key-pair`."
                        ""
                        "Transactions require consensus and incur fees in Convex Coins."
                        ""
                        "Returns the exact same value as `.client.query`."
                        ""
                        "For more about transaction, see `(?.shell '.trx)`."
                        ""
                        "If the `client` is connected to the testnet hosted by `convex.world`,"
                        "see `(?.shell '.testnet)` for creating an account and provisioning funds."]
          :signature   [{:params [client key-pair transaction]}]}}

  [client key-pair transaction]

  (.shell.invoke '.client.transact
                 client
                 key-pair
                 transaction))


;;;;;;;;;; Dependency management


(def .dep
  
  ^{:private?      true
    :shell.section ["Experimental dependency management framework."
                    ""
                    "Convex Lisp dependencies are expressed in a `project.cvx` file"
                    "residing in the root directory of your project."
                    ""
                    "Currently, 3 types of dependencies are supported:"
                    ""
                    "  :relative"
                    "    Project files relative to your `project.cvx` file."
                    "    Expressed as a vector `[:relative \"./path/inside/project\"]`."
                    ""
                    "  :local"
                    "    Local directory containing its own `project.cvx` file."
                    "    Expressed as a vector `[:local \"/path/to/another-project\"]`."
                    ""
                    "  :git"
                    "    Git repository containing its own `project.cvx` file."
                    "    Those will be cloned in a local cached found in `.shell.*root*`."
                    "    Expressed as a vector `[:git \"URL\" \"FULL_COMMIT_SHA\"]`."
                    ""
                    ""
                    "Here is an example of a `project.cvx` file showcasing those 3 types:"
                    ""
                    "  {:deps {main            [:relative \"./src/main\"]"
                    "          another-project [:local \"/home/foo/another-project\"]"
                    "          some-lib        [:git \"https://github.com/foo/bar\""
                    "                                \"38a44d086c95c7b190f47ea17712da130906495f\"]}}"
                    ""
                    "  `main`"
                    "     indicates that the project files can be found under `./src/main`."
                    ""
                    "  `another-project`"
                    "     points to a directory which should contain its own `project.cvx`,"
                    "     typically defining its own relative dependencies."
                    ""
                    "  `some-lib`"
                    "     points to a foreign Git repository that will be cloned locally if not"
                    "     found in the local cache, and that specific commit will be used."
                    ""
                    ""
                    "Inside a relative directory, files meant to be deployed in the Shell as"
                    "actors can be referred to by following the directory hierarchy. This is known"
                    "as the \"actor path\", expressed as a list."
                    ""
                    "E.g. Suppose the above example project defines a file at `./src/main/a/b.cvx`."
                    "     Its actor path would be: (main a b)"
                    "     Now, any other files in your project can require it by adding a similar map"
                    "     as a header which specifies a \"deploy vector\":"
                    ""
                    "        {:deploy [a.b (main a b)]}"
                    ""
                    "     In the requiring file, this will instruct the Shell to deploy `(main a b)` as"
                    "     an actor and its address will be bound to the chosen symbol, `a.b` in this case."
                    "     Such a deploy vector can refer to any number of actor paths."
                    ""
                    "Actor paths are recursive. If `some-lib`, in its own `project.cvx`, defines a relative"
                    "dependency called `lib` with a file `math.cvx`, you could require it similarly to:"
                    ""
                    "        {:deploy [a.b  (main a b)"
                    "                  math (some-lib lib math)]}"
                    ""]}

  nil)



(defn .dep.deploy

  ^{:doc {:description ["Deploys requested actors in the Shell."
                        "Expects a \"deploy vector\"."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map where each symbol from the deploy vector points"
                        "to the address of its corresponding deployed actor."]
          :examples    [{:code (.dep.deploy '[some-alias (path to actor)])}]
          :signature   [{:params [deploy-vector]}]}}

  [deploy-vector]

  (.shell.invoke '.dep.deploy
                 deploy-vector))



(defn .dep.exec

  ^{:doc {:description ["Given an actor path, deploys all dependencies in its deploy"
                        "vector using `.dep.deploy` and defines in the current account"
                        "all deployed addesses under their corresponding symbols."
                        ""
                        "The source of the actor then runs through `eval`, in the current"
                        "account."
                        "Very useful when used alongside `.repl` during development."

                        "See `(?.shell '.dep)`."]
          :examples    [{:code (.dep.exec '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  [actor-path]

  (when-not (list? actor-path)
    (fail :ARGUMENT
          "Requires an actor path"))
  (let [file     (.dep.read actor-path)
        required (:deploy file)]
    (when required
      (reduce (fn [_ [sym addr]]
                (eval `(def ~sym
                            ~addr))
                nil)
              nil
              (.dep.deploy required)))
    (eval (cons 'do
                (:src file)))))



(defn .dep.fetch

  ^{:doc {:description ["Fetches all dependencies required by the given actor path"
                        "or deploy vector."
                        "Does not deploy anything in the Shell but ensures everything"
                        "is available locally."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns some analysis data that is subject to change while"
                        "this dependency management framework is stabilized."]
          :examples    [{:code (.dep.fetch '(main foo bar))}
                        {:code (.dep.fetch '[foo.bar (main foo bar)])}]
          :signature   [{:params [required]}]}}

  [required]

  (.shell.invoke '.dep.fetch
                  (if (list? required)
                    ['_ required]
                    required)))



(defn .dep.read

  ^{:doc {:description ["Reads the content of a file by actor path."
                        ""
                        "See `(?.shell '.dep)`."
                        ""
                        "Returns a map with"
                        ""
                        "  :deploy"
                        "    Deploy vector of this actor if there is one."
                        ""
                        "  :filename"
                        "    Filename to the file."
                        ""
                        "  :src"
                        "    List of cells representing the source code of this actor."]
          :examples    [{:code (.dep.read '(main foo bar))}]
          :signature   [{:params [actor-path]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.

  [actor-path]

  (let [required actor-path]
    (if (list? required)
      (do
        (when (empty? required)
          (fail :ARGUMENT
                "Actor path is empty"))
        (get (.shell.invoke '.dep.read
                            ['x required])
             'x))
      (.shell.invoke '.dep.read
                     required))))



(defn .dep.require.filter

  ^:private?

  [f required]

  (let [n (count required)]
    (loop [acc []
           i   0]
      (if (< i
             n)
        (recur (let [sym  (get required
                               i)
                     path (get required
                               (inc i))]
                 (if (f sym
                        path)
                   (conj acc
                         sym
                         path)
                   acc))
               (+ i
                  2))
        acc))))
                      


(defn .dep.test

  ^{:doc {:description ["Executes unit tests by actor path."
                        "The actor is effectively a test suite which specifies all files"
                        "to test in its deploy vector."
                        ""
                        "A map of options map be provided with:"
                        ""
                        "  :focus"
                        "    Vector of metadata keywords, actors by alias, or individual tests to"
                        "    focus. Meaning only corresponding tests will run while other ones will"
                        "    be skipped."
                        ""
                        "  :skip"
                        "    Just like `:focus` but behaves in the opposite way: everything else will run"
                        "    but what is specified in this vector."
                        ""
                        "E.g. These options will run only actors A and B, as aliased in the deploy vector,"
                        "     and skip all tests which have `{:slow? true}` in their metadata:"
                        ""
                        "        {:focus [A B]"
                        "         :skip  [:slow?]}"
                        ""
                        ""
                        "See:"
                        "  (?.shell '.dep)"
                        "  (?.shell '.t)"]
          :examples    [{:code (.dep.test '(test foo bar))}
                        {:code (.dep.test '(test foo bar) {:skip [:slow?]})}]
          :signature   [{:params [actor-path]}
                        {:params [actor-path option+]}]}}

  ;; Also supports as deploy vector, not only an actor path.
  ;; But not documented for now, for the sake of simplicity.


  ([actor-path]

   (.dep.test actor-path
              nil))


  ([actor-path option+]

   (let [test            (if .*dev?*
                           .t.dev
                           .t.main)
         required        actor-path
         required-2      (if (list? required)
                           (:deploy (.dep.read required))
                           required)
         focus           (:focus option+)
         focus.test      (reduce (fn [actor-sym->test+ x]
                                   (if (and (list? x)
                                            (not (empty? x))
                                            (= (first x)
                                               'lookup))
                                     (let [actor-sym (second x)]
                                       (assoc actor-sym->test+
                                              actor-sym
                                              (conj (or (get actor-sym->test+
                                                             actor-sym)
                                                        #{})
                                                    (nth x
                                                         2))))
                                     actor-sym->test+))
                                 {}
                                 focus)
         option-2+       (assoc option+
                                :focus.test
                                focus.test)
         focus-actor+    (union (set (filter symbol?
                                             focus))
                                (set (keys focus.test)))

         required-3      (if (empty? focus-actor+)
                           required-2
                           (.dep.require.filter (fn [sym _path]
                                                  (contains-key? focus-actor+
                                                                 sym))
                                                required-2))
         skip            (:skip option+)
         skip-actor+     (set (filter symbol?
                                      skip))
         required-4      (if (empty? skip-actor+)
                           required-3
                           (.dep.require.filter (fn [sym _path]
                                                  (not (contains-key? skip-actor+
                                                                      sym)))
                                                required-3))
         option-3+       (assoc option-2+
                                :skip.test
                                (reduce (fn [skip.test x]
                                          (if (and (list? x)
                                                   (not (empty? x))
                                                   (= (first x)
                                                      'lookup))
                                            (let [actor-sym (second x)]
                                              (assoc skip.test
                                                     actor-sym
                                                     (conj (or (get skip.test
                                                                    actor-sym)
                                                               #{})
                                                           (nth x
                                                                2))))
                                            skip.test))
                                        {}
                                        skip))
                         ]
     (test (.dep.deploy required-4)
           (assoc option-3+
                  :focus.meta (set (filter keyword?
                                           focus))
                  :order      (filter symbol?
                                      required-4)
                  :skip.meta  (set (filter keyword?
                                           skip)))))))


;;;;;;;;;; Dev


(def .*dev?*

  ^{:doc {:description ["Boolean indicating if the Shell is in dev mode."
                        "Some utilities uses this value to change behavior."
                        ""
                        "E.g. `.dep.test` will not terminate the process if this value is `false`."]}}

  false)



(defn .dev.set

  ^{:callable? true
    :doc       {:description ["Sets `.*dev*`."]
                :examples    [{:code (.dev.set true)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         $CORE$)
    (def .*dev?*
         (boolean enable?))
    (call $CORE$
          (.dev.set enable?))))


;;;;;;;;; Etch


(def .db

  ^{:private?      true
    :shell.section ["Etch is a fast, immutable database for Convex data."
                    ""
                    "Writing a cell returns the hash of that cell whereas reading"
                    "requiring a hash and returns the corresponding cell."
                    ""
                    "Only one instance can be open per Shell."
                    "See `.db.open`."]}

  nil)
 
 

(defn .db.flush

  ^{:doc {:description ["Flushes the current Etch instance."
                        ""
                        "Happens automatically when the process terminates gracefully."
                        "Good idea to flush manually once in a while to ensure data"
                        "is persisted on disk."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.flush))



(defn .db.open

  ^{:doc {:description ["Opens an Etch instance."
                        ""
                        "Must be called before calling any other DB function."
                        "Not providing a path will create an instance in a temporary file."
                        "File is created if it does not exist."
                        ""
                        "Attention, only one instance can be open per Shell."]
          :examples    [{:code (.db.open "path/to/file.etch")}]
          :signature   [{:params [path]}]}}


  ([]

   (.db.open nil))


  ([path]

   (.shell.invoke '.db.open
                  (or path
                      (.fs.tmp "convex-shell-"
                               ".etch")))))



(defn .db.path

  ^{:doc {:description ["Returns the path of the current Etch instance (or nil if"
                        "no instance has been open)."]
          :examples    [{:code (.db.flush)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.path))



(defn .db.read
  
  ^{:doc {:description ["Reads a cell by hash from the current Etch instance."
                        "Returns `nil` if no cell is found for that hash."
                        ""
                        "Also see `.db.write`."]
          :examples    [{:code (.db.read 0x1fa0dd51b167d4cca60177d13d731c461eae9cdb4ecd75e1e8f2158251968c66)}]
          :signature   [{:params [hash]}]}}

  [hash]

  (.shell.invoke '.db.read
                 hash))



(defn .db.root.read

  ^{:doc {:description ["Reads the root cell from the current Etch instance."
                        "Returns `nil` if no cell has been persisted to the root."
                        ""
                        "Also see `.db.root.write`."]
          :examples    [{:code (.db.root.read)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.root.read))



(defn .db.root.write

  ^{:doc {:description ["Writes the given `cell` to the root of the current Etch instance."
                        "Otherwise, behaves exactly like `.db.write`."
                        ""
                        "Also see `.db.root.read`."]
          :examples    [{:code (.db.root.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.root.write
                 cell))



(defn .db.size

  ^{:doc {:description ["Returns the full size of the current Etch instance in bytes."
                        ""
                        "Etch always allocates extra room in its instance file whereas"
                        "this value reflects the actual size of the data persisted."
                        ""
                        "E.g. Writing data will increase the data size but not always the"
                        "     filesize."]
          :examples    [{:code (.db.size)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.db.size))



(defn .db.write

  ^{:doc {:description ["Writes the given `cell` to the current Etch instance."
                        "Returns a new version of that cell."
                        ""
                        "If the cell is needed for more work, the old version should be discarded in favor of"
                        "that new version. This offers 2 main benefits:"
                        ""
                        "  - For more complex cells such as collections, part of the data can be garbage collected"
                        "    in case of memory pressure and retrieved transparently when needed again. Peers use"
                        "    this principle for storing and handling `*state*`s that are even bigger than memory."
                        "    The user does not have anything else to do but discard the old version and work with"
                        "    the new one."
                        ""
                        "  - Subsequent writes involving that cell directly or indirectly are optimized."
                        ""
                        "If the returned value is `nil`, it means the cell was not persisted."
                        "This happens only with a few basic cell types for optimization reasons."
                        "Precisely, those that are so simple they are usually embedded in more complex values:"
                        ""
                        "  - Addresses"
                        "  - Empty collections"
                        "  - Primitives (booleans, bytes, doubles, longs)"
                        "  - Symbolic (keywords and symbols)"
                        ""
                        "Also see `.db.read`."]
          :examples    [{:code (.db.write [:my 'cell 42])}]
          :signature   [{:params [cell]}]}}

  [cell]

  (.shell.invoke '.db.write
                 cell))


;;;;;;;;;; Exceptions


(defn .ex.print

  ^{:doc {:description ["Pretty prints the given exception (by default to STDOUT, see `.stream.stdout`)."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.print {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}
                        {:params [stream ex]}]}}

  ([ex]

   (.ex.print nil
              ex))


  ([stream ex]

   (let [msg        (:message ex)
         msg-2      (when (map? msg)
                      (:message msg))
         extra-data (when msg-2
                      (dissoc msg
                              :message))
         trace      (:trace ex)
         trace-2    trace]
     (.stream.txt.outln
       stream
       (str .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Exception code:"
            (.term.reset)
            .sys.eol
            "  "
            (.term.bold)
            (:code ex)
            (.term.bold)
            (.term.fg.red)
            .sys.eol
            "Executing address:"
            (.term.reset)
            .sys.eol
            "  "
            (:address ex)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Message:"
            (.term.reset)
            .sys.eol
            "  "
            (or msg-2
                msg)
            .sys.eol
            (.term.bold)
            (.term.fg.red)
            "Trace:"
            (.term.reset)
            (if (empty? trace-2)
              (str .sys.eol
                   "  None.")
              (apply str
                     (reduce (fn [acc entry]
                               (conj acc
                                     .sys.eol
                                     "  "
                                     entry))
                             []
                             trace-2)))
            (if (and extra-data
                     (not (empty? extra-data)))
              (str .sys.eol
                   (.term.bold)
                   (.term.fg.red)
                   "Extra data:"
                   (.term.reset)
                   .sys.eol
                   "  "
                   extra-data)
              ""))))))



(defn .ex.rethrow
  ^{:doc {:description ["Rethrow the given exception."
                        "For catching exceptions, see `.state.safe` and `.state.tmp`."]
          :examples    [{:code (.ex.rethrow {:code :ARGUMENT, :message "Some message"})}]
          :signature   [{:params [ex]}]}}

  [ex]

  (.shell.invoke '.ex.rethrow
                 ex))


;;;;;;;;;; File operations


(def .file

  ^{:private?      true
    :shell.section ["High-level utilities for reading and writing files,"
                    "either as text or as Convex data."
                    ""
                    "Builds on the stream utilities offered by the Shell."
                    "See `(?.shell '.stream)`."]}

  nil)



(defn .file.-handle

  ^:private?

  [x path]

  (if (nil? x)
    [(.gensym "file-")
     (.fs.resolve path)]
    x))



(defn .file.-read

  ^:private?

  [f-in path]

  (let [handle (.file.stream.in path)
        [ok?
         x]    (.state.safe (fn []
                              (f-in handle)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))



(defn .file.-write

  ^:private?

  [f-out path cell option+]

  (let [handle (.file.stream.out path
                                  option+)
        [ok?
         x]    (.state.safe (fn []
                              (f-out handle
                                     cell)))]
    (.stream.close handle)
    (if ok?
      x
      (.ex.rethrow x))))


;;;


(defn .file.exec

  ^{:doc {:description ["Like `.file.read` but also applies `eval`."]
          :examples    [{:code (.file.exec "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (eval (cons 'do
              (.file.read path))))



(defn .file.read

  ^{:doc {:description ["Returns a list of cells resulting from reading the given file."
                        "Also see `.file.txt.read`."]
          :examples    [{:code (.file.read "./my/file.cvx")}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  (.file.-read .stream.in+
               path))



(defn .file.stream.in

  ^{:doc {:description ["Returns a handle to an input stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."]
          :examples    [{:code (.file.stream.in "./my/file.cvx")}]
          :signature   [{:params [path]}]}}


  [path]

  (.shell.invoke '.file.stream.in
                 (.fs.resolve path)
                 path))



(defn .file.stream.out

  ^{:doc {:description ["Returns a handle to an output stream for the given file."
                        "See `(?.shell '.stream)` about stream utilities."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code (.file.stream.out "./my/file.cvx")}
                        {:code (.file.stream.out "./my/file.cvx" {:append? true})}]
          :signature   [{:params [path]}
                        {:params [path option+]}]}}


  ([path]

   (.file.stream.out path
                     nil))


  ([path option+]

   (.shell.invoke '.file.stream.out
                  path
                  (:append? option+))))



(defn .file.txt.read

  ^{:doc {:description ["Returns the content of the given file as a string."
                        "Also see `.file.read`."]
          :examples    [{:code (.file.txt.read "some/file.txt")}]
          :signature   [{:params [path]}]}}

  [path]

  (.file.-read .stream.txt.in
               path))



(defn .file.txt.write

  ^{:doc {:description ["Writes the given cell to the given file as a string."
                        "Same options as `.file.stream.out`."
                        ""
                        "Also see `.file.write`."]
          :examples    [{:code (.file.txt.write "some/file.txt" "Some text")}
                        {:code (.file.txt.write "some/file.txt" "Some text" {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.txt.write path
                    cell
                    nil))


  ([path cell option+]

   (.file.-write .stream.txt.outln
                 path
                 cell
                 option+)))



(defn .file.write

  ^{:doc {:description ["Writes the given cell to the given file."
                        "Same options as `.file.stream.out`."
                        "Can be read back as cells with `.file.read`."
                        ""
                        "Also see `.file.txt.write`."]
          :examples    [{:code (.file.write "some/file.cvx" [:a :b])}
                        {:code (.file.write "some/file.cvx" [:a :b] {:append? true})}]
          :signature   [{:params []}]}}


  ([path cell]

   (.file.write path
                cell
                nil))


  ([path cell option+]

   (.file.-write .stream.outln
                 path
                 cell
                 option+)))


;;;;;;;;;; Filesystem operations


(def .fs
 
  ^{:private?      true
    :shell.section ["Simple filesystem utilities."]}

  nil)



(defn .fs.copy

  ^{:doc {:description ["Copies the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code (.file.copy "some_dir/foo.txt" "another_dir")}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (.shell.invoke '.fs.copy
                 path-source
                 path-destination))



(defn .fs.delete

  ^{:doc {:description "Deletes the file or the empty folder at the given `path`."
          :examples    [{:code (.file.delete "some-file.cvx")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.delete
                 path))



(defn .fs.dir?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing directory."]
          :examples    [{:code (.fs.dir? "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.dir?
                 path))



(defn .fs.exists?

  ^{:doc {:description ["Returns `true` if a file or directory exists at the given path."]
          :examples    [{:code (.file.exists? "some_dir/some_file.txt")}]
          :signatures  [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.exists?
                 path))



(defn .fs.file?

  ^{:doc {:description ["Returns `true` if the given path refers to an existing regular file."]
          :examples    [{:code (.fs.file? "some/path")}]
          :signature   [{:params [path]}]}}
  [path]

  (.shell.invoke '.fs.file?
                 path))



(defn .fs.resolve

  ^{:doc {:description ["Returns the given path fully resolved as an absolute path."
                        "Follows symlinks."]
          :examples    [{:code (.fs.resolve "some/../../path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.resolve
                 path))



(defn .fs.size

  ^{:doc {:description ["Returns the size of the file at the given path (in bytes)."
                        "Returns `nil` if the file does not exist."]
          :examples    [{:code (.fs.size "some/path")}]
          :signature   [{:params [path]}]}}

  [path]

  (.shell.invoke '.fs.size
                 path))



(defn .fs.tmp

  ^{:doc {:description ["Creates a temporary file."
                        "`prefix` and `suffix` for the filename are both optional."]
          :examples    [{:code (.file.tmp)}
                        {:code (.file.tmp ".cvx")}
                        {:code (.file.tmp "some-project_" ".cvx")}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (.fs.tmp nil
            nil))


  ([suffix]

   (.fs.tmp nil
            suffix))


  ([prefix suffix]

   (.shell.invoke '.fs.tmp
                  (or prefix
                      "")
                  (or suffix
                      ""))))



(defn .fs.tmp.dir

  ^{:doc {:description ["Creates a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code (.file.tmp.dir)}
                        {:code (.file.tmp-dir "some-prefix")}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (.fs.tmp.dir nil))


  ([prefix]

   (.shell.invoke '.fs.tmp.dir
                  (or prefix
                      ""))))


;;;;;;;;;; Generators


(defn .gen


  ([generator]

   (.gen generator
         nil))


  ([generator option+]

   (.shell.invoke '.gen
                  generator
                  (or (:size option+)
                      30)
                  (:seed option+))))



(defn .gen.address

  []

  (.shell.invoke '.gen.address))



(defn .gen.always

  [x]

  (.shell.invoke '.gen.always
                 x))



(defn .gen.any

  []

  (.shell.invoke '.gen.any))



(defn .gen.any.coll

  []

  (.shell.invoke '.gen.any.coll))



(defn .gen.any.list

  []

  (.shell.invoke '.gen.any.list))



(defn .gen.any.map

  []

  (.shell.invoke '.gen.any.map))



(defn .gen.any.set

  []

  (.shell.invoke '.gen.any.set))



(defn .gen.any.vector

  []

  (.shell.invoke '.gen.any.vector))



(defn .gen.bigint

  []

  (.shell.invoke '.gen.bigint))



(defn .gen.bind

  [generator f]

  (.shell.invoke '.gen.bind
                 generator
                 f))



(defn .gen.blob


  ([]

   (.shell.invoke '.gen.blob))


  ([n]

   (.shell.invoke '.gen.blob.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.blob.bounded
                  min
                  max)))



(defn .gen.blob-32

  []

  (.shell.invoke '.gen.blob-32))



(defn .gen.blob-map


  ([generator-key generator-value]

   (.shell.invoke '.gen.blob-map
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.blob-map.fixed
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.blob-map.bounded
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.boolean

  []

  (.shell.invoke '.gen.boolean))



(defn .gen.char

  []

  (.shell.invoke '.gen.char))



(defn .gen.char.alphanum

  []

  (.shell.invoke '.gen.char.alphanum))



(defn .gen.double

  []

  (.shell.invoke '.gen.double))



(defn .gen.double.bounded

  [option+]

  (.shell.invoke '.gen.double.bounded
                 (:min option+)
                 (:max option+)
                 (:infinite? option+
                             true)
                 (:NaN? option+
                        true)))



(defn .gen.falsy

  []

  (.shell.invoke '.gen.falsy))



(defn .gen.fmap

  [f generator]

  (.shell.invoke '.gen.fmap
                 f
                 generator))



(defn .gen.freq


  [pair+]

  (.shell.invoke '.gen.freq
                 pair+))



(defn .gen.hex-string


  ([]

   (.shell.invoke '.gen.hex-string))


  ([n]

   (.shell.invoke '.gen.hex-string.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.hex-string.bounded
                  min
                  max)))



(defn .gen.keyword

  []

  (.shell.invoke '.gen.keyword))



(defn .gen.list


  ([generator]

   (.shell.invoke '.gen.list
                  generator))


  ([generator n]

   (.shell.invoke '.gen.list.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.list.bounded
                  generator
                  min
                  max)))



(defn .gen.long

  []

  (.shell.invoke '.gen.long))



(defn .gen.long.bounded

  [option+]

  (.shell.invoke '.gen.long.bounded
                 (:min option+)
                 (:max option+)))



(defn .gen.long.uniform

  [min max]

  (.shell.invoke '.gen.long.uniform
                 min
                 max))



(defn .gen.number

  []

  (.shell.invoke '.gen.number))



(defn .gen.map


  ([generator-key generator-value]

   (.shell.invoke '.gen.map
                  generator-key
                  generator-value))


  ([generator-key generator-value n]

   (.shell.invoke '.gen.map.fixed
                  generator-key
                  generator-value
                  n))


  ([generator-key generator-value min max]

   (.shell.invoke '.gen.map.bounded
                  generator-key
                  generator-value
                  min
                  max)))



(defn .gen.nil

  []

  (.shell.invoke '.gen.nil))



(defn .gen.or

  [generator+]

  (.shell.invoke '.gen.or
                 generator+))



(defn .gen.pick

  [x+]

  (.shell.invoke '.gen.pick
                 x+))



(defn .gen.record

  [k->gen]

  (let [k+ (keys k->gen)
        n  (count k+)]
    (.gen.fmap (fn [v+]
                 (loop [i      0
                        record {}]
                   (if (< i
                          n)
                     (recur (inc i)
                            (assoc record
                                   (get k+
                                        i)
                                   (get v+
                                        i)))
                     record)))
               (.gen.tuple (values k->gen)))))



(defn .gen.quoted

  [generator]

  (.shell.invoke '.gen.quoted
                 generator))



(defn .gen.scalar

  []

  (.shell.invoke '.gen.scalar))



(defn .gen.set


  ([generator]

   (.shell.invoke '.gen.set
                  generator))


  ([generator n]

   (.shell.invoke '.gen.set.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.set.bounded
                  generator
                  min
                  max)))



(defn .gen.string


  ([]

   (.shell.invoke '.gen.string))


  ([n]

   (.shell.invoke '.gen.string.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.string.bounded
                  min
                  max)))



(defn .gen.string.alphanum


  ([]

   (.shell.invoke '.gen.string.alphanum))


  ([n]

   (.shell.invoke '.gen.string.alphanum.fixed
                  n))


  ([min max]

   (.shell.invoke '.gen.string.alphanum.bounded
                  min
                  max)))



(defn .gen.such-that


  ([pred generator]

   (.gen.such-that nil
                   pred
                   generator))


  ([max-try pred generator]

   (.shell.invoke '.gen.such-that
                  (or max-try
                      100)
                  pred
                  generator)))



(defn .gen.symbol

  []

  (.shell.invoke '.gen.symbol))



(defn .gen.syntax


  ([]

   (.shell.invoke '.gen.syntax))


  ([generator-value]

   (.shell.invoke '.gen.syntax.with-value
                  generator-value))


  ([generator-value generator-meta]

   (.shell.invoke '.gen.syntax.with-meta
                  generator-value
                  generator-meta)))



(defn .gen.truthy

  []

  (.shell.invoke '.gen.truthy))



(defn .gen.tuple

  [generator+]

  (.shell.invoke '.gen.tuple
                 generator+))



(defn .gen.vector


  ([generator]

   (.shell.invoke '.gen.vector
                  generator))


  ([generator n]

   (.shell.invoke '.gen.vector.fixed
                  generator
                  n))


  ([generator min max]

   (.shell.invoke '.gen.vector.bounded
                  generator
                  min
                  max)))


;;;;;;;;;; Gensym


(def .*gensym*

  ^:private?

  0)



(defn .gensym

  ^{:callable? true
    :doc       {:description ["Returns a symbol guaranteed to be unique relative to other symbols generated"
                              "with this function in the context of a single process."
                              ""
                              "A prefix string may be provided (default to \"G_\")."
                              ""
                              "Useful for metaprogramming."]
                :examples    [{:code (.gensym)}
                              {:code ($.gensym "some-prefix-")}]
                :signature   [{:params []}
                              {:params [prefix]}]}}

  
  ([]

   (.gensym nil))


  ([prefix]

   (if (= *address*
          $CORE$)
     (do
       (let [id .*gensym*]
         (def .*gensym*
              (inc id))
         (symbol (str (or prefix
                          "G_")
                      id
                      "_"
                      (.time.nano)))))
     (call $CORE$
           (.gensym prefix)))))


;;;;;;;;;; Juice operations


(def .juice

  ^{:private?      true
    :shell.section ["Juice is the computational unit of Convex."
                    "All operations in a transaction, such as calling a function,"
                    "are measured in this unit."
                    ""
                    "Currently available juice can be retrieved with `*juice*`."
                    ""
                    "For instance, try setting this value to 0 with `.juice.set`"
                    "and do anything afterwards. A `:JUICE` exception will be thrown."]}

  nil)



(defn .juice.refill

  ^{:doc {:description ["Refills `*juice*` to the maximum value."
                        "Useful to call once in a while when running long operations."]
          :examples    [{:code (.juice.refill)}]
          :signature   [{:params []}]}}

  []

  (.juice.set 9223372036854775807))



(defn .juice.set

  ^{:doc {:description ["Sets `*juice*` to an exact amount."
                        "Useful when there is a need for limiting an operation."]
          :examples    [{:code (.juice.set 10000000)}]
          :signature   [{:params [n-unit]}]}}

  [n-unit]

  (.shell.invoke '.juice.set
                 n-unit))



(defn .juice.track

  ^{:doc {:description ["Tracks the juice consumption of the given transaction."
                        "Any state change is reverted."
                        ""
                        "Returns a vector of 4 elements:"
                        ""
                        "  0: Transaction result"
                        "  1: Juice cost when running as is"
                        "  2: Juice cost after `compile`"
                        "  3: Juice cost after `expand`"]
          :examples    [{:code (.juice.track '(if :a :b :c))}
                        {:code (.juice.track (compile '(if :a :b :c)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (conj (.shell.invoke '.juice.track
                       trx)
        (second (.shell.invoke '.juice.track
                               (compile trx)))
        (second (.shell.invoke '.juice.track
                               (expand trx)))))


;;;;;;;;;; Key pairs


(def .kp

  ^{:private?      true
    :shell.section ["Utilities for creating and handling key pairs (Ed25519)."
                    ""
                    "All user accounts are bounded to a key pair. The public key of an account"
                    "is kept on-chain (e.g. `(:key (account *address*))`). Whoever is holding"
                    "the matching private key can transact with that account."]}

  nil)



(defn .kp.create

  ^{:doc {:description ["Creates a key pair from a seed (32-byte Blob)."
                        "A random seed will be generated if none is provided."]
          :examples    [{:code (.kp.create)}
                        {:code (.kp.create 0xae09224a6683aa86ea7e3eaabc06fe9e8b056b0da5fa741677b11983ad2116c6)}]
          :signature   [{:params []}
                        {:params [seed]}]}}

  ([]

   (.shell.invoke '.kp.create))


  ([seed]

   (.shell.invoke '.kp.create.from-seed
                  seed)))



(defn .kp.pubkey

  ^{:doc {:description ["Extracts the public key from the given `key-pair`."]
          :examples    [{:code (.kp.public-key (.kp.create))}]
          :signature   [{:params [key-pair]}]}}

  [key-pair]

  (.shell.invoke '.kp.pubkey
                 key-pair))



(defn .kp.seed

  ^{:doc {:description ["Extracts the seed from the given `key-pair`."
                        "It can be used in `.kp.create` for recreating the key pair."
                        ""
                        "Attention, it follows that seeds are absolutely confidential."
                        "Anyone with a seed can recreate the exact same key pair."
                        ""
                        "You should NEVER share a seed with anyone unless you know exactly"
                        "what you are doing and what it means."]
          :examples    [{:code (.kp.seed (.kp.create))}]
          :signature   [{:params [key-pair]}]}}

  [key-pair]

  (.shell.invoke '.kp.seed
                 key-pair))



(defn .kp.sign

  ^{:doc {:description ["Returns a signature (64-byte Blob) of `x` (any cell) by this `key-pair`."
                        ""
                        "See `.kp.verify` for verifying signatures."]
          :examples    [{:code (.kp.sign (.kp.create) :some-cell)}]
          :signature   [{:params [key-pair x]}]}}

  [key-pair x]

  (.shell.invoke '.kp.sign
                 key-pair
                 x))



(defn .kp.verify

  ^{:doc {:description ["Returns `true` if the `signature` matches `x` for the given `public-key`."
                        ""
                        "See `.kp.sign` for producing signatures."]
          :signature   [{:params [signature public-key x]}]}}

  [signature public-key x]

  (.shell.invoke '.kp.verify
                 signature
                 public-key
                 x))


;;;;;;;;;; CVM log operations


(def .log

  ^{:private?      true
    :shell.section ["The core `log` functions allows for saving Convex data"
                    "for off-chain use. For instance, a peer might issue off-chain"
                    "notifications based on what is being logged."
                    ""
                    "On-chain, logged data is inaccessible. These few functions"
                    "allowing for inspecting it in the Shell."]}

  nil)



(defn .log.clear

  ^{:doc {:description ["Clears the CVM log."
                        "Also see `.log.get`."]
          :examples    [{:code (.log.clear)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.clear))



(defn .log.get

  ^{:doc {:description ["Returns the current CVM log."
                        "Values can be logged using the core `log` function."
                        ""
                        "Also see `.log.clear`."]
          :examples    [{:code (.log.get)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.log.get))


;;;;;;;;;; Peers


(defn .peer.init


  ([state key-pair]

   (.peer.init state
               key-pair
               nil))


  ([state key-pair option+]

   (.shell.invoke '.peer.init
                  state
                  key-pair
                  (or (:host option+)
                      "localhost")
                  (or (:port option+)
                      18888)
                  )))



(defn .peer.start

  [peer]

  (.shell.invoke '.peer.start
                 peer))



(defn .peer.stop

  [peer]

  (.shell.invoke '.peer.stop
                 peer))


;;;;;;;;;; PFX stores


(def .pfx

  ^{:private?      true
    :shell.section ["PFX stores securely index key pairs in flat files by alias (strings)."
                    ""
                    "They can be protected by a passphrase (optional) and each key in a store"
                    "is additionally protected by its own passphrase (mandatory)."
                    ""
                    "All `.pfx.*` functions may throw in case of error."
                    ""
                    "See `(?.shell '.kp)` about key pairs."]}

  nil)



(defn .pfx.alias+

  ^{:doc {:description ["Returns a set of aliases available in the given `store`."]
          :examples    [{:code (.pfx.alias+ (.pfx.create "/tmp/store.pfx"))}]
          :signature   [{:params [store]}]}}

  [store]

  (.shell.invoke '.pfx.alias+
                 store))



(defn .pfx.create

  ^{:doc {:description ["Creates a new PFX store, optionally protected by a `passphrase` (string)."
                        "Already stores it at the given `path`."
                        "Also see `.pfx.load` and `.pfx.save`."]
          :examples    [{:code (.pfx.create "/tmp/store.pfx")}
                        {:code (.pfx.create "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [path]}
                        {:params [path passphrase]}]}}

  ([path]

   (.pfx.create path
                nil))


  ([path passphrase]

   (.shell.invoke '.pfx.create
                  path
                  (or passphrase
                      ""))))



(defn .pfx.kp.get

  ^{:doc {:description ["Retrieves a key pair from the given `store` by `alias`."
                        ""
                        "Returns `nil` if the alias does not exist and throws an exception"
                        "if the passphrase does not match."
                        ""
                        "Also see `.pfx.kp.set`."]
          :examples    [{:code (.pfx.kp.get some-store "some-alias" "my-passphrase")}]
          :signature   [{:params [store alias passphrase]}]}}

  [store alias passphrase]

  (.shell.invoke '.pfx.kp.get
                 store
                 (str alias)
                 passphrase))



(defn .pfx.kp.rm

  ^{:doc {:description ["Removes a key pair from the given `store` by `alias`."
                        "Returns `store`."]
          :examples    [{:code (.pfx.kp.rm some-store "some-alias")}]
          :signature   [{:params [store alias]}]}}

  [store alias]

  (.shell.invoke '.pfx.kp.rm
                 store
                 alias))



(defn .pfx.kp.set

  ^{:doc {:description ["Adds the given `key-pair` to the given `store` under `alias`."
                        "Alias will be the public key of `key-pair` if not provided."
                        "Returns `store`."
                        "Also see `.pfx.kp.get`."]
          :examples    [{:code (.pfx.kp.set some-store (.kp.create) "my-passphrase")}
                        {:code (.pfx.kp.set some-some "some-alias" (.kp.create) "my-passphrase")}]
          :signature   [{:params [store key-pair passphrase]}
                        {:params [store alias key-pair passphrase]}]}}


  ([store key-pair passphrase]

   (.pfx.kp.set store
                (str (.kp.pubkey key-pair))
                key-pair
                passphrase))


  ([store alias key-pair passphrase]

   (.shell.invoke '.pfx.kp.set
                  store
                  (str alias)
                  key-pair
                  passphrase)))



(defn .pfx.load

  ^{:doc {:description ["Loads an existing store from the given `path`, which"
                        "may be protected by a passphrase."
                        ""
                        "Also see `.pfx.save`."]
          :examples    [{:code (.pfx.load "/tmp/store.pfx")}
                        {:code (.pfx.load "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [path]}
                        {:params [path passphrase]}]}}


  ([path]

   (.pfx.load path
              nil))


  ([path passphrase]

   (.shell.invoke '.pfx.load
                  path
                  (or passphrase
                      ""))))



(defn .pfx.save

  ^{:doc {:description ["Saves the given `store` to the file at the given `path`, optionally"
                        "protected by a `passphrase`."
                        ""
                        "Also see `.pfx.load`."]
          :examples    [{:code (.pfx.save some-store "/tmp/store.pfx")}
                        {:code (.pfx.save some-store "/tmp/store.pfx" "my-passphrase")}]
          :signature   [{:params [store path]}
                        {:params [store path passphrase]}]}}


  ([store path]

   (.pfx.save store
              path
              nil))


  ([store path passphrase]

   (.shell.invoke '.pfx.save
                  store
                  path
                  (or passphrase
                      ""))))


;;;;;;;;;; Project files


(def .project.*dir*

  ^{:doc {:description ["Path to the directory containing `project.cvx`."
                        "Also see `.project.dir.set`."]}}

  "./")



(defn .project.dir.set

  ^{:callable? true
    :doc       {:description ["Points `.project.*dir*` to another directory."]
                :examples    [{:code (.project.dir.set "some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (.fs.dir? dir)
        (fail :ARGUMENT
              "Given path is not a directory"))
      (def .project.*dir*
           dir))
    (call $CORE$
          (.project.dir.set dir))))


;;;;;;;;;; Reader


(defn .reader.form+

  ^{:doc {:description ["Returns a list of cells read from the given string."]
          :examples    [{:code (.reader.form+ ":a :b :c")}]
          :signature   [{:params [string]}]}}
  [string]

  (.shell.invoke '.reader.form+
                 string))


;;;;;;;;;; REPL


(defn .repl

  ^{:doc {:description ["Starts a Read-Eval-Print-Loop for working interactively."
                        ""
                        "By default, a prompt is printed and the user can introduce a lines of cells to evaluate."
                        "Results and exceptions are printed."
                        "By default, stops when the user enter `:q` or `:quit`."
                        "The result of the previous command is made available under `$`."
                        ""
                        "A map of options may be provided to alter the behavior of the REPL."
                        "Functions in this map takes an \"env\" map and must returns it, altered or not."
                        "The env map starts with those options. Users may want to attach additional
                         information."
                        ""
                        "Tweaking these option may lead to interesting ways of doing inter-process communication"
                        "through STDIO."
                        ""
                        "Options may be:"
                        ""
                        "  :eval"
                        "    Function for producing a result given cells attached under `:result`."
                        "    Defaults to `.repl.eval`."
                        "    If the result is a caught exception, `:exception?` can be set to `true`"
                        "    to pretty print it."
                        ""
                        "  :on.ex"
                        "    Function for acting when `:eval` throws an exception."
                        "    Exception is attached under `:result`."
                        "    Defaults to `.repl.on.ex`."
                        ""
                        "  :on.ex.reader"
                        "    Function for acting on reader errors, when an input line is not valid Convex data."
                        "    Besides the env map, also takes the message of the reader exception."
                        "    Defaults to `.repl.on.ex.reader`."
                        ""
                        "  :on.prompt"
                        "    Function for acting prior to asking for input (e.g. print a prompt)."
                        "    Defaults to `.repl.on.prompt`."
                        ""
                        "  :on.result"
                        "     Function for acting when a result is produced."
                        "     Defaults to `.repl.on.result`."
                        ""
                        "  :stop?"
                        "    Function for deciding if the REPL should stop after reading a line but before evaluating it."
                        "    Defaults to `.repl.stop?`."
                        ""
                        "  :stream.in"
                        "    Input stream for reading lines of cells."
                        "    Defaults to STDIN (returned by `.stream.stdin`)."
                        ""
                        "  :stream.out"
                        "    Output stream for printing results."
                        "    Defaults to STDOUT (returned by `.stream.stdout`)."]
          :examples    [{:code (.repl)}]
          :signature   [{:params []}
                        {:params [option+]}]}
    :shell.section ["See `(? '.repl)` for driving an interactive workflow."
                    "The REPL is started automatically when the Shell is started"
                    "without instructions."]}


  ([]

   (.repl nil))


  ([option+]

   (loop [env (merge {:eval         .repl.eval
                      :on.ex        .repl.on.ex
                      :on.ex.reader .repl.on.ex.reader
                      :on.prompt    .repl.on.prompt
                      :on.result    .repl.on.result
                      :stop?        .repl.stop?
                      :stream.in    (.stream.stdin)
                      :stream.out   (.stream.stdout)}
                     option+)]
     (let [env-2 ((:on.prompt env) env)
           [read?
            x]    (.state.safe (fn []
                                 (.stream.line (:stream.in env-2))))]
       (if read?
         ;;
         ;; Successful read.
         ;;
         (let [form+   x
               env-3 (assoc env-2
                            :form+
                            form+)]
           (cond
             ;;
             (nil? form+)
             env-3
             ;;
             (empty? form+)
             (recur env-3)
             ;;
             ((:stop? env-3) env-3)
             env-3
             ;;
             (let [[ok?
                    x]   (.state.safe (fn []
                                        ((:eval env-3) (assoc (dissoc env-3
                                                                      :exception?)
                                                              :form+
                                                              form+))))
                   env-4 (if ok?
                             (let [env-4 x]
                               ((:on.result env-4) env-4))
                             (let [ex x]
                               ((:on.ex env) (assoc env-3
                                                    :result
                                                    ex))))]
               (if (contains-key? env-4
                                  :result)
                 (recur env-4)
                 env-4))))
         ;;
         ;; Reading input failed.
         ;;
         (let [ex x]
           (if (= (:code ex)
                  :READER)
             (recur ((:on.ex.reader env) env
                                         (:message ex)))
             (.ex.rethrow ex))))))))



(defn .repl.eval

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, applies `:form+` to `eval` and attaches the result"
                        "under `:result`."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (assoc env
         :result
         (eval (concat `(let [$ (quote ~(:result env))])
               (:form+ env)))))



(defn .repl.on.ex

  ^{:doc {:description ["See `.repl`."
                        "Pretty-prints the exception found under `:result` in the REPL env."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (let [out (:stream.out env)
        ex  (:result env)]
    (.ex.print out
               ex)
    (.stream.txt.outln out
                       ""))
  env)



(defn .repl.on.ex.reader

  ^{:doc {:description ["See `.repl`."
                        "Prints the reader error that occured when the REPL was parsing input."]
          :signature   [{:params [repl-env error-message]}]}}

  [env message]

  (.stream.txt.outln (:stream.out env)
                     (str .sys.eol
                          (.term.fg.red)
                          (.term.bold)
                          "Input cannot be parsed as Convex Lisp:"
                          (.term.reset)
                          .sys.eol
                          "  "
                          message
                          .sys.eol))
  env)



(defn .repl.on.prompt

  ^{:doc {:description ["See `.repl`."
                        "Prints a simple prompt."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (let [out (:stream.out env)]
    (.stream.txt.out out
                     (str (.term.bold)
                          (.term.fg.blue)
                          "> "
                          (.term.reset)))
    (.stream.flush out))
  env)



(defn .repl.on.result

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, prints `:result` to `:stream.out`."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (if (:exception? env)
    ((:on.ex env) env)
    (let [out (:stream.out env)]
      (.stream.txt.out out
                       .sys.eol)
      (.stream.out out
                   (:result env))
      (.stream.txt.out out
                       .sys.eol)
      (.stream.txt.out out
                       .sys.eol)
      (.stream.flush out)))
  env)



(defn .repl.stop?

  ^{:doc {:description ["See `.repl`."
                        "Relative to the REPL env, returns `true` if the first cell in"
                        "`:form+` is `:q` or `:quit`."]
          :signature   [{:params [repl-env]}]}}

  [env]

  (contains-key? #{:q
                   :quit}
                 (first (:form+ env))))


;;;;;;;;;; Shell


(def .shell

  ^{:private?      true
    :shell.section ["Shell configuration, such as selectively removing some of"
                    "the extra features it offers."]}

  nil)



(defn .shell.inspect

  ^{:doc {:description ["Returns a set of symbols expressing features offered by the Shell."
                        "Those symbols often relates directly to functions and are not native"
                        "to the regular Convex Virtual Machine."
                        ""
                        "See also `.shell.limit`."]
          :examples    [{:code (.shell.inspect)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.shell.inspect))



(def .shell.invoke

  ^{:doc {:description ["Main entry point for accessing features offered by the Shell."
                        "Aka the \"invoker\"."
                        "Shell functions often delegates to it."
                        ""
                        "The regular user should never have to call this function directly."
                        "For experts only."]
          :examples    [{:code (.shell.invoke '.time.unix)}]
          :signature   [{:params [feature & arg+]}]}}

  ;; Injected from Clojure.

  ^:private?

  nil)



(defn .shell.limit

  ^{:doc {:description ["Limits the features offered by the Shell."
                        ""
                        "See `.shell.inspect` about getting the set of currently available features."
                        "This function takes a similar set and will limit `.shell.invoke` to those only."
                        ""
                        "Thus, an empty set removes all Shell features, resulting in a pure Convex Virtual Machine."
                        ""
                        "A common pattern is to call `.shell.limit` inside `.state.tmp*`, so that the Shell"
                        "is limited only temporarily."]
          :examples    [{:code (.shell.limit #{})}
                        {:code (.shell.limit (disj (.shell.inspect) '.time.unix))}]
          :signature   [{:params [feature-set]}]}}

  [feature-set]

  (.shell.invoke '.shell.limit
                 feature-set))



(defn .shell.main

  ^:private?

  [src]

  (let [[ok?
         x]  (.state.safe (fn []
                            (.reader.form+ src)))]
    (cond
      ;;
      ok?
      (let [form+ x]
        (if (empty? form+)
          (do
            (.dev.set true)
            (.stream.txt.outln
              (str (.term.fg.blue)
                   (.term.bold)
                   "Convex Shell (REPL mode)"
                   (.term.reset)
                   .sys.eol
                   "Enter transactions and build a new world."
                   .sys.eol
                   .sys.eol
                   "Powered by Protosens SRL and collaborators."
                   .sys.eol
                   "For help, type: "
                   (.term.bold)
                   "(?)"
                   (.term.reset)
                   .sys.eol))
            (.repl)
            nil)
          (eval (cons 'do
                      form+))))
      ;;
      (= (:code x)
         :READER)
      (do
        (.stream.txt.outln
           (str .sys.eol
                (.term.fg.red)
                (.term.bold)
                "Input cannot be parsed as Convex Lisp:"
                (.term.reset)
                .sys.eol
                "  "
                (:message x)
                .sys.eol))
        (.sys.exit 4))
      ;;
      (fail :SHELL.FATAL
            {:message "Initialization problem while reading input"}))))



(def .shell.*root*

  ^{:doc {:description ["Root directory used by the Shell."
                        "E.g. This is where `.dep.fetch` caches foreign dependencies."
                        ""
                        "Also see `.shell.root.set`."]}}

  "~/.convex-shell")



(defn .shell.root.set

  ^{:callable? true
    :doc       {:description ["Points `.shell.*root*` to another directory."
                              "Given path must point to an existing one."]
                :examples    [{:code (.shell.root.set "./some/dir")}]
                :signature   [{:params [dir]}]}}

  [dir]

  (if (= *address*
         $CORE$)
    (do
      (when-not (str? dir)
        (fail :ARGUMENT
              "Given path is not a string"))
      (def .shell.*root*
           dir))
    (call $CORE$
          (.shell.root.set dir))))


;;;;;;;;;; Creating and handling states


(def .state

  ^{:private?      true
    :shell.section ["Convex transactions alter the global state of the network."
                    "In Convex Lisp, the current state is available under `*state*`."
                    ""
                    "The Shell offers extra features such as `.state.switch` which allows"
                    "jumping to another state. For instance, one that has been loaded"
                    "from the Etch database (see `(?.shell '.db)`)."]}

  nil)



(defn .state.do

  ^{:doc {:description ["Like `.state.safe` but returns only a boolean, where `false` indicates"
                        "that an exception was thrown (and the state reverted)."
                        ""
                        "This is mostly used for particular situations such as benchmarking to avoid"
                        "unnecessary work done by the Shell when forwarding exceptions to the user"
                        "as in `.state.safe`."
                        ""
                        "See `.state.do*` for a convenience macro."]
          :examples    [{:code (.state.do (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.do
                 f))



(defmacro .state.do*

  ^{:doc {:description ["Executes the given code exactly like `.state.do`."
                        "More convenient to use."]
          :examples    [{:code (.state.do* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}
  [& form+]

  `(.state.do ~(concat '(fn [])
                       form+)))



(defn .state.genesis

  ^{:doc {:description ["Generates and returns a genesis state."
                        ""
                        "The genesis state is the original state used by a Convex network"
                        "to bootstrap. Such a state does not have any of the features offered"
                        "by the Shell."
                        ""
                        "Based on the provided public keys (which MUST be distinct):"
                        ""
                        "  - A special genesis user is created with 50% of available user funds,"
                        "    associated with the first public key"
                        "  - For the address of that special genesis user, see `.account.genesis`"
                        "  - For each public key, an additional user is created, sharing the remaining"
                        "    user funds equally"
                        "  - Each additional user becomes the controller of a declared peers (see the"
                        "    `:peers` key in the state)"
                        "  - Each peer uses the same public key as its controller"
                        "  - Each user stakes 1 / 3 of its balance on its peer"
                        ""
                        "Defaults to a vector with the public key of the key pair created by using"
                        "`.account.0-key` as a seed."
                        ""
                        "See `(?.shell '.kp)` about creating key pairs."]
          :examples    [{:code (.state.genesis)}
                        {:code (.state.genesis [(.kp.pubkey (.kp.create .account.0-key))])}]
          :signature   [{:params []}
                        {:params [public-key+]}]}}

  ([]

   (.state.genesis nil))


  ([public-key+]

   (.shell.invoke '.state.genesis
                  (or public-key+
                      [(.kp.pubkey (.kp.create .account.0-key))]))))



(defn .state.safe

  ^{:doc {:description ["Executes the given function in a safe, atomic way."
                        "Returns a vector of 2 elements."
                        ""
                        "First item is a boolean indicating if the function ran without throwing"
                        "an exception."
                        ""
                        "If `true`, second item is the returned result."
                        "If `false`, second item is the thrown exception and `*state*` is reverted."
                        ""
                        "Usually, prefer the `.state.safe*` macro for convenience."]
          :examples    [{:code (.state.safe (fn [] (assert false)))}]
          :signature   [{:params [f]}]}}
  [f]

  (.shell.invoke '.state.safe
                 f))



(defmacro .state.safe*

  ^{:doc {:description ["Executes the given code exactly like `.state.safe`."
                        "More convenient to use."]
          :examples    [{:code (.state.safe* (def x []) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.safe (fn []
                          ~(cons 'do
                                 form+))))
 


(defn .state.switch

  ^{:doc {:description ["Switches `*state*` to the given one."
                        "For instance, a state produced with `.state.genesis` or a state"
                        "retrieved from Etch."
                        ""
                        "Provided address must point to an account in the target state."
                        "By default, current `*address*` is used."
                        ""
                        "Attention, beware of consequences."
                        "E.g. Switching in a middle of an actor call who was working under"
                        "     assumptions relating to the old `*state*`."]
          :examples    [{:code (.state.switch (.state.genesis))}]
          :signature   [{:params [state]}]}}


  ([state]

   (.state.switch nil
                  state))


  ([address state]

   (.shell.invoke '.state.switch
                  (or address
                      *address*)
                  state)))



(defn .state.tmp

  ^{:doc {:description ["Exactly like `.state.safe` but the state is always reverted."
                        "Even if an exception is not thrown."
                        ""
                        "Also see the `.state.tmp*` macro for convenience."]
          :examples    [{:code (.state.tmp (fn [] (def x 42) (inc x)))}]
          :signature   [{:params [f]}]}}

  [f]

  (.shell.invoke '.state.tmp
                 f))



(defmacro .state.tmp*

  ^{:doc {:description ["Convenience macro over `.state.tmp`."
                        "Wraps given code into a function."]
          :examples    [{:code (state.tmp* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}

  [& form+]

  `(~$CORE$/.state.tmp (fn []
                         ~(cons 'do
                                form+))))


;;;;;;;;;; Strings


(def .str

  ^{:private?      true
    :shell.section ["Extra string-related utilities not found natively in Convex."]}

  nil)



(defn .str.count

  ^:private?

  [s]

  (let [n-byte (count s)]
    (loop [i      0
           n-char 0]
      (if (< i
             n-byte)
        (recur (inc i)
               (if (nil? (nth s
                              i))
                 n-char
                 (inc n-char)))
        n-char))))

        

(defn .str.pluralize

  ^:private?

  [n s]

  (if (> n
         1)
    (str s
         "s")
    s))



(defn .str.sort

  ^:private?

  [str+]

  (.shell.invoke '.str.sort
                 str+))



(defn .str.stream.in

  ^{:doc {:description ["Wraps the given string in an input stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."]
          :examples    [{:code (.str.stream.in ":a :b :c")}]
          :signature   [{:params [string]}]}}

  [string]

  (.shell.invoke '.str.stream.in
                 string))



(defn .str.stream.out

  ^{:doc {:description ["Wraps the given string in an output stream."
                        "The returned handle can be used with stream utilities."
                        "See `(?.shell '.stream)`."
                        ""
                        "Note that `.stream.close` has no effect."
                        ""
                        "See `.str.stream.unwrap` for unwrapping the string inside."]
          :examples    [{:code (.str.stream.out)}]
          :signature   [{:params [string]}]}}

  []

  (.shell.invoke '.str.stream.out))



(defn .str.stream.unwrap

  ^{:doc {:description ["Returns the string wrapped inside the given string output stream."
                        "See `.str.stream.out`."]
          :examples    [{:code (.str.stream.unwrap (.str.stream.out))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.str.stream.unwrap
                 handle))


;;;;;;;;;; Streams


(def .stream

  ^{:private?      true
    :shell.section ["Streams are an abstraction for reading and writing text"
                    "or Convex data."
                    ""
                    "For instance, see the following ways for creating streams"
                    "which can then be used with the various stream utilities:"
                    ""
                    "  .file.stream.in"
                    "  .file.stream.out"
                    "  .str.stream.in"
                    "  .str.stream.out"]}

  nil)



(defn .stream.stderr

  ^{:doc {:description ["Returns the handle for the STDERR stream."]
          :examples    [{:code (.stream.stderr)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stderr))



(defn .stream.stdin

  ^{:doc {:description ["Returns the handle for the STDIN stream."]
          :examples    [{:code (.stream.stdin)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stdin))



(defn .stream.stdout

  ^{:doc {:description ["Returns the handle for the STDOUT stream."]
          :examples    [{:code (.stream.stdout)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.stream.stdout))


;;;


(defn .stream.close

  ^{:doc {:description ["Closes the given stream."
                        "Returns `nil`."]
          :examples    [{:code (.stream.close (.str.stream.in ":test"))}]
          :signature   [{:params [handle]}]}}

  [handle]

  (.shell.invoke '.stream.close
                 handle))



(defn .stream.err

  ^{:doc {:description ["Like `.stream.out` but prints the given value to the STDERR (returned"
                        "by `.stream.stderr`)."]
          :examples    [{:code (.stream.err {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.out (.stream.stderr)
               x))



(defn .stream.errln

  ^{:doc {:description ["Like `.stream.outln` but prints the given value to STDERR (returned"
                        "by `.stream.stderr`)."]
          :examples    [{:code (.stream.errln {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.outln (.stream.stderr)
                 x))



(defn .stream.flush

  ^{:doc {:description ["Flushes the given output stream, ensuring all current content is printed."
                        "Defaults to STDOUT (returned by `.stream.stdout`)."
                        "Returns the stream handle."]
          :examples    [{:code (.stream.flush)}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.flush (.stream.stdout)))


  ([handle]

   (.shell.invoke '.stream.flush
                  handle)))



(defn .stream.in+

  ^{:doc {:description ["Reads as cells all content available from the given stream."
                        "Returns a list."
                        "Closes the stream automatically."
                        ""
                        "Reads from STDIN by default (returned by `.stream.stdin`)."]
          :examples    [{:code (.stream.in+ (.str.stream.in ":a :b :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.in+ (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.in+
                  handle)))



(defn .stream.line

  ^{:doc {:description ["Reads a single lines of cells from the given stream."
                        "Returns a list or `nil` if the stream is empty."
                        ""
                        "Once empty, the next read will throw an exception."
                        ""
                        "Reads from STDIN by default (returned by `.stream.stdin`)"]
          :examples    [{:code (.stream.line (.str.stream.in ":a :b \n :c"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.line (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.line
                  handle)))



(defn .stream.out

  ^{:doc {:description ["Writes the value as a cell to the given output stream."
                        "Prints in such a way that those cells can be read back."
                        ""
                        "Defaults to STDOUT (returned by `.stream.stdout`)."]
          :examples    [{:code (.stream.out :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.out (.stream.stdout)
                x))


  ([handle x]

   (.shell.invoke '.stream.out
                  handle
                  x)))



(defn .stream.outln

  ^{:doc {:description "Exactly like `.stream.out` but also prints a new line and flushes the stream."
          :examples    [{:code (.stream.outln :test)}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.outln (.stream.stdout)
                  x))


  ([handle x]
   
   (.shell.invoke '.stream.outln
                  handle
                  x)))



(defn .stream.set.err

  ^{:callable? true
    :doc       {:description "Sets `.stream.*err*` to the given stream."
                :examples    [{:code (.stream.set.err (.str.stream.out))}]
                :signature   [{:params [handle]}]}}

  [handle]

  (if (= *address*
         $CORE$)
    (def .stream.*err*
         handle)
    (call $CORE$
          (.stream.set.err handle))))



(defn .stream.txt.err

  ^{:doc {:description ["Like `.stream.txt.out` but prints to STDERR (returned by `.stream.stderr`)."]
          :examples    [{:code (.stream.err {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.out (.stream.stderr)
                   x))



(defn .stream.txt.errln

  ^{:doc {:description ["Like `.stream.txt.outln but prints to STDERR (returned by `.stream.stderr`)."]
          :examples    [{:code (.stream.errln {:some :error})}]
          :signature   [{:params [x]}]}}

  [x]

  (.stream.txt.outln (stream.stderr)
                     x))



(defn .stream.txt.in

  ^{:doc {:description ["Reads the full content of the given input stream as a string."
                        "Defaults to STDIN (returned by `.stream.stdin`)."
                        "Stream is closed automatically."]
          :examples    [{:code (.stream.txt.in (.str.stream.in "test"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.in (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.txt.in
                  handle)))



(defn .stream.txt.line

  ^{:doc {:description ["Reads a single line from the given input stream as a string."
                        "Defaults to STDIN (returned by `.stream.stdin`)."
                        ""
                        "Like `.stream.in`, returns `nil` when the end of the stream is reached."
                        "Any subsequent read will then throw an exception."]
          :examples    [{:code (.stream.txt.line (.str.stream.in "foo\nbar"))}]
          :signature   [{:params []}
                        {:params [handle]}]}}


  ([]

   (.stream.txt.line (.stream.stdin)))


  ([handle]

   (.shell.invoke '.stream.txt.line
                  handle)))



(defn .stream.txt.out

  ^{:doc {:description ["Like `.stream.out` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.out "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.out (.stream.stdout)
                    x))


  ([handle x]

   (.shell.invoke '.stream.txt.out
                  handle
                  x)))



(defn .stream.txt.outln

  ^{:doc {:description ["Like `.stream.outln` but strings are not double-quoted."
                        "Hence, the output might not be readable as Convex data."]
          :examples    [{:code (.stream.txt.outln "Some text")}]
          :signature   [{:params [x]}
                        {:params [handle x]}]}}


  ([x]

   (.stream.txt.outln (.stream.stdout)
                      x))


  ([handle x]

   (.shell.invoke '.stream.txt.outln
                  handle
                  x)))


;;;;;;;;;; System utilities


(def .sys

  ^{:private?      true
    :shell.section ["Basic system utilities."]}

  nil)



(defn .sys.arch

  ^{:doc {:description ["Returns the machine architecture as a string."]
          :examples    [{:code (.sys.arch)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.arch))



(defn .sys.cwd

  ^{:doc {:description ["Returns the current working directory."
                        "In other words, the directory the Shall was started in."
                        "Will not change throught the course of a process."]
          :examples    [{:code (.sys.cwd)}]
          :signature   [{:params []}]}}
  []

  (.shell.invoke '.sys.cwd))



(defn .sys.env

  ^{:doc {:description ["Returns a map of process environment variables."
                        "Also see `.sys.env.var`."]
          :examples    [{:code (.sys.env)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.env))



(defn .sys.env.var

  ^{:doc {:description ["Returns the value for a single process environment variable."
                        "Also see `.sys.env.var."]
          :examples    [{:code (.sys.env.var "SOME_VAR")}]
          :signature   [{:params [var]}]}}
  [var]

  (.shell.invoke '.sys.env.var
                 var))



(def .sys.eol

  ^{:doc {:description "Platform-dependent new line."}}

  .sys.eol)



(defn .sys.exit

  ^{:doc {:description ["Exists the Shell process with the given exit code."
                        "Exit code must be 0 or >= 128 and <= 255."
                        "Values below 128 are reserved for the Shell itself."]
          :examples    [{:code (.sys.exit 128)}]
          :signature   [{:params [code]}]}}

  [code]

  (.shell.invoke '.sys.exit
                 code))



(defn .sys.home

  ^{:doc {:description ["Returns the user's home directory."]
          :examples    [{:code (.sys.home)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.home))



(defn .sys.os

  ^{:doc {:description ["Returns a vector where the first element is the operating"
                        "system and the second is the version."]
          :examples    [{:code (.sys.os)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.sys.os))


;;;;;;;;;; Unit testing


(def .t

  ^{:private?      true
    :shell.section ["Unit testing framework."
                    ""
                    "Tests are functions defined with `.t.def` which should"
                    "contain assertions written with `.t.is`."
                    ""
                    "See `.dep.test` about how to run them."]}

  nil)



(def .t.*assert+*

  ^:private?

  [])



(defn .t.assert.add

  ^:callable?
  ^:private?

  [assertion]

  (if (= *address*
         ~*address*)
    (def .t.*assert+*
         (conj .t.*assert+*
               assertion))
    (call ~*address*
          (.t.assert.add assertion))))



(defn .t.assert.failed+

  ^:private?

  [assertion+]

  (reduce (fn [acc assertion]
            (let [[ok?
                   x]         (:result assertion)
                  assertion-2 (if ok?
                                (if (syntax? x)
                                  (if-let [status (:test.status (meta x))]
                                    {:fail   (unsyntax x)
                                     :status status}
                                    {:fail   x
                                     :status :fail})
                                  (when-not (= x
                                               true)
                                    {:fail   x
                                     :status :fail}))
                                {:fail   x
                                 :status :exception})]
              (if assertion-2
                (conj acc
                      (assoc assertion-2
                             :form    (:form assertion)
                             :message (:message assertion)))
                acc)))
          []
          assertion+))



(defmacro .t.ex

  ^{:doc {:description ["Used as a form for `.t.is` for testing if an exception was thrown."
                        "Exception code is optional. Without it, the assertion will pass for"
                        "any exception."
                        ""
                        "A good test suite not only proves that things succeed but also that they"
                        "fail when they should."]
          :examples    [{:code (.t.is (.t.ex (assert false)))}
                        {:code (.t.is (.t.ex :ASSERT (assert false)))}]
          :signature   [{:params [form]}
                        {:params [ex-code form]}]}}

  ([form]

   `(.t.ex nil
           ~form))


  ([ex-code form]

   `(let [ex-code ~ex-code
          [ok?
           x]    (.state.safe* ~form)]
      (if ok?
        (syntax x
                {:test.status :fail})
        (if (nil? ex-code)
          true
          (or (= ex-code
                 (:code x))
              (syntax x
                      {:test.status :exception})))))))



(defmacro .t.def

  ^{:doc {:description ["Defines a function that can run as a test."
                        ""
                        "Just like when defining a regular function, metadata can be attached."
                        "This metadata may be useful for focusing on the test or skipping it when"
                        "running tests with `.dep.test`."]
          :examples    [{:code (.t.def some-test ^:slow? (.t.is (< 1 2)))}]
          :signature   [{:params [name & assertion+]}]}}

  [name & assertion+]

  (let [[name-2
         meta-]      (if (syntax? name)
                       [(unsyntax name)
                        (meta name)]
                       [name
                        nil])
        first-assert (when-not (empty? assertion+)
                       (first assertion+))
        meta-2       (if (syntax? first-assert)
                       (merge meta-
                              (meta first-assert))
                       meta-)]
    `(defn ~(syntax name-2
                    (assoc meta-2
                           :test?
                           true))

       []

       ~(cons 'do
               assertion+))))



(defn .t.dev

  ^:private?

  ([required]

   (.t.dev required
           nil))


  ([required state]

   (= (:status (.t.run required
                       state))
      :pass)))



(defn .t.find

  ^:private?

  [state actor-sym actor-address]

  (let [account    (account actor-address)
        meta       (:metadata account)
        env        (:environment account)
        focus.test (get-in state
                           [:focus.test
                             actor-sym])
        skip.test  (get-in state
                           [:skip.test
                            actor-sym])]
    (reduce (fn [acc [sym x]]
              (let [sym-meta (get meta
                                  sym)]
                (if (and (fn? x)
                         (get-in meta
                                 [sym
                                  :test?])
                         (or (not focus.test)
                             (contains-key? focus.test
                                            sym))
                         (or (not skip.test)
                             (not (contains-key? skip.test
                                                 sym)))
                         (reduce (fn [_focus? k-focus]
                                   (if (get sym-meta
                                            k-focus)
                                     (reduced true)
                                     false))
                                 true
                                 (get state
                                      :focus.meta))
                         (reduce (fn [_skip? k-skip]
                                   (if (get sym-meta
                                            k-skip)
                                     (reduced false)
                                     true))
                                 true
                                 (get state
                                      :skip.meta)))
                  (conj acc
                        [sym
                         x])
                  acc)))
            []
            env)))



(defmacro .t.is

  ^{:doc {:description ["Creates a test assertion."
                        "Meant to be used in tests defined with `.t.def`."
                        ""
                        "In order for a test assertion to pass, `form` must return `true`."
                        "An optional message can be provided, making it easier to locate the"
                        "assertion in the test report in case of failure."]
          :examples    [{:code (.t.is (= a b) "A and B must be equal")}]
          :signature   [{:params [form]}
                        {:params [form message]}]}}


  ([form]

   `(.t.is ~form
           nil))


  ([form message]

   `(.t.assert.add {:form    (quote ~form)
                    :message ~message
                    :result  (.state.safe* ~form)})))



(defn .t.main

  ^:private?


  ([required]

   (.t.main required
            nil))


  ([required state]

   (.sys.exit (if (.t.dev required
                          state)
                0
                128))))



(defn .t.on.run.begin

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (str .sys.eol
                          "=========="
                          .sys.eol
                          .sys.eol
                          (.term.bold)
                          "["
                          (.term.reset)))
    (.stream.flush s))
  state)



(defn .t.on.run.end

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       (str (.term.bold)
                            "]"
                            (.term.reset)
                            .sys.eol
                            .sys.eol
                            "=========="
                            .sys.eol))
    (.docoll (fn [test]
               (if-let [f (get {:empty     .t.on.test.empty
                                :exception .t.on.test.ex
                                :fail      .t.on.test.fail}
                               (:status test))]
                 (f state
                    test)
                 nil))
             (:run state))
    (let [status (:status state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (cond
                                (= status
                                   :empty)
                                (str (.term.fg.red)
                                     "NO TESTS FOUND")
                                ;;
                                (= status
                                   :fail)
                                (str (.term.fg.red)
                                     "FAIL")
                                ;;
                                (= status
                                   :pass)
                                (str (.term.fg.green)
                                     "OK"))
                              (.term.bold)
                              .sys.eol)))
    (let [empty-actor+ (:empty-actor+ state)
          n-actor      (:n-actor state)
          n-test       (:n-test state)
          n-test-fail  (:n-test-fail state)]
      (.stream.txt.outln s
                         (str (.term.bold)
                              (.term.fg.cyan)
                              n-test
                              " test"
                              (if (> n-test
                                     1)
                                "s"
                                "")
                              (.term.reset)
                              " run over "
                              (.term.bold)
                              (.term.fg.cyan)
                              n-actor
                              " actor"
                              (if (> n-actor
                                     1)
                                "s"
                               "")
                              (.term.reset)
                              ", "
                              (.term.bold)
                              (if (zero? n-test-fail)
                                (.term.fg.green)
                                (.term.fg.red))
                              n-test-fail
                              " failed"
                              (.term.reset)))
      (when-not (empty? empty-actor+)
        (.stream.txt.outln s
                           (str .sys.eol
                                .sys.eol
                                (.term.bold)
                                (.term.fg.red)
                                "Actors without tests:"
                                (.term.reset)
                                .sys.eol))
        (.docoll (fn [sym-actor]
                   (.stream.txt.outln s
                                      (str "  "
                                           sym-actor)))
                 empty-actor+))))
  state)



(defn .t.on.test.empty

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (.stream.txt.outln (:stream.out state)
                     "No assertions.")
  (.t.print.test.separator state))



(defn .t.on.test.ex

  ^:private?

  [state test]

  (.t.print.test.name state
                      test)
  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "Exception thrown unexpectedly")
    (.ex.print s
               (:exception test)))
  (.t.print.test.separator state))



(defn .t.on.test.fail

  ^:private?

  [state test]

  (let [s (:stream.out state)]
    (.docoll (fn [failed]
               (.t.print.test.name state
                                   test)
               (when-let [message (:message failed)]
                 (.stream.txt.outln s
                                    (str message
                                         .sys.eol)))
               (.stream.txt.outln s
                                  (str (.term.bold)
                                       (.term.fg.cyan)
                                       "Form:   "
                                       (.term.reset)
                                       (:form failed)))
               (let [status (:status failed)]
                 (when-not (= status
                              :pass)
                   (cond
                     ;;
                     (= status
                        :fail)
                     (.stream.txt.outln s
                                        (str .sys.eol
                                             (.term.bold)
                                             (.term.fg.cyan)
                                             "Result: "
                                             (.term.reset)
                                             (:fail failed)))
                     ;;
                     (= status
                        :exception)
                     (.ex.print s
                                (:fail failed)))
                   (.t.print.test.separator state))))
             (:failed+ test))))



(defn .t.on.test.result

  ;; Ultimately meant to be public for custom test reporting.

  ^:private?

  [state result]

  (let [s (:stream.out state)]
    (.stream.txt.out s
                     (if (= (:status result)
                            :pass)
                       (str (.term.bold)
                            (.term.fg.green)
                            "."
                            (.term.reset))
                       (str (.term.bold)
                            (.term.fg.red)
                            "X"
                            (.term.reset))))
    (.stream.flush s))
  state)



(defn .t.print.test.name

  ^:private?

  [state test]

  (.stream.txt.outln (:stream.out state)
                     (str (.term.bold)
                          (:name test)
                          (.term.reset)
                          .sys.eol))
  nil)



(defn .t.print.test.separator

  ^:private?

  [state]

  (let [s (:stream.out state)]
    (.stream.txt.outln s
                       "")
    (.stream.txt.outln s
                       "-----")
    (.stream.txt.outln s
                       ""))
  nil)



(defn .t.run

  ^:private?

  [actor-sym->addr state]

  (let [[ok?
         x]
        (.state.tmp
          (fn []
            (let [state          (merge {:on.run.begin   .t.on.run.begin
                                         :on.run.end     .t.on.run.end
                                         :on.test.result .t.on.test.result
                                         :stream.out     (.stream.stdout)}
                                        state)
                  on.run.begin   (:on.run.begin state)
                  on.run.end     (:on.run.end state)
                  state          (if on.run.begin
                                   (on.run.begin state)
                                   state)
                  state-2        (reduce (fn [state-2 actor-sym]
                                           (.t.run.actor state-2
                                                         actor-sym
                                                         (get actor-sym->addr
                                                              actor-sym)))
                                         (assoc state
                                                :empty-actor+ []
                                                :n-actor      0
                                                :n-test       0
                                                :n-test-fail  0)
                                         (:order state))
                 state-3         (.t.run.finalize state-2)]
             (if on.run.end
               (on.run.end state-3)
               state-3))))]
    (if ok?
      x
      (.ex.rethrow x))))



(defn .t.run.actor

  ^:private?

  [state actor-sym actor-address]

  (let [found (.t.find state
                       actor-sym
                       actor-address)]
    (if (empty? found)
      (assoc state
             :empty-actor+
             (conj (:empty-actor+ state)
                   actor-sym))
      (reduce (fn [state-2 [test-sym test-f]]
                (.t.run.test state-2
                             actor-sym
                             actor-address
                             test-sym
                             test-f))
              (assoc state
                     :n-actor
                     (inc (:n-actor state)))
              found))))



(defn .t.run.finalize

  ^:private?

  [state]

  (assoc state
         :status
         (cond
           ;;
           (zero? (:n-test state))
           :empty
           ;;
           (zero? (:n-test-fail state))
           :pass
           ;;
           :else
           :fail)))



(defn .t.run.test

  ^:private?

  [state actor-sym actor-address test-sym test-f]

  (let [on.test.result (:on.test.result state)
        [ok?
         x]            (.state.tmp (fn []
                                     (.account.switch actor-address)
                                     (test-f)
                                     .t.*assert+*))
        test-result    (if ok?
                         (.t.run.test.finalize x)
                         (let [trace (:trace x)]
                           {:exception (assoc x
                                              :trace
                                              ;; Removing lines relating to calling the test.
                                              (slice trace
                                                     0
                                                     (max 0
                                                          (- (count trace)
                                                             2))))
                            :status    :exception}))
        test-result-2  (assoc test-result
                              :name
                              (str actor-sym
                                   "/"
                                   test-sym))
        state-2        (assoc state
                              :run
                              (conj (:run state)
                                    test-result-2))
        state-3        (assoc state-2
                              :n-test
                              (inc (:n-test state-2)))
        state-4        (if on.test.result
                         (on.test.result state-3
                                         test-result-2)
                         state-3)]
    (if (= (:status test-result-2)
           :pass)
      state-4
      (assoc state-4
             :n-test-fail
             (inc (:n-test-fail state-4))))))



(defn .t.run.test.finalize

  ^:private?

  [assertion+]

  (let [n (count assertion+)]
    (if (zero? n)
      {:status :empty}
      (let [failed+ (.t.assert.failed+ assertion+)
            result  {:n n}]
        (if (empty? failed+)
          (assoc result
                 :status
                 :pass)
          (assoc result
                 :failed+ failed+
                 :status  :fail))))))


;;;;;;;;;; Basic ANSI terminal commands


(def .term

  ^{:private?      true
    :shell.section ["Simples utilities for producing terminal ANSI escape codes, such as"
                    "for coloring strings."
                    ""
                    "Some environments, such as some Windows terminals, or some use cases,"
                    "such as writing files, requires disabling these."
                    "See `.term.style.enable?` which will work for all color-related functions."]}

  nil)



(def .term.*style?*

  ^{:doc {:description ["Boolean indicating if text styling functions like `.term.fg.red` can use ANSI escape codes."
                        "If set to `false`, those functions will return empty strings."
                        "See `.term.style.enable?`."]}}

  true)



(defn .term.style

  ^:private?

  [x]

  (if .term.*style?*
    x
    ""))



(defn .term.style.enable?

  ^{:callable? true
    :doc       {:description ["Sets the value of `.term.*style?*`."
                              "Disabling colors is useful when working in a terminal that does not support ANSI"
                              "escape codes or when printing to files."
                              "See `.term.style.enable?`."]
                :examples    [{:code (.term.style.enable? false)}]
                :signature   [{:params [enable?]}]}}

  [enable?]

  (if (= *address*
         ~*address*)
    (def .term.*style?*
         (boolean enable?))
    (call ~*address*
          (.term.style.enable? enable?))))


;; ANSI background colors


(defn .term.bg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (background)."]
          :examples    [{:code (.term.bg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[40m"))



(defn .term.bg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (background)."]
          :examples    [{:code (.term.bg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[44m"))



(defn .term.bg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (background)."]
          :examples    [{:code (.term.bg.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[46m"))



(defn .term.bg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (background)."]
          :examples    [{:code (.term.bg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[42m"))



(defn .term.bg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (background)."]
          :examples    [{:code (.term.bg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[45m"))


(defn .term.bg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (background)."]
          :examples    [{:code (.term.bg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[41m"))



(defn .term.bg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (background)."]
          :examples    [{:code (.term.bg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[47m"))



(defn .term.bg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in (background)."]
          :examples    [{:code (.term.bg.)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[43m"))


;;


(defn .term.bg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (background)."]
          :examples    [{:code (.term.bg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}

  [r g b]

  (if .term.*style?*
    (str "\033[48;2;" r ";" g ";" b "m")
    ""))


;; ANSI foreground colors


(defn .term.fg.black

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in black (foreground)."]
          :examples    [{:code (.term.fg.black)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[30m"))



(defn .term.fg.blue

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in blue (foreground)."]
          :examples    [{:code (.term.fg.blue)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[34m"))



(defn .term.fg.cyan

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in cyan (foreground)."]
          :examples    [{:code (.term.cyan)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[36m"))



(defn .term.fg.green

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in green (foreground)."]
          :examples    [{:code (.term.fg.green)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[32m"))



(defn .term.fg.magenta

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in magenta (foreground)."]
          :examples    [{:code (.term.fg.magenta)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[35m"))



(defn .term.fg.white

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in white (foreground)."]
          :examples    [{:code (.term.fg.white)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[37m"))



(defn .term.fg.red

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in red (foreground)."]
          :examples    [{:code (.term.fg.red)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[31m"))



(defn .term.fg.yellow

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in yellow (foreground)."]
          :examples    [{:code (.term.fg.yellow)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[33m"))


;;


(defn .term.fg.rgb

  ^{:doc {:description ["Returns the ANSI escape code for coloring text in RGB (foreground)."]
          :examples    [{:code (.term.fg.rgb 156 120 201)}]
          :signature   [{:params [r g b]}]}}


  [r g b]

  (if .term.*style?*
    (str "\033[38;2;" r ";" g ";" b "m")
    ""))


;; Terminal effects


(defn .term.bold

  ^{:doc {:description ["Returns the ANSI escape code for bold text."]
          :examples    [{:code (.term.bold)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[1m"))



(defn .term.reset

  ^{:doc {:description ["Returns the ANSI escape code for resetting all colors and effects."]
          :examples    [{:code (.term.reset)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[0m"))



(defn .term.reversed

  ^{:doc {:description ["Returns the ANSI escape code for reversing background and"
                        "foreground colors."]
          :examples    [{:code (.term.reversed)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[7m"))



(defn .term.underline

  ^{:doc {:description ["Returns the ANSI escape code for underlining text."]
          :examples    [{:code (.term.underline)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[4m"))


;;;;;;;;;; Moving


(defn .term.col

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to column `n`."]
          :examples    [{:code (.term.col 42)}]
          :signature   [{:params [n]}]}}

  [n]

  (str "\033[" n "G"))



(def .term.cursor.save

  ^{:doc {:description ["ANSI code for saving current cursor position."
                        "See `cursor.restore`."]}}

  "\033[s")



(def .term.cursor.restore

  ^{:doc {:description ["ANSI escape code for restoring last saved cursor position."
                        "See `cursor.save`."]}}

  "\033[u")



(defn .term.down

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code (.term.down 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down 1))


  ([n]

   (str "\033[" n "B")))



(defn .term.down.begin

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor to the beginning"
                        "of the line and then `n` lines down."
                        "Defaults to one line."]
          :examples    [{:code ($.term.down.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.down.begin 1))


  ([n]

   (str "\033[" n "E")))



(defn .term.left

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns left."
                        "Defaults to one column."]
          :examples    [{:code (.term.left 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.left 1))


  ([n]

   (str "\033[" n "D")))



(defn .term.right

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` columns right."
                        "Defaults to one column."]
          :examples    [{:code (.term.right 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.right 1))


  ([n]

   (str "\033[" n "C")))



(defn .term.up

  ^{:doc {:description ["Returns the ANSI escape code for moving the cursor `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up 1))


  ([n]

   (str "\033[" n "A")))



(defn .term.up.begin

  ^{:doc {:description ["Returns the ANSI escapecode for moving the cursor to the beginning of the line"
                        "and then `n` lines up."
                        "Defaults to one line."]
          :examples    [{:code (.term.up.begin 4)}]
          :signature   [{:params []}
                        {:params [n]}]}}


  ([]

   (.term.up.begin 1))


  ([n]

   (str "\033[" n "F")))


;; Screen clearing


(defn .term.clear

  ^{:doc {:description "Returns the ANSI code for clearing the whole screen."
          :examples    [{:code (.term.clear)}]
          :signature   [{:params []}]}}

  []

  (.term.style "\033[H\033[2J"))


;;


(defn .term.demo

  ^{:doc {:description ["Prints a string to STDOUT producing colored output as demo"
                        "of the different `.term...` functions."]
          :examples    [{:code ($.term/demo)}]
          :signature   [{:params []}]}}
  []

  (.stream.txt.outln
    (str .sys.eol
         (.term.bg.black)
         "BG black"
         (.term.reset)
         .sys.eol
         (.term.bg.blue)
         "BG blue"
         (.term.reset)
         .sys.eol
         (.term.bg.cyan)
         "BG cyan"
         (.term.reset)
         .sys.eol
         (.term.bg.green)
         "BG green"
         (.term.reset)
         .sys.eol
         (.term.bg.magenta)
         "BG magenta"
         (.term.reset)
         .sys.eol
         (.term.bg.red)
         "BG red"
         (.term.reset)
         .sys.eol
         (.term.bg.white)
         (.term.fg.black)
         "BG white"
         (.term.reset)
         .sys.eol
         (.term.bg.yellow)
         "BG yellow"
         (.term.reset)
         .sys.eol
         (.term.bg.rgb 100 200 150)
         "BG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.fg.black)
         "FG black"
         (.term.reset)
         .sys.eol
         (.term.fg.blue)
         "FG blue"
         (.term.reset)
         .sys.eol
         (.term.fg.cyan)
         "FG cyan"
         (.term.reset)
         .sys.eol
         (.term.fg.green)
         "FG green"
         (.term.reset)
         .sys.eol
         (.term.fg.magenta)
         "FG magenta"
         (.term.reset)
         .sys.eol
         (.term.fg.red)
         "FG red"
         (.term.reset)
         .sys.eol
         (.term.fg.white)
         (.term.fg.black)
         "FG white"
         (.term.reset)
         .sys.eol
         (.term.fg.yellow)
         "FG yellow"
         (.term.reset)
         .sys.eol
         (.term.fg.rgb 100 200 150)
         "FG RGB 100 200 150"
         (.term.reset)
         .sys.eol
         (.term.bold)
         "Bold text"
         .sys.eol
         (.term.fg.blue)
         "Bold makes also colors brighter"
         (.term.reset)))
  nil)


;;;;;;;;;;


(defn .testnet.create-account

  ^{:doc {:description ["Creates a new account on `convex.world` for the given public key."
                        "Returns the address of that new account."]
          :examples    [{:code (.testnet.create-account (.kp.pubkey (.kp.create)))}]
          :signature   [{:params [public-key]}]}}

  [public-key]

  (.shell.invoke '.testnet.create-account
                 public-key))



(defn .testnet.faucet

  ^{:doc {:description ["Requests Convex Coppers for an account on `convex.world`."
                        "Amount must be >= 0 and <= 100,000,000."]
          :examples    [{:code (.testnet.faucet #42 1000000)}]
          :signature   [{:params [address amount]}]}}

  [address amount]

  (.shell.invoke '.testnet.faucet
                 address
                 amount))


;;;;;;;;;; Time utilities


(def .time

  ^{:private?      true
    :shell.section ["Times related utilities."
                    ""
                    "Note that the Convex Virtual Machine keeps its own time available"
                    "under `*timestamp*` which represents the network time. In the Shell,"
                    "this timestamp can only move forwards via `.time.advance`."
                    ""
                    "Other utilities, such as `.time.unix`, refer to the actual clock"
                    "time of the machine the Shell is running on."]}

  nil)



(defn .time.advance

  ^{:doc {:description ["Advances `*timestamp*`, the timestamp of the Convex Virtual Machine."
                        "Unless calling this function, this timestamp never changes."
                        "Canot go back in time."
                        ""
                        "Useful for triggering transactions that have been scheduled at a"
                        "future time with `schedule`."]
          :examples    [{:code (.time.advance 1000)}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.advance
                 millis))



(defmacro .time.do*

  ^{:doc {:description ["Macro for timing code execution."
                        ""
                        "Returns a vector where:"
                        "  0: Elapsed time in nanoseconds"
                        "  1: Result from executing forms"
                        ""
                        "Uses `.time.nano`."
                        "Might not be accurate enough for tiny operations."]
          :examples    [{:code (.time.do* (def x 42) (inc x))}]
          :signature   [{:params [& form+]}]}}
  [& form+]

  (let [n-form     (count form+)
        sym-result (.gensym)
        sym-time   (.gensym)]
    `(let [~sym-time   (.time.nano)
           ~sym-result ~(cond
                          ;;
                          (= n-form
                             0)
                          nil
                          ;;
                          (= n-form
                             1)
                          (first form+)
                          ;;
                          (cons 'do
                                form+))]
       [(- (.time.nano)
            ~sym-time)
        ~sym-result])))



(defn .time.iso

  ^{:doc {:description ["Returns the current time as an ISO 8601 UTC string."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.iso)}]
          :signature   [{:params []}]}}
  []

  (.time.unix->iso (.time.unix)))



(defn .time.iso->unix

  ^{:doc {:description ["Converts time as an ISO 8601 UTC string into a Unix timestamp."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.iso->unix "2022-09-14T11:43:34.633")}]
          :signature   [{:params [iso-string]}]}}

  [iso-string]

  (.shell.invoke '.time.iso->unix
                 iso-string))



(defn .time.nano

  ^{:doc {:description ["Returns the current value of a high-resolution timer in nanoseconds."
                        ""
                        "Guarantees:"
                        ""
                        "  - Timer is monotonic if the OS supports it"
                        "  - Resolution is at least as good as that of `.time.unix`"
                        ""
                        "Useful for timing things as usually more accurate than `.time.unix`."
                        ""
                        "This timer has no particular, predictable origin. Hence the first value is meaningless."
                        "However, the difference between 2 values from the same process offers a precise interval."
                        "It follows that values from different processes are not comparable."
                        ""
                        "See `.time.do*` for a convenience macro."]
          :examples    [{:code (.time.nano)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.nano))



(defn .time.sleep

  ^{:doc {:description ["Blocks execution for the given interval in milliseconds."
                        "subject to the precision and accuracy of system timers and scheduler."]
          :examples    [{:code (.time.sleep 1000)}]
          :signature   [{:params [millis]}]}}

  [millis]

  (.shell.invoke '.time.sleep
                 millis))



(defn .time.unix

  ^{:doc {:description ["Returns the current Unix time as a Long."
                        "This refers to clock time, the actual time of the machine the Shell"
                        "is running on, not `*timestamp*`."]
          :examples    [{:code (.time.unix)}]
          :signature   [{:params []}]}}

  []

  (.shell.invoke '.time.unix))



(defn .time.unix->iso

  ^{:doc {:description ["Converts a Unix timestamp to an ISO 8601 UTC string."
                        "Also see `.time.iso`, `.time.unix`."]
          :examples    [{:code (.time.unix->iso 1663155814633)}]
          :signature   [{:params [unix-timestamp]}]}}

  [unix-timestamp]

  (.shell.invoke '.time.unix->iso
                 unix-timestamp))


;;;;;;;;;; Transactions


(defn .trx

  ^{:doc           {:description ["Applies a transaction."
                                  ""
                                  "This is effectively what a peer does when executing a transaction from"
                                  "a consensus block, after validating its signature."
                                  ""
                                  "Will fail with an exception if:"
                                  ""
                                  "  - Transaction origin is an actor (they cannot transact, only users can)"
                                  "  - Sequence ID is not the current sequence ID for that address + 1"
                                  ""
                                  "Sequence ID is an on-chain number attached to an account. It is incremented on"
                                  "every transaction. A valid transaction must embedded the current sequence ID + 1"
                                  "to avoid replay attacks."
                                  ""
                                  "If not provided when creating a new transaction, will be deduced from the current"
                                  "state. Obviously, this only really works if the transaction is meant to be executed"
                                  "against the current state as opposed to a network."
                                  ""
                                  "E.g.`(:sequence (account *address*))`."]
                    :examples    [{:code (.trx (.trx.new.invoke .account.genesis '(def cool? true)))}]
                    :signature   [{:params [trx]}]}
    :shell.section ["Creating and executing transactions like a peer would."
                    ""
                    "Transactions a special kind of Convex data not directly available to the user"
                    "on-chain. In the Shell, they look and behave like maps but technically are not."]}

  [trx]

  (.shell.invoke '.trx
                 trx))



(defn .trx.new.call

  ^{:doc  {:description ["Creates a transaction for calling an actor that can be executed with `.trx`."
                         ""
                         "Requires:"
                         ""
                         "  - Address of the account issuing the transaction (origin)"
                         "  - Address of the actor being called (target)"
                         "  - Symbol of the function being called"
                         "  - A vector of arguments or `nil`"
                         ""
                         "A map of options may be provided:"
                         ""
                         "  :offer"
                         "    Amount of Convex Coins for paying the actor (defaults to 0)"
                         ""
                         "  :sequence"
                         "    See `.trx` about the sequence ID"]
           :examples    [{:code (.trx.new.call #11 #42 'some-fn [1 2 3])}
                         {:code (.trx.new.call #11 #42 'some-fn [1 2 3] {:offer 10000, :sequence 100})}]
           :signature   [{:params [origin target function-name arg+]}
                         {:params [origin target function-name arg+ option+]}]}}


  ([origin target function-name arg+]

   (.trx.new.call origin
                  target
                  function-name
                  arg+
                  nil))


  ([origin target function-name arg+ option+]

   (.shell.invoke '.trx.new.call
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  target
                  (or (:offer option+)
                      0)
                  function-name
                  arg+)))



(defn .trx.new.invoke

  ^{:doc  {:description ["Creates a transaction for arbitrary code that can be executed with `.trx`."
                         ""
                         "Requires:"
                         ""
                         "  - Address issuing the transaction (origin)"
                         "  - A cell to execute (command)"
                         ""
                         "Advanced users may want to precompile the command using `.cell.compile`."
                         ""
                         "A map of options may be provided:"
                         ""
                         "  :sequence"
                         "    See `.trx` about the sequence ID"]
           :examples    [{:code (.trx.new.invoke #11 '(def cool? true))}
                         {:code (.trx.new.invoke #11 (compile '(def cool? true)) {:sequence 3})}]
           :signature   [{:params [origin command]}
                         {:params [origin command option+]}]}}


  ([origin command]

    (.trx.new.invoke origin
                     command
                     nil))


  ([origin command option+]

   (.shell.invoke '.trx.new.invoke
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  command)))



(defn .trx.new.transfer

  ^{:doc {:description ["Creates a transaction for a transfer of Convex Coins that can be executed"
                        "with `.trx`."
                        ""
                        "Requires:"
                        ""
                        "  - Address of the sender (origin)"
                        "  - Address of the receiver (target)"
                        "  - Amount of Convex Coins to transfer"
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :sequence"
                        "    See `.trx` about the sequence ID"]
          :examples    [{:code (.trx.new.transfer #11 #42 100000)}
                        {:code (.trx.new.transfer #11 #42 100000 {:sequence 3})}]
          :signature   [{:params [origin target amount]}
                        {:params [origin target amount option+]}]}}


  ([origin target amount]

   (.trx.new.transfer origin
                      target
                      amount
                      nil))


  ([origin target amount option+]

   (.shell.invoke '.trx.new.transfer
                  origin
                  (or (:sequence option+)
                      (inc (:sequence (account origin))))
                  target
                  amount)))



(defn .trx.noop

  ^{:doc {:description ["Like `.trx` but eventually does not execute the given transaction."
                        ""
                        "Meant for particular situations such as benchmarking, to emulate the overhead"
                        "associated with `.trx` without the cost of execution."
                        ""
                        "For advanced users only."]
          :examples    [{:code (.trx.noop (.trx.new.invoke .account.genesis '(def cool? true)))}]
          :signature   [{:params [trx]}]}}

  [trx]

  (.shell.invoke '.trx.noop
                 trx))



(defn .trx.with.sequence

  ^{:doc {:description ["Returns a new transaction which `trx` with the updated `sequence-id`."
                        "See `.trx` about sequence IDs."]
          :examples    [{:code (.trx.with.sequence (.trx.new.invoke #11 '(def cool? true)) 3)}]
          :signature   [{:params [trx sequence-id]}]}}

  [trx sequence-id]

  (.shell.invoke '.trx.with.sequence
                 trx
                 sequence-id))


;;;;;;;;;; Try-catch like helpers


(def .try

  ^{:private?      true
    :shell.section ["By design, the Convex Virtual Machine does not offer any \"try-catch\""
                    "mechanism as commonly found in mainstream languages. A transaction either"
                    "succeeds or fails when an exception is thrown."
                    ""
                    "However, catching exceptions is a common need for development. This section"
                    "contains some helper macros that build over `.state.safe`."]}

  nil)



(defmacro .try*

  ^{:doc {:description ["If `do-good` fails with an exception, state is reverted and `do-fail` is run."]
          :examples    [{:code (.try* (+ 2 2) :fail)}
                        {:code (.try* (assert false) :fail)}]
          :signature   [{:params [do-good do-fail]}]}}

  [do-good do-fail]

  `(let [[ok?
          x]  (.state.safe (fn [] ~do-good))]
     (if ok?
       x
       ~do-fail)))
          


(defmacro .try.resrc*

  ^{:doc {:description ["Safe way of running code with resources such as streams."
                        "Bindings are in a vector, akin to `let`, where each symbol is followed"
                        "by 2 forms."
                        ""
                        "Result of the first form is bound to the symbol, just like in `let`."
                        "Second form is executed when leaving this macro, usually to close the resource."
                        ""
                        "This ensure that resources closed even in case of an exception."]
          :examples    [{:code (.try.resrc* [s (.file.stream.in "foo.cvx") (.stream.close s)] (assert false)) }]
          :signature   [{:params [binding+ & body]}]}}

  [binding+ & body]

  (when-not (and (vector? binding+)
                 (zero? (mod (count binding+)
                             3)))
    (fail :ARGUMENT
          "Bindings must be in a vector consisting of triples"))
  (loop [code (cons 'do
                    body)
         i    (- (count binding+)
                 3)]
    (if (< i
           0)
      code
      (recur
        (let [sym   (get binding+
                         i)
              open  (get binding+
                         (inc i))
              close (get binding+
                         (+ i
                            2))]
          `(let [~sym ~open
                 [ok?
                  x]  (.state.safe* ~code)]
             ~(if (symbol? close)
                (list close
                      sym)
                close)
             (if ok?
               x
               (.ex.rethrow x))))
        (- i
           3)))))


;;;;;;;;;; Versions


(def .version

  ^{:private?      true
    :shell.section ["In case of a bug, please report `.version.shell` as well as `.version.convex`."]}

  nil)



(def .version.convex

  ^{:doc {:description "Convex version used by the Shell."}}

  .version.convex)



(def .version.java

  ^:private?

  .version.java)



(def .version.shell

  ^{:doc {:description "Version of this Shell."}}

  .version.shell)


;;;;;;;;;; Help


(defn ?

  ^{:doc {:description ["Get help."]
          :examples    [{:code (?)}
                        {:code (? #8)}
                        {:code (? #8 'inc)}
                        {:code (? 'inc)}]
          :signature   [{:params [query]}
                        {:params [address symbol]}]}}

  ([]

   (.stream.txt.outln "")
   (?.title "Information about an account")
   (?.txt "(? address)         ->  (? #8)")
   (?.title "Information about a symbol")
   (?.txt "(? symbol)          ->  (? 'inc)")
   (?.txt "(? address symbol)  ->  (? #8 'inc)")
   (?.title "Information about the Convex Shell")
   (?.txt "(?.shell)")
   (.stream.txt.outln "")
   nil)


  ([query]

   (.stream.txt.outln "")
   (cond
     ;;
     (address? query)
     (?.account query)
     ;;
     (symbol? query)
     (?.sym query)
     ;;
     (.stream.txt.outln "Ask for an address or a symbol."))
   nil)


  ([addr sym]

    (.stream.txt.outln "")
    (?.sym addr
           sym)
    nil))



(defn ?.account

  ^:private?

  [addr]

  (if-let [-account (account addr)]
    (?.print.account (assoc -account
                            :help.addr
                            addr))
    (.stream.txt.outln (str "Account not found for address "
                            addr))))



(defn ?.color

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.blue)
       s
       (.term.reset)))



(defn ?.color-2

  ^:private?

  [s]

  (str (.term.bold)
       (.term.fg.green)
       s
       (.term.reset)))



(defn ?.print.env

  ^:private?

  [env metadata filt]

  (reduce (fn [n sym-str]
            (let [sym      (symbol sym-str)
                  meta-sym (get metadata
                                sym)]
              (if (and (not (get meta-sym
                                   :private?))
                         (filt sym
                               meta-sym))
                (do
                  (?.txt (?.color-2 sym))
                  (?.txt-2 (when-let [desc (:description (:doc meta-sym))]
                             (let [desc-2 (if (str? desc)
                                            desc
                                            (let [first-line (first desc)]
                                              (if (> (count desc)
                                                     1)
                                                (str first-line
                                                     "..")
                                                first-line)))]
                               (if (> (count desc-2)
                                      80)
                                 (str (slice desc-2
                                             0
                                             77)
                                      "...")
                               desc-2))))
                  (inc n))
                n)))

           0
           (.str.sort (keys env))))



(defn ?.print.account

  ^:private?

  [-account]

  (.stream.txt.outln "")
  (let [addr   (:help.addr -account)
        lookup (call *registry*
                     (lookup addr))]
    (.docoll (fn [[title txt]]
               (?.title title)
               (?.txt txt))
             [["Address"     addr]
              ["Name"        (:name lookup)]
              ["Description" (:description lookup)]
              ["Allowance"   (:allowance -account)]
              ["Balance"     (:balance -account)]
              ["Controller"  (:controller -account)]
              ["Key"         (when-let [key (:key -account)]
                               (str "0x"
                                    key))]])
  
    (?.title "Overview")
    (let [env      (:environment -account)
          metadata (:metadata -account)]
      (if (empty? env)
        (?.txt "Empty environment.")
        (?.print.env env
                     metadata
                     (fn [sym _sym-meta]
                       (let [first-char (first (str sym))]
                         (and (not (= first-char
                                      \.))
                              (not (= first-char
                                      \?))))))))))



(defn ?.print.sym

  ^:private?

  [sym-meta]

  (?.title "Defined in")
  (?.txt (:help.addr sym-meta))
  (let [doc          (:doc sym-meta)
        code->reason (:errors doc)
        example+     (:examples doc)
        signature+   (:signature doc)]
    (?.title "Description")
    (?.txt (:description doc))
    (when-not (empty? signature+)
      (?.title (.str.pluralize (count signature+)
                               "Signature"))
      (.docoll (fn [signature]
                 (.stream.txt.outln (str "  "
                                         (:params signature))))
               signature+))
    (when-not (empty? code->reason)
      (?.title "Throws")
      (.docoll (fn [[code reason]]
                 (?.txt (str code
                             (?.color " <- ")
                             reason)))
               code->reason))
    (when-not (empty? example+)
      (?.title (.str.pluralize (count example+)
                               "Example"))
      (.docoll (fn [example]
                 (?.txt (:code example)))
               example+))))



(defn ?.shell


  ([]
 
   (let [feature (fn [feature description]
                   (str "  "
                        (.term.bold)
                        feature
                        (.term.reset)
                        "  "
                        description))]
     (.docoll .stream.txt.outln
              [""
               "Convex Shell augments the Convex Virtual Machine with additional features"
               "useful for developing smart contracts in Convex Lisp."
               ""
               "These functions and values are prefixed with `.` to be easily recognizable."
               "None of this is available on-chain with the regular Convex Virtual Machine."
               ""
               "Key sets of features are:"
               ""
               (feature ".a      "
                        "Utilities for async programming")
               (feature ".account"
                        "Account management")
               (feature ".bench  "
                        "Benchmarking")
               (feature ".cell   "
                        "Cell-related utilities")
               (feature ".client "
                        "Querying and transacting over peers")
               (feature ".db     "
                        "Using Etch, the fast immutable database for cells")
               (feature ".dep    "
                        "Dependency management and file reloading")
               (feature ".file   "
                        "Reading and writing files")
               (feature ".fs     "
                        "Filesystem utilities")
               (feature ".juice  "
                        "Juice operations")
               (feature ".kp     "
                        "Creating and managing key pairs")
               (feature ".log    "
                        "CVM log management")
               (feature ".pfx    "
                        "Safely storing and retrieving key pairs from files")
               (feature ".repl   "
                        "Read-Eval-Print-Loop for interactive work")
               (feature ".shell  "
                        "Shell configuration")
               (feature ".state  "
                        "Convex state management, such as time travel")
               (feature ".str    "
                        "String utilities")
               (feature ".stream "
                        "Generic utilities for reading and writing streams (files and beyond)")
               (feature ".sys    "
                        "System utilities")
               (feature ".t      "
                        "Unit testing library")
               (feature ".term   "
                        "Terminal ANSI escape codes (e.g. colored output)")
               (feature ".testnet"
                        "Utilities for the public testnet hosted by `https://convex.world`")
               (feature ".trx    "
                        "Executing transactions like a peer would")
               (feature ".try    "
                         "Error handling abstractions built over `.state.safe`.")
               (feature ".time   "
                        "Time utilities")
               (feature ".version"
                        "CVM and Shell versions")
               ""]))
   (?.title "List everything available in a feature set")
   (?.txt "(?.shell feature-set)  ->  (?.shell '.account)")
   (?.title "List all Shell features")
   (?.txt "(?.shell.list)")
   (?.title "Help about a function or a value")
   (?.txt "(? symbol)             ->  (? '.time.unix)")
   nil)


 ([sym]

   (.stream.txt.outln "")
   (when-let [txt (get-in (account $CORE$)
                          [:metadata
                           sym
                           :shell.section])]
     (?.title sym)
     (?.txt txt)
     (.stream.txt.outln ""))
   (?.title (str "Overview of Shell features matching `" sym "`"))
   (let [sym-2     (or (get {'.str '.str.  ;; avoids printing stream utils
                             '.t   '.t.}
                            sym)  ;; avoids printin anything that starts with `.t`
                       sym)
         core      (account .account.core)
         prefix    (str sym-2)
         n-slice   (count prefix)
         n-printed (?.print.env (:environment core)
                                (:metadata core)
                                (fn [sym sym-meta]
                                  (and (?.shell.list.filter sym
                                                            sym-meta)
                                       (let [target (str sym)]
                                         (and (>= (count target)
                                                  n-slice)
                                              (= (slice (str sym)
                                                        0
                                                        n-slice)
                                                 prefix))))))]
     (when (zero? n-printed)
       (?.txt "No matching symbols found.")))
   nil))



(defn ?.shell.list

  []

  (.stream.txt.outln "")
  (?.title "All Shell functions and values")
  (let [core (account .account.core)]
    (?.print.env (:environment core)
                 (:metadata core)
                 ?.shell.list.filter))
  nil)



(defn ?.shell.list.filter

  ^:private?

  [sym _sym-meta]

  (let [first-char (first (str sym))]
    (or (= first-char
           \.)
        (= first-char
           \?))))



(defn ?.sym

  ^:private?

  ([sym]

   (if-let [sym-meta (or (?.sym.meta *address*
                                     sym)
                         (?.sym.meta .account.core
                                     sym))]
     (?.print.sym sym-meta)
     (.stream.txt.outln "Symbol not found in current account nor in core account.")))


  ([addr sym]

   (if-let [sym-meta (?.sym.meta addr
                                 sym)]
     (?.print.sym sym-meta)
     (.stream.txt.outln (str "Symbol not found in account "
                             addr)))))



(defn ?.sym.meta

  ^:private?

  [addr sym]

  (when-let [sym-meta (get-in (account addr)
                              [:metadata
                               sym])]
    (assoc sym-meta
           :help.addr addr
           :help.sym  sym)))



(defn ?.title

  ^:private?

  [s]

  (.stream.txt.outln (?.color (str s
                                   ":"))))



(defn ?.txt

  ^:private?

  [s]

  (if s
    (if (vector? s)
      (.docoll (fn [s]
                 (.stream.txt.outln (str "  "
                                         s)))
               s)
      (.stream.txt.outln (str "  "
                              s)))
    (.stream.txt.outln "  None.")))



(defn ?.txt-2

  ^:private?

  [s]

  (.stream.txt.out "  ")
  (?.txt s))
