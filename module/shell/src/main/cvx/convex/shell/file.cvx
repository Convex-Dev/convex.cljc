(call *registry*
      (cns-update 'convex.shell.file
                  *address*))


(call *registry*
      (register {:description "Utilities for reading and writing Convex Lisp files."
                 :name        "File IO for the Convex Shell"}))


;;;;;;;;;;


(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))
           

;;;;;;;;;; Opening streams


(defn !.stream.in

  ^{:doc {:description ["Returns a request for opening an input stream for the Convex Lisp file located under `path`."
                        "Stream is available during next transaction under `$/*result*`."
                        "See the `$.stream` library."]
          :examples    [{:code "($.file/!.stream.in \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.stream.in path])



(defn !.stream.out

  ^{:doc {:description ["Returns a request for opening an output stream for the Convex Lisp file located under `path`."
                        "Stream is available during next transaction under `$/*result*`."
                        "See the `$.stream` library."]
          :examples    [{:code "($.file/!.stream.out \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}


  [path]

  (assert (str? path))
  [:cvm.sreq :file.stream.out path])


;;;;;;;;;; Higher-level utilities built on stream utilities


(defn !.exec

  ^{:doc {:description "Like `read` but the read cells are passed to `$.trx/precat` for executing as transactions."
          :examples    [{:code "($.file/!.exec \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  ($.trx/prepend '($.trx/precat $/*result*))
  (!.read path))



(defn !.read

  ^{:doc {:description ["Returns a request for reading the Convex Lisp file located under `path` in one go."
                        "List of read cells is available during next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.read \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  ($.trx/precat `(($.file/!.stream.in ~path)
                  ($.stream/!.in+ $/*result*))))



(defn -!.write

  ^{:private? true}

  [f-outln path cell]

  ($.trx/precat `(($.file/!.stream.out ~path)
                  (let [cell      (quote ~cell)
                        f-outln   (quote ~f-outln)
                        id-stream $/*result*]
                    ($.trx/precat `((~f-outln ~id-stream
                                              (quote ~cell))
                                    ($.stream/!.close ~id-stream)
                                    nil))))))



(defn !.txt.read


  ^{:doc {:description ["Returns a request for reading the file as the given `path` as text."
                        "String will be avaible during the next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.txt.read \"path/to/file.txt\")"}]
          :signature   [{:params [path]}]}}

  [path]

  ($.trx/precat `(($.file/!.stream.in ~path)
                  ($.stream/!.txt.in $/*result*))))



(defn !.write

  ^{:doc {:description ["Returns a request for writing `cell` to the Convex Lisp file located under `path`, in one go."
                        "File is created if needed."]
          :examples    [{:code "($.file/!.write \"./my/file.cvx\") {:foo :bar})"}]
          :signature   [{:params [path cell]}]}}

  [path cell]

  (-!.write '$.stream/!.outln
            path
            cell))



(defn !.txt.write

  ^{:doc {:description ["Like `!.write` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might be readable as Convex Lisp."]
          :examples    [{:code "($.file/!.write.txt \"./my/file.cvx\") \"This is some text\")"}]
          :signature   [{:params [path cell]}]}}

  [path cell]

  (-!.write '$.stream/!.txt.outln
            path
            cell))


;;;;;;;;;; Other filesystem operations


(defn !.copy

  ^{:doc {:description ["Returns a requrest for copying the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code "($.file/!.copy \"some_dir/foo.txt\" \"another_dir\")"}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (assert (str? path-source)
          (str? path-destination))
  [:cvm.sreq :file.copy path-source path-destination])



(defn !.delete

  ^{:doc {:description "Returns a request for deleting the file or the empty folder at the given `path`."
          :examples    [{:code "($.file/!.delete \"some-file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.delete path])



(defn !.exists?

  ^{:doc {:description ["Returns a request for testing if a file exists."
                        "Boolean result will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.exists? \"some_dir/some_file.txt\")"}]
          :signatures  [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.exists path])



(defn !.tmp

  ^{:doc {:description ["Returns a request for creating a temporary file."
                        "`prefix` and `suffix` are both optional."]
          :examples    [{:code "($.fs/!.tmp)"}
                        {:code "($.fs/!.tmp \".cvx\")"}
                        {:code "($.fs/!.tmp \"some-project\" \".cvx\")"}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (!.tmp nil
          nil))


  ([suffix]

   (!.tmp nil
          suffix))


  ([prefix suffix]

   (assert (or (nil? prefix)
               (str? prefix))
           (or (nil? suffix)
               (str? suffix)))
   [:cvm.sreq :file.tmp prefix suffix]))
