(call *registry*
      (cns-update 'convex.shell.file
                  *address*))


(call *registry*
      (register {:description "Utilities for reading and writing Convex Lisp files."
                 :name        "File IO for the Convex Shell"}))


;;;;;;;;;; Private values


(def $.state

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.state)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))
           

;;;;;;;;;; Opening streams


(defn !.stream.in

  ^{:doc {:description ["Returns a request for opening an input stream for file located under `path`."
                        "Stream will available during the next transaction under `$/*result*`."
                        ""
                        "See the `$.stream` library."]
          :examples    [{:code "($.file/!.stream.in \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.stream.in path])



(defn !.stream.out

  ^{:doc {:description ["Returns a request for opening an output stream for the file located under `path`."
                        ""
                        "Stream will be available during the next transaction under `$/*result*`."
                        "See the `$.stream` library."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :append?"
                        "    Writes will be appended to the end if true, otherwise file will be overwritten if it exists."
                        "    False by default."]
          :examples    [{:code "($.file/!.stream.out \"./my/file.cvx\")"}
                        {:code "($.file/!.stream.out \"./my/file.cvx\" {:append? true})"}]
          :signature   [{:params [path]}
                        {:params [path option+]}]}}


  ([path]

   (!.stream.out path
                 nil))


  ([path option+]

   (assert (str? path))
   [:cvm.sreq :file.stream.out path (boolean (:append? option+))]))


;;;;;;;;;; Higher-level utilities built on stream utilities


(defn !.exec

  ^{:doc {:description ["Like `$.file/!.read` but the read cells are executed atomically as transactions."
                        "See `$.state/!.atomic`."]
          :examples    [{:code "($.file/!.exec \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  ($.state/!.atomic `(($.file/!.read ~path)
                      ($.trx/precat $/*result*))))



(defn !.read

  ^{:doc {:description ["Returns a request for reading the Convex Lisp file located under `path` in one go."
                        "List of read cells is available during next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.read \"./my/file.cvx\")"}]
          :signature   [{:params [path]}]}}

  ;; Stream is closed automatically in the Clojure code.

  [path]

  ($.trx/precat `(($.file/!.stream.in ~path)
                  ($.stream/!.in+ $/*result*))))



(defn -!.write

  ^{:private? true}

  [f-outln path cell option+]

  ($.trx/precat `(($.file/!.stream.out ~path
                                       (quote ~option+))
                  (let [cell      (quote ~cell)
                        f-outln   (quote ~f-outln)
                        id-stream $/*result*]
                    ($.catch/!.try `($.trx/precat '((~f-outln ~id-stream
                                                              (quote ~cell))
                                                    nil))
                                   nil
                                   `($.stream/!.close ~id-stream))))))



(defn !.write

  ^{:doc {:description ["Returns a request for writing `cell` to the file located under `path`, in one go."
                        "See `$.file/!.stream.out` for options."]
          :examples    [{:code "($.file/!.write \"./my/file.cvx\") {:foo :bar})"}
                        {:code "($.file/!.write \"./my/file.cvx\") {:foo :bar} {:append? true})"}]
          :signature   [{:params [path cell]}
                        {:params [path cell option+]}]}}


  ([path cell]

   (!.write path
            cell
            nil))


  ([path cell option+]

   (-!.write '$.stream/!.outln
             path
             cell
             option+)))



(defn !.txt.read


  ^{:doc {:description ["Returns a request for reading the file as the given `path` as text."
                        "String will be avaible during the next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.txt.read \"path/to/file.txt\")"}]
          :signature   [{:params [path]}]}}

  [path]

  ($.trx/precat `(($.file/!.stream.in ~path)
                  ($.stream/!.txt.in $/*result*))))



(defn !.txt.write

  ^{:doc {:description ["Like `$.file/!.write` but if `cell` is a string, it will not be double-quoted."
                        "Hence, the output might not be readable as Convex Lisp."]
          :examples    [{:code "($.file/!.txt.write \"./my/file.cvx\" \"This is some text\")"}
                        {:code "($.file/!.txt.write \"./my/file.cvx\" \"This is some text\" {:append? true})"}]
          :signature   [{:params [path cell]}
                        {:params [path cell option+]}]}}


  ([path cell]

   (!.txt.write path
                cell
                nil))


  ([path cell option+]

   (-!.write '$.stream/!.txt.outln
             path
             cell
             option+)))


;;;;;;;;;; Other filesystem operations


(defn !.copy

  ^{:doc {:description ["Returns a requrest for copying the file at `path-source` to `path-destination`."
                        "If `path-destination` is a directory, `path-source` will be copied inside it."
                        "Behaves like Unix's `cp`."]
          :examples    [{:code "($.file/!.copy \"some_dir/foo.txt\" \"another_dir\")"}]
          :signature   [{:params [path-source path-destination]}]}}

  [path-source path-destination]

  (assert (str? path-source)
          (str? path-destination))
  [:cvm.sreq :file.copy path-source path-destination])



(defn !.delete

  ^{:doc {:description "Returns a request for deleting the file or the empty folder at the given `path`."
          :examples    [{:code "($.file/!.delete \"some-file.cvx\")"}]
          :signature   [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.delete path])



(defn !.exists?

  ^{:doc {:description ["Returns a request for testing if a file exists."
                        "Boolean result will be available during the next transaction under `$/*result*`."]
          :examples    [{:code "($.file/!.exists? \"some_dir/some_file.txt\")"}]
          :signatures  [{:params [path]}]}}

  [path]

  (assert (str? path))
  [:cvm.sreq :file.exists path])



(defn !.tmp

  ^{:doc {:description ["Returns a request for creating a temporary file."
                        "`prefix` and `suffix` are both optional."]
          :examples    [{:code "($.file/!.tmp)"}
                        {:code "($.file/!.tmp \".cvx\")"}
                        {:code "($.file/!.tmp \"some-project\" \".cvx\")"}]
          :signature   [{:params []}
                        {:params [suffix]}
                        {:params [prefix suffix]}]}}


  ([]

   (!.tmp nil
          nil))


  ([suffix]

   (!.tmp nil
          suffix))


  ([prefix suffix]

   (assert (or (nil? prefix)
               (str? prefix))
           (or (nil? suffix)
               (str? suffix)))
   [:cvm.sreq :file.tmp prefix suffix]))



(defn !.tmp-dir

  ^{:doc {:description ["Returns a request for creating a temporary directory."
                        "`prefix` is optional."]
          :examples    [{:code "($.file/!.tmp-dir)"}
                        {:code "($.file/!.tmp-dir \"some-prefix\")"}]
          :signature   [{:params []}
                        {:params [prefix]}]}}


  ([]

   (!.tmp-dir nil))


  ([prefix]

   (assert (or (nil? prefix)
               (str? prefix)))
   [:cvm.sreq :file.tmp-dir prefix]))
