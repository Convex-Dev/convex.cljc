(call *registry*
      (cns-update 'convex.shell.state
                  *address*))


(call *registry*
      (register {:description ["Advanced capabilities for doing time travel, allowing to remember and restore"
                               "the whole state at given points in time."
                               "Notably useful for restoring a work session in combination with `$.db` utilities."]
                 :name        "Time travel and state utilities for the Convex Shell"}))


;;;;;;;;;; Private


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; State loading


(defn !.load

  ^{:doc {:description ["Returns a request for discarding the current state of the Convex Shell and loading the given one."
                        "Available under `*state*`, states are actually a special type of cell behaving like maps."
                        "When using functions like `assoc` on them, regular maps are returned. Such values will not work"
                        "with this request."
                        ""
                        "A common use case is saving the current state on disk with `$.db/!.root.write`, retrieving it in a later"
                        "work session using `$.db/!.root.read`, and restoring it using this request."
                        ""
                        "A transaction can be submitted as second argument. It will be executed after loading the state."
                        "It is commonly used for remembering information from state to state."]
          :examples    [{:code "($.state/!.load *state*)"}
                        {:code "($.state/!.load *state* `(def y ~(inc x)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load state
           nil))


  ([state trx]

   [:cvm.sreq :state.load state trx]))




(defn !.load-continue

  ^{:doc {:description ["Like `!.load` but the current list of transactions will replace the list of transactions"
                        "of the loaded state."
                        "This is what is often needed. Remember that transactions to execute are stored in the"
                        "`$.trx` library, hence in an account that is part of the state."
                        "That means that loading a state without restoring current transactions will result in the"
                        "execution of transactions stored on the loaded state as opposed to the old state."
                        ""
                        "Note that this function simply reuses `!.load`. Users may imagine many different variants"
                        "as to what should happen to transactions."]
          :examples    [{:code "($.state/!.load-continue *state*)"}
                        {:code "($.state/!.load-continue *state* `(def y ~(inc x)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load-continue state
                    nil))


  ([state trx]

   (!.load state
           `($.trx/set (quote ~(cons trx
                                     $.trx/*list*))))))


;;;;;;;;;;


(def *stack*

  ^{}

  (list))



(defn push

  ^{:callable? true
    :doc       {:description ["Pushes the current state of the CVM onto `$.state/*stack*`."
                              "This state can later be restored using `$.stack/!.pop`."
                              "Unlike `$.stack/!.pop`, this is not a request and is performed righ away."]
                :examples    [{:code "($.state/push)"}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         ~*address*)
    (do
      (def *stack*
           (cons *state*
                 *stack*))
      $/*result*)
    (call ~*address*
          (push))))



(defn !.pop

  ^{:doc {:description ["Returns a request that will restore  the last state saved with `$.state/push`."
                        "An optional transaction may be provided for execution after popping the state."
                        "This is commonly used to remember something from the popped state."]
          :examples    [{:code "($.state/!.pop)"}
                        {:code "($.state/!.pop `(def bar ~(inc foo)))"}]
          :signature   [{:params []}
                        {:params [trx]}]}}


  ([]

   (!.pop nil))


  ([trx]

   (if-let [state (first *stack*)]
     (!.load-continue state
                      trx)
     (fail :STATE
           "No state to pop"))))
