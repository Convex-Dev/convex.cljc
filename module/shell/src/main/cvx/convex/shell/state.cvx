(call *registry*
      (cns-update 'convex.shell.state
                  *address*))


(call *registry*
      (register {:description ["Advanced capabilities for doing time travel, allowing to remember and restore"
                               "the whole state at given points in time."
                               "Notably useful for restoring a work session in combination with `$.db` utilities."]
                 :name        "Time travel and state utilities for the Convex Shell"}))


;;;;;;;;;; Private


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.catch

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.catch)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; State loading


(defn !.load

  ^{:doc {:description ["Returns a request for discarding the current state of the Convex Virtual Machine and loading the given one."
                        "Available under `*state*`, states are actually a special type of cell behaving like maps."
                        "When using functions like `assoc` on them, regular maps are returned. Such values will not work"
                        "with this request."
                        ""
                        "A common use case is saving the current state on disk with `$.db/!.root.write`, retrieving it in a later"
                        "work session using `$.db/!.root.read`, and restoring it using this request."
                        ""
                        "A transaction may be submitted as second argument. It will be executed after loading the state."
                        "Default one is `$/*result*`so that the last result of the old state will be transferred to the new one."
                        "It is commonly used for remembering information from state to state."
                        ""
                        "Note that all of this is only about the state of the Convex Virtual Machine. Other resources that may have"
                        "been opened in the Convex Shell, such as file streams, will not be changed in any way."]
          :examples    [{:code "($.state/!.load *state*)"}
                        {:code "($.state/!.load *state* `(def y ~(inc x)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load state
           `(quote ~$/*result*)))


  ([state trx]

   [:cvm.sreq :state.load state trx]))




(defn !.load-continue

  ^{:doc {:description ["Like `!.load` but the current list of transactions will replace the list of transactions"
                        "of the loaded state."
                        "This is what is often needed. Remember that transactions to execute are stored in the"
                        "`$.trx` library, hence in an account that is part of the state."
                        "That means that loading a state without restoring current transactions will result in the"
                        "execution of transactions stored on the loaded state as opposed to the old state."
                        ""
                        "Note that this function simply reuses `!.load`. Users may imagine many different variants"
                        "as to what should happen to transactions."]
          :examples    [{:code "($.state/!.load-continue *state*)"}
                        {:code "($.state/!.load-continue *state* `(def y ~(inc x)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load-continue state
                    `(quote ~$/*result*)))


  ([state trx]

   (!.load state
           `($.trx/set (quote ~(cons trx
                                     $.trx/*list*))))))


;;;;;;;;;; Stack-base time traveling


(def *stack*

  ^{:doc {:description "See `$.state/push`."}}

  (list))



(defn drop

  ^{:callable? true
    :doc       {:description ["Opposite of `$.state/push`: drops the next state from `$.state/*stack*`."
                              "Throws if there is no state to drop."
                              "Returns the popped state."]
                :examples    [{:code "($.state/push)"}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         ~*address*)
    (if (empty? *stack*)
      (fail :STATE
            "No state to drop")
      (let [state (first *stack*)]
        (def *stack*
             (next *stack*))
        state))
    (call ~*address*
          (drop))))



(defn push

  ^{:callable? true
    :doc       {:description ["Pushes the current state of the Convex Virtual Machine onto `$.state/*stack*`."
                              "This state can later be restored using `$.stack/!.pop`."
                              "Unlike `$.stack/!.pop`, this is not a request and is performed right away."
                              "Returns the last `$/*result*`."]
                :examples    [{:code "($.state/push)"}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         ~*address*)
    (do
      (def *stack*
           (cons *state*
                 *stack*))
      $/*result*)
    (call ~*address*
          (push))))



(defn !.pop

  ^{:doc {:description ["Returns a request that will restore the last state saved with `$.state/push`."
                        ""
                        "An optional transaction may be provided for execution after popping the state."
                        "Default one is `$/*result*` so that the last result from the old state will"
                        "be transferred to the popepd state."
                        "This is commonly used to remember something from the discarded state."
                        ""
                        "Throws if there is no state to pop."

                        "Attention, do not pop a state that you did not push."
                        "Usually, things will go very baddly if you do."]
          :examples    [{:code "($.state/!.pop)"}
                        {:code "($.state/!.pop `(def bar ~(inc foo)))"}]
          :signature   [{:params []}
                        {:params [trx]}]}}


  ([]

   (!.pop nil))


  ([trx]

   (if (empty? *stack*)
     (fail :STATE
           "No state to pop")
     (!.load-continue (first *stack*)
                      (if (nil? trx)
                        $/*result*
                        trx)))))


;;;;;;;;;; Executing several transactions with different guarantees


(defn !.atomic

  ^{:doc {:description ["Single Convex transactions are atomic: if they fail, any state change is discarded."
                        ""
                        "This function extends this behavior to multi-transactions."
                        "Before prepending the given transactions for execution, the `*state*` is remembered. In case of"
                        "an exception, the original state is restored and the exception is rethrown."
                        ""
                        "E.g. In the example below, an exception will be thrown and `foo` will be undefined."]
          :examples    [{:code "($.state/!.atomic '((def foo 42) (assert (< foo 1))))"}]
          :signature   [{:params [trx+]}]}}

  [trx+]

  ($.catch/!.safe `($.trx/precat (quote ~trx+))
                  '{:$.state.exception $/*result*}
                  `(when-let [exception (and (map? $/*result*)
                                             ($/*result* :$.state.exception))]
                     ($.state/!.load (quote ~*state*)
                                     `[:cvm.sreq :catch.rethrow (quote ~exception)]))))



(defn -!.tmp

  ^{:private? true}

  ;; General mechanism for executing some transactions safely and restoring to a given state.

  [original-state trx+]

  ($.catch/!.safe `($.trx/precat (quote ~trx+))
                  '{:$.state.exception $/*result*}
                  `($.state/!.load (quote ~original-state)
                                   (if-let [exception (and (map? $/*result*)
                                                           ($/*result* :$.state.exception))]
                                     `[:cvm.sreq :catch.rethrow (quote ~exception)]
                                     $/*result*))))


(defn !.tmp

  ^{:doc {:description ["Remembers the current `*state*` and prepends the given transactions for execution."
                        "After executing them, the original state is restored and the last `$/*result*` is transferred."
                        ""
                        "Useful for computing a result and erasing any state change it might have caused."
                        ""
                        "In case of an exception, behaves like `$.state/!.atomic`."]
          :examples    [{:code "($.state/!.tmp '((def foo 42) (inc foo)))   (and (= $/*result* 43) (not (defined? foo)))"}]
          :signature   [{:params [trx+]}]}}

  [trx+]

  ;; Exception must be rethrown explicitly because after loading, `$.catch/!.safe` related transactions
  ;; are forgotten.

  (-!.tmp *state*
          trx+))



(defn !.tmp-with

  ^{:doc {:description ["Like `$.state/!.tmp` but the first argument is a state to load temporarily"
                        "as oppposed to using the current `*state*`."
                        "After the given transactions are executed, the original `*state*` is restored."]
          :examples    [{:code "($.state/!.tmp-with some-state '(*balance*)"}]
          :signature   [{:params [state trx+]}]}}

  [state trx+]

  (!.load-continue state
                   `($.state/-!.tmp (quote ~*state*)
                                    (quote ~trx+))))
