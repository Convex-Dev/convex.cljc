(call *registry*
      (cns-update 'convex.shell.state
                  *address*))


(call *registry*
      (register {:description ["Advanced capabilities for doing time travel, allowing to remember and restore"
                               "the whole state at given points in time."
                               "Notably useful for restoring a work session in combination with `$.db` utilities."]
                 :name        "Time travel and state utilities for the Convex Shell"}))


;;;;;;;;;; Private values


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.catch

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.catch)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; Public values


(def genesis

  ^{:doc {:description ["Genesis state used as the very first state in the Convex network."
                        ""
                        "It provides all the official Convex actors and libraries but nothing related to"
                        "the Convex Shell."]}}

  ;; Provided by CLJ `$.shell.ctx/dpeloy-lib+`.

  nil)

;;;;;;;;;; Scoped evaluation


(defn !.god

  ^{:doc {:description ["Commonly used for executing a transaction under a given address."
                        "Effectively \"god mode\"."
                        ""
                        "Reuses `$.state/!.safe` and behaves exactly the same but:"
                        ""
                        "  - Uses `*state*` as the input state"
                        "  - Output state will be loaded using `$.state/!.load-continue`"
                        "  - Output result will be bound to `$/*result*`"
                        ""
                        "Same options."]
          :examples    [{:code "($.state/!.god {:address #3} '(def foo 42))"}]
          :signature   [{:params [trx]}
                        {:params [option+ trx]}]}}


  ([trx]

   (!.god nil
          trx))


  ([option+ trx]

   ($.trx/precat `(($.state/!.safe (quote ~*state*)
                                   (quote ~option+)
                                   (quote ~trx))
                   ($.state/!.load-continue (second $/*result*)
                                            `(quote ~(first $/*result*)))))))



(defn !.safe

  ^{:doc {:description ["Returns a request for evaluating the given transaction in the context of the given state."
                        ""
                        "Unlike `$.state/!.load` and variants, Convex Shell libraries will never be deployed."
                        "The input state will not be prepared in any way and the original state will always be restored."
                        ""
                        "The result will be available during the next transaction under `$/*result*`: a vector"
                        "where the first element is the result of the transaction and the second element is the new state"
                        "after executing it."
                        ""
                        "This provides an environment for safe evaluation. The current `*state*` is never modified and"
                        "even if the input state has access to Convex Shell libraries, no request such as reading a file"
                        "can be performed. Even if the result of the transaction is a request, it ends up being wrapped"
                        "in vector as described above and will not be recognized by the Convex Shell. Nonetheless, results"
                        "should always be handled carefully when the transaction is untrusted code."
                        ""
                        "Note that any CVM log changes will be discarded."
                        ""
                        "A map of options may be provided:"
                        ""
                        "  :address"
                        "    Sets the origin address (current address by default)."
                        ""
                        "  :juice"
                        "    Sets the maximum juice limit (100K units by default)."]
          :examples    [{:code "($.state/!.safe $.state/genesis '(balance #3))"}
                        {:code "($.state/!.safe $.state/genesis {:address #3, :juice 50000} '*balance*)"}]
          :signature   [{:params [state trx]}
                        {:params [state address trx]}]}}


  ([state trx]

   (!.safe state
           nil
           trx))


  ([state option+ trx]

   (let [address (:address option+)
         juice   (:juice option+)]
     (assert (or (nil? address)
                 (address? address))
             (or (nil? juice)
                 (and (long? juice)
                      (>= juice
                          0))))
     (let [address-2 (or address
                         *address*)]
       (when-not (>= (count (state :accounts))
                     (long address-2))
         (fail :NOBODY
               (str "Input state does not contain address: "
                    address-2)))
         [:cvm.sreq :state.safe state address-2 (or juice 100000) trx]))))


;;;;;;;;;; State loading


(defn !.load

  ^{:doc {:description ["Returns a request for discarding the current state of the Convex Virtual Machine and loading the given one."
                        "Available under `*state*`, states are actually a special type of cell behaving like maps."
                        "When using functions like `assoc` on them, regular maps are returned. Such values will not work"
                        "with this request."
                        ""
                        "A common use case is saving the current state on disk with `$.db/!.root.write`, retrieving it in a later"
                        "work session using `$.db/!.root.read`, and restoring it using this request."
                        ""
                        "A transaction may be submitted as second argument. It will be executed after loading the state."
                        "Default one is `'$/*result*`so that the last result of the old state will be transferred to the new one."
                        "It is commonly used for remembering information from state to state."
                        ""
                        "All Convex Shell libraries will be deployed if they seem to be lacking."
                        ""
                        "Note that all of this is only about the state of the Convex Virtual Machine. Other resources that may have"
                        "been opened in the Convex Shell, such as file streams, will not be changed in any way."]
          :examples    [{:code "($.state/!.load $.state/genesis)"}
                        {:code "($.state/!.load $.state/genesis `(def y ~(inc 42)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load state
           `(quote ~$/*result*)))


  ([state trx]

   [:cvm.sreq :state.load state trx]))




(defn !.load-continue

  ^{:doc {:description ["Like `!.load` but the current list of transactions will replace the list of transactions"
                        "of the loaded state."
                        ""
                        "This is what is often needed. Remember that transactions to execute are stored in the"
                        "`$.trx` library, hence in an account that is part of the state."
                        "That means that loading a state without restoring current transactions will result in the"
                        "execution of transactions stored on the loaded state as opposed to the old state."
                        ""
                        "Note that this function simply reuses `!.load`. Users may imagine many different variants"
                        "as to what should happen to transactions."]
          :examples    [{:code "($.state/!.load-continue $.state/genesis)"}
                        {:code "($.state/!.load-continue $.state/genesis `(def y ~(inc 42)))"}]
          :signature   [{:params [state]}
                        {:params [state trx]}]}}

  
  ([state]

   (!.load-continue state
                    `(quote ~$/*result*)))


  ([state trx]

   (!.load state
           `($.trx/set (quote ~(cons trx
                                     $.trx/*list*))))))


;;;;;;;;;; Executing several transactions with different guarantees


(defn !.atomic

  ^{:doc {:description ["Single Convex transactions are atomic: if they fail, any state change is discarded."
                        ""
                        "This function extends this behavior to multi-transactions."
                        "Before prepending the given transactions for execution, the `*state*` is remembered. In case of"
                        "an exception, the original state is restored and the exception is rethrown."
                        ""
                        "Based on `$.state/!.load`."
                        ""
                        "E.g. In the example below, an exception will be thrown and `foo` will be undefined."]
          :examples    [{:code "($.state/!.atomic '((def foo 42) (assert (< foo 1))))"}]
          :signature   [{:params [trx+]}]}}

  [trx+]

  ($.catch/!.try `($.trx/precat (cons '(quote ~$/*result*)
                                      (quote ~trx+)))
                 '{:$.state.exception $/*result*}
                 `(when-let [exception (and (map? $/*result*)
                                            ($/*result* :$.state.exception))]
                    ($.state/!.load (quote ~*state*)
                                    `($.catch/!.rethrow (quote ~exception))))))



(defn -!.tmp

  ^{:private? true}

  ;; General mechanism for executing some transactions safely and restoring to a given state.
  ;;
  ;; Exception must be rethrown explicitly because after loading, `$.catch/!.try` related transactions
  ;; are forgotten.

  [original-state result-begin trx+]

  ($.catch/!.try `($.trx/precat (cons '(quote ~result-begin)
                                      (quote ~trx+)))
                 '{:$.state.exception $/*result*}
                 `($.state/!.load (quote ~original-state)
                                  (if-let [exception (and (map? $/*result*)
                                                          ($/*result* :$.state.exception))]
                                    `($.catch/!.rethrow (quote ~exception))
                                    `(quote ~$/*result*)))))



(defn !.tmp

  ^{:doc {:description ["Remembers the current `*state*` and prepends the given transactions for execution."
                        "After executing them, the original state is restored and the last `$/*result*` is transferred."
                        ""
                        "Useful for computing a result and erasing any state change it might have caused."
                        ""
                        "In case of an exception, behaves like `$.state/!.atomic`."
                        ""
                        "Based on `$.state/!.load`."]
          :examples    [{:code "($.state/!.tmp '((def foo 42) (inc foo)))   (and (= $/*result* 43) (not (defined? foo)))"}]
          :signature   [{:params [trx+]}]}}

  [trx+]

  (-!.tmp *state*
          $/*result*
          trx+))



(defn !.tmp-with

  ^{:doc {:description ["Like `$.state/!.tmp` but the first argument is a state to load temporarily"
                        "as oppposed to using the current `*state*`."
                        "After the given transactions are executed, the original `*state*` is restored."]
          :examples    [{:code "($.state/!.tmp-with $.state/genesis '(*balance*))"}]
          :signature   [{:params [state trx+]}]}}

  [state trx+]

  (!.load-continue state
                   `($.state/-!.tmp (quote ~*state*)
                                    (quote ~$/*result*)
                                    (quote ~trx+))))


;;;;;;;;;; Specific state alterations


(defn !.clean

  ^{:doc {:description ["Prepends a series of requests for execution aimed to cleane the input state by ensuring:"

                        "by ensuring:"
                        ""
                        "  - Custom exception handlers in `$.catch/*stack* are removed"
                        "  - REPL is declared as off"
                        "  - Transactions are replaced with the given ones or reset"
                        ""
                        "Naturally, this will fail on a state that has not been initialized with the Convex"
                        "Shell libraries."
                        ""
                        "Default input state is `*state*`."
                        ""
                        "This is often cleaner when storing a state in Etch (see `$.db`) with the propsect"
                        "of using it later with `$.state/!.load`."]
          :examples    [{:code "($.state/!.clean *state* '(($.repl/!.start)))"}]
          :signature   [{:params [state]}
                        {:params [state option+]}]}}


  ([]

   (!.clean *state*))


  ([state]

   (!.clean state
            nil))


  ([state trx+]

   ($.trx/precat `(($.state/!.safe (quote ~state)
                                   {:address #2}
                                   '(do
                                      ;; Actually, `$.repl/!.stop` is CVX Lisp only.
                                      ($.repl/!.stop)
                                      ($.trx/set (quote ~(or trx+
                                                             '())))
                                      $.catch))
                   ($.state/!.safe (second $/*result*)
                                   {:address (first $/*result*)}
                                   '(def *stack*
                                         (list (last *stack*))))
                   (second $/*result*)))))
