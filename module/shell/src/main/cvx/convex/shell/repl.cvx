(call *registry*
      (cns-update 'convex.shell.repl
                  *address*))


(call *registry*
      (register {:description "Starting and stopping the basic REPL provided by the Convex Shell."
                 :name        "Simple Convex REPL"}))


;;;;;;;;;; Importing libraries


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.catch

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.catch)))



(def $.stream

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.stream)))



(def $.term

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.term)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; Private values


(def -self

  ^{:private? true}

  *address*)


;;;;;;;;;; Public values


(def *active?*

  ^{:doc {:description "Set to true if the REPL is currently running."}}

  false)



(defn prompt

  ^{:doc {:description "Default function for producing prompt string."}}

  []

  (str ($.term/bold)
       ($.term/fg.blue)
       "> "
       ($.term/reset)))


;;;;;;;;;; Private values


(def -prompt

  ^{:doc      {:description "Currently used prompt."}
    :private? true}

  nil)



;;;;;;;;;; Pretty-printing


(defn str.exception

  ^{:doc {:description ["Turns given `exception` into a nice human-readable string." 
                        "Used by the REPL when handling exceptions thrown during evaluation."]
          :signature   [{:params [exception]}]}}

  [exception]

  (str $/line
       ($.term/bold)
       ($.term/fg.red)
       "Exception code:"
       ($.term/reset)
       $/line
       "  "
       ($.term/bold)
       (exception :code)
       $/line
       ($.term/bold)
       ($.term/fg.red)
       "Message:"
       ($.term/reset)
       $/line
       "  "
       (exception :message)
       $/line
       ($.term/bold)
       ($.term/fg.red)
       "Trace:"
       ($.term/reset)
       (let [trace (exception :trace)]
         (if (empty? trace)
           (str $/line
                "  None.")
           (apply str
                  (reduce (fn [acc entry]
                            (conj acc
                                  $/line
                                  "  "
                                  entry))
                          []
                          trace))))
       (let [extra-data (dissoc exception
                                :code
                                :exception?
                                :message
                                :trace)]
         (if (empty? extra-data)
           ""
           (str $/line
                ($.term/bold)
                ($.term/fg.red)
                "Extra data:"
                ($.term/reset)
                $/line
                "  "
                extra-data)))
       $/line))


;;;;;;;;;; Internal


(declare -!.next)



(defn -!.eval

  ^{:private? true}

  ;; Handles the evaluation part with exception handling.

  [result-previous form+]

  ($.trx/precat `(($.catch/!.try ;; Try
                                 '($.trx/precat (concat '((quote ~result-previous))
                                                        (quote ~form+)
                                                        '((if $.repl/*active?*
                                                            ($.trx/precat `(($.stream/!.txt.out $/line)
                                                                            ($.stream/!.outln (quote ~$/*result*))
                                                                            ($.stream/!.txt.out $/line)
                                                                            ($.stream/!.flush)
                                                                            (quote ~$/*result*)))
                                                            $/*result*))))
                                 ;; Catch
                              `($.trx/precat `(($.stream/!.txt.outln ($.repl/str.exception (quote ~$/*result*)))
                                               (quote ~$/*result*))))
                  (if $.repl/*active?*
                    ($.repl/-!.next $/*result*)
                    $/*result*))))



(defn -!.exception.input

  ^{:private? true}

  ;; Handles exceptions occuring while reading input forms.

  [exception result-previous]

  (if (= (exception :code)
         :READER)
    ;; Input is not valid Convex Lisp.
    ($.trx/precat `(($.stream/!.txt.outln (str $/line
                                               ($.term/fg.red)
                                               ($.term/bold)
                                               "Input cannot be parsed as Convex Lisp:"
                                               ($.term/reset)
                                               $/line
                                               "  "
                                               ~(exception :message)
                                               $/line))
                    ($.repl/-!.next (quote ~result-previous))))
    ;; Another unforeseen exception while reading input.
    ($.trx/set `(($.stream/!.txt.outln $.stream/*err*
                                       (str $/line
                                            $/line
                                            ($.term/bold)
                                            ($.term/fg.red)
                                            "================================================"
                                            $/line
                                            "                                                "
                                            $/line
                                            "  Exception while reading input: stopping REPL  "
                                            $/line
                                            "                                                "
                                            $/line
                                            "================================================"
                                            ($.term/reset))):
                 ($.stream/!.txt.outln ($.repl/str.exception (quote ~exception)))
                 ($.process/!.exit 4)))))



(defn -!.next

  ^{:private? true}

  ;; Read-Eval-Print loop.

  [result-previous]

  ($.trx/precat `(($.stream/!.txt.out ~(if (fn? -prompt)
                                         (-prompt)
                                         -prompt))
                  ($.stream/!.flush)
                  ($.catch/!.try '($.stream/!.line)
                                 '$/*result*)
                  (cond
                    ;;
                    ;; An exception occured while reading input.
                    ($.catch/exception? $/*result*)
                    ($.repl/-!.exception.input $/*result*
                                               (quote ~result-previous))
                    ;;
                    ;; Nil, input stream reached its end.
                    (nil? $/*result*)
                    ($.repl/stop)
                    ;;
                    ;; Prints result or exception after executing input.
                    (let [form+ $/*result*]
                      (if (>= (count form+)
                              1)
                        ;; At least one form to evaluate.
                        ($.repl/-!.eval (quote ~result-previous)
                                        form+)
                        ;; No input form, restart while keeping the same previous result.
                        ($.repl/-!.next (quote ~result-previous))))))))


;;;;;;;;;; Public


(defn !.start

  ^{:callable? true
    :doc       {:description ["Starts a REPL on next transaction."
                              ""
                              "User can then enter transactions and see results."
                              "For stopping, see `stop`."
                              "A prompt or prompt producing function may be provided."]
                :examples    [{:code "($.repl/!.start)"}
                              {:code "($.repl/!.start {:prompt \"my-repl>>> \"})"}]
                :signature   [{:params []}
                              {:params [option+]}]}}


  ([]

   (!.start nil
            $/*result*))


  ([option+]

   (!.start option+
            $/*result*))


  ([option+ result-previous]
 
   (if (= *address*
          -self)
     (when-not *active?*
       (def *active?*
            true)
       (def -prompt
            (or (:prompt option+)
                prompt))
       ($.trx/precat `(~(when (:intro? option+)
                          ($.stream/!.txt.outln (str ($.term/fg.blue)
                                                     ($.term/bold)
                                                     "Convex Shell (REPL mode)"
                                                     ($.term/reset)
                                                     $/line
                                                     "Enter transactions and build a new world."
                                                     $/line
                                                     $/line
                                                     "Powered by Protosens SRL and collaborators."
                                                     $/line
                                                     "To learn more: "
                                                     ($.term/bold)
                                                     "($/help)"
                                                     ($.term/reset)
                                                     $/line)))
                       ($.repl/-!.next (quote ~result-previous)))))
     (call -self
           (!.start option+
                    result-previous)))))



(defn stop

  ^{:callable? true
    :doc       {:description ["If currently running, sets `$.repl/*active?*` to false so that the REPL"
                              "will stop at the next transaction."
                              ""
                              "Returns nil."]
                :examples    [{:code "($.repl/stop)"}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         -self)
    (do
      (def *active?*
           false)
      (def -prompt
           nil)
      nil)
    (call -self
          (stop))))
