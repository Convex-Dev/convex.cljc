(call *registry*
      (cns-update 'convex.shell.repl
                  *address*))


(call *registry*
      (register {:description "Starting and stopping the basic REPL provided by the Convex Shell."
                 :name        "Simple Convex REPL"}))


;;;;;;;;;; Importing libraries


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.catch

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.catch)))



(def $.stream

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.stream)))



(def $.term

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.term)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; Private values


(def -self

  ^{:private? true}

  *address*)


;;;;;;;;;; Public values


(def *active?*

  ^{:doc {:description "Set to true if the REPL is currently running."}}

  false)



(defn prompt

  ^{:doc {:description "Default function for producing prompt string."}}

  []

  (str ($.term/bold)
       ($.term/fg.blue)
       "> "
       ($.term/reset)))


;;;;;;;;;; Private values


(def -prompt

  ^{:doc      {:description "Currently used prompt."}
    :private? true}

  nil)


;;;;;;;;;; Internal


(defn -!.next

  ^{:callable? true
    :doc       {:description ["After `start`, loops Read-Eval-Print until `stop` is called."
                              "Ensures last result produced by the user is available under `$/*result*`."]}
    :private?  true}

  ;; TODO. Refactor. This is very complex to follow.

  [result]

  ($.trx/precat `(($.stream/!.txt.out ~(if (fn? -prompt)
                                         (-prompt)
                                         -prompt))
                  ($.stream/!.flush)
                  ($.catch/!.safe '($.stream/!.line)
                                  '$/*result*)
                  (cond
                    ;;
                    ;; An exception occured while reading input.
                    ($.catch/exception? $/*result*)
                    (let [result (quote ~result)]
                      (if (= (:code $/*result*)
                             :READER)
                        ($.trx/precat `(($.stream/!.txt.outln (str $/line
                                                                   ($.term/fg.red)
                                                                   ($.term/bold)
                                                                   "Input cannot be parsed as Convex Lisp:"
                                                                   ($.term/reset)
                                                                   $/line
                                                                   "  "
                                                                   ~(:message $/*result*)
                                                                   $/line))
                                        (call $.repl
                                              (-!.next (quote ~result)))))
                        ($.trx/set '(($.stream/!.txt.outln $.stream/*err*
                                                           (str $/line
                                                                $/line
                                                                ($.term/bold)
                                                                ($.term/fg.red)
                                                                "REPL cannot read: is the input stream closed perhaps?"
                                                                ($.term/reset)))
                                     ($.process/!.exit 3)))))
                    ;;
                    ;; Nil, input stream reached its end.
                    (nil? $/*result*)
                    ($.repl/!.stop)
                    ;;
                    ;; Prints result or exception after executing input.
                    (let [form+       $/*result*
                          n-form      (count form+)
                          result-real (quote ~result)]
                      (if (>= n-form
                              1)
                        ($.catch/!.safe ;; Try
                                        `($.trx/precat (quote ~(concat `((quote ~result-real))
                                                                      form+
                                                                      '((def $.repl.result
                                                                             $/*result*)
                                                                        (when $.repl/*active?*
                                                                          ($.trx/precat '(($.stream/!.txt.out $/line)
                                                                                          ($.stream/!.outln $.repl.result)
                                                                                          ($.stream/!.txt.out $/line)
                                                                                          ($.stream/!.flush)
                                                                                          (let [result $.repl.result]
                                                                                            (undef $.repl.result)
                                                                                            (call $.repl
                                                                                                  (-!.next result))))))))))
                                        ;; Catch
                                        '($.trx/precat `(~($.stream/!.txt.outln
                                                            (str $/line
                                                                 ($.term/bold)
                                                                 ($.term/fg.red)
                                                                 "Exception code:"
                                                                 ($.term/reset)
                                                                 $/line
                                                                 "  "
                                                                 ($.term/bold)
                                                                 (:code $/*result*)
                                                                 $/line
                                                                 ($.term/bold)
                                                                 ($.term/fg.red)
                                                                 "Message:"
                                                                 ($.term/reset)
                                                                 $/line
                                                                 "  "
                                                                 (:message $/*result*)
                                                                 $/line
                                                                 ($.term/bold)
                                                                 ($.term/fg.red)
                                                                 "Trace:"
                                                                 ($.term/reset)
                                                                 (let [trace (:trace $/*result*)]
                                                                   (if (empty? trace)
                                                                     (str $/line
                                                                          "  None.")
                                                                     (apply str
                                                                            (reduce (fn [acc entry]
                                                                                      (conj acc
                                                                                            $/line
                                                                                            "  "
                                                                                            entry))
                                                                                    []
                                                                                    trace))))
                                                                 (let [extra-data (dissoc $/*result*
                                                                                          :code
                                                                                          :exception?
                                                                                          :message
                                                                                          :trace)]
                                                                   (if (empty? extra-data)
                                                                     ""
                                                                     (str $/line
                                                                          ($.term/bold)
                                                                          ($.term/fg.red)
                                                                          "Extra data:"
                                                                          ($.term/reset)
                                                                          $/line
                                                                          "  "
                                                                          extra-data)))
                                                                 $/line
                                                                 ))
                                                         (call $.repl                                       
                                                               (-!.next (quote ~$/*result*))))))
                        (call $.repl
                              (-!.next (quote ~result)))))))))


;;;;;;;;;; API


(defn !.start

  ^{:callable? true
    :doc       {:description ["Starts a REPL on next transaction."
                              "User can then enter transactions and see results."
                              "For stopping, see `stop`."
                              "A prompt or prompt producing function may be provided."]
                :examples    [{:code "($.repl/!.start)"}
                              {:code "($.repl/!.start {:prompt \"my-repl>>> \"})"}]
                :signature   [{:params []}
                              {:params [option+]}]}}


  ([]

   (!.start nil
            $/*result*))


  ([option+]

   (!.start option+
            $/*result*))


  ([option+ result]
 
   (if (= *address*
          -self)
     (when-not *active?*
       (def *active?*
            true)
       (def -prompt
            (or (:prompt option+)
                prompt))
       ($.trx/precat `(~(when (:intro? option+)
                          ($.stream/!.txt.outln (str ($.term/fg.blue)
                                                     ($.term/bold)
                                                     "Convex Shell (REPL mode)"
                                                     ($.term/reset)
                                                     $/line
                                                     $/line
                                                     "Enter transactions and build a new world."
                                                     $/line
                                                     $/line
                                                     "To learn more: "
                                                     ($.term/bold)
                                                     "($/help)"
                                                     ($.term/reset)
                                                     $/line)))
                       (call $.repl
                             (-!.next (quote ~result))))))
     (call -self
           (!.start option+
                    result)))))



(defn !.stop

  ^{:callable? true
    :doc       {:description "If currently running, stops the REPL on next transaction."
                :examples    [{:code "($.repl/!.stop)"}]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         -self)
    (do
      (def *active?*
           false)
      (def -prompt
           nil)
      nil)
    (call -self
          (!.stop)))
  nil)
