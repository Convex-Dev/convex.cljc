(call *registry*
      (cns-update 'convex.shell.catch
                  *address*))


(call *registry*
      (register {:description ["Handling exceptions in a flexible way."
                               "When an exception is thrown, it is made accessible through `$/*result*`."
                               "Then, the shell uses `pop` to prepare a transaction for handling the error."
                               "Users can use `push` to register an error handler but most of the time, the `safe` idiom is rather used."]
                 :name        "Basic exception handling for the Convex Shell"}))


;;;;;;;;;; Importing libraries


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; Static values


(def -self

  ^{:private? true}

  *address*)



(def *stack*

  ^{:doc {:description ["List of transactions used as error handlers."
                        "When an exception is thrown, the shell uses `pop`."
                        "If another exception occurs, the shell keeps popping."
                        "Always contains at least the default error handler which is unpoppable."]}}

  '(($.trx/set `(($.stream/!.err (quote ~$/*result*))
                 ($.stream/!.flush $.stream/*err*)
                 ($.process/!.exit 2)))))


;;;;;;;;;; API


(defn drop

  ^{:callable? true
    :doc       {:description ["Removes the next transaction from `*stack*`."
                              "Unlike `pop`, the tranaction is simply forgotten about."]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         -self)
    (when (> (count *stack*)
             1)
      (let [trx (first *stack*)]
        (def *stack*
             (next *stack*))
        trx))
    (call -self
          (drop))))



(defn pop

  ^{:callable? true
    :doc       {:description ["Pops the next transaction from `*stack*` and prepends it to `$.trx/*list*`."
                              "Used by the shell when an exception is thrown."]
                :signatures [{:params []}]}}

  []

  (if (= *address*
         -self)
    (do
      ($.trx/prepend (first *stack*))
      (when (> (count *stack*)
               1)
        (def *stack*
             (next *stack*)))
      $/*result*)
    (call -self
          (pop))))



(defn push

  ^{:callable? true
    :doc       {:description ["Pushes `trx` onto `*stack*`."
                              "When an exception is thrown, the shell uses `pop`."]
                :examples    [{:code "($.catch/push '(when (= :NOBODY (:code $/*result*)) ...))"}]
                :signature   [{:params [trx]}]}}

  [trx]

  (if (= *address*
         -self)
    (do
      (def *stack*
           (conj *stack*
                 trx))
      trx)
    (call -self
          (push trx))))



(defn !.safe

  ^{:doc {:description ["Akin to the try-catch idiom found in many languages."
                        ""
                        "If `trx-try` transaction fails, the thrown exception is bound to `$/*result*` and `trx-catch`"
                        "is executed."
                        ""
                        "In any case, `trx-finally` is finally executed if given."
                        "However, the end `$/*result*` value will always come from `trx-try` in case of success or"
                        "`trx-catch` in case of failure, irrelevant of what `trx-finally` does. It is commonly used"
                        "to ensure that some resources, like file streams, are closed even in case of failure."
                        ""
                        "If `trx-catch` itself throws an exception, `trx-finally` will be called nonetheless but the"
                        "new exception will ultimately propagate afterwards. If `trx-finally` itself throws an exception,"
                        "this one will propagate."
                        ""
                        "For any argument, `$.trx/precat` can be used if more than one transaction must be executed."]
          :examples    [{:code "($.catch/!.safe '(assert false) '[:caught $/*result*])"}
                        {:code "($.catch/!.safe '(assert false) nil '($.stream/!.outln :finally!))"}]
          :signature   [{:params [trx-try]}
                        {:params [trx-try trx-catch]}
                        {:params [trx-try trx-catch trx-finally]}]}}


  ([trx-try]

   (!.safe trx-try
           nil))


  ([trx-try trx-catch]

   (!.safe trx-try
           trx-catch
           nil))


  ([trx-try trx-catch trx-finally]

   (if (and (nil? trx-catch)
            (nil? trx-finally))
     ;; If only `try` is provided, then nothing special happens.
     ($.trx/prepend trx-try)
     ;; At least 'catch' or 'finally' is provided, hence it calls for special handling.
     (do
       ;; No matter which one is provided, an error handler must be pushed on the stack.
       (push `(do
                ;; At this point, former transactions are restored to have a clean slate.
                ($.trx/set (quote ~$.trx/*list*))
                ;; What happens next depends on what has been provided.
                ~(if (nil? trx-catch)
                   ;; If there is no 'catch' (but we deduce from the beginning there is 'finally').
                   ;; 'finally' will be executed but the exception must be rethrown.
                   `(let [trx-finally (quote ~trx-finally)]
                      ($.trx/precat `(~trx-finally
                                      [:cvm.sreq :catch.rethrow (quote ~$/*result*)])))
                   (if (nil? trx-finally)
                     ;; If there is no 'finally', 'catch' will be simply executed and this is it.
                     trx-catch
                     ;; If both are provided, `!.safe` is reused.
                     ;; `catch` becomes `try` and `finally` is forwarded.
                     ;; That way, if `catch` fails as well, `finally` is executed but the
                     ;; new exception will be rethrown.
                     `($.catch/!.safe (let [trx-catch (quote ~trx-catch)]
                                        `($.trx/precat '((quote ~$/*result*)
                                                         ~trx-catch)))
                                      nil
                                      (quote ~trx-finally))))))
       ;;
       ;; After pushing the error handler.
       ;;
       ;; If 'finally' is provided, already prepend this to transactions.
       ;; This part will be executed only if 'try' succeeds due to how the error handler
       ;; restores former transactions.
       (when-not (nil? trx-finally)
         ($.trx/prepend `(let [trx-finally (quote ~trx-finally)]
                           ($.trx/precat `(~trx-finally
                                           (quote ~$/*result*))))))
       ;; Lastly, prepend all 'try' transactions.
       ;; If they succeed, the error handler pushed above is cleared.
       ;; Note: if they fail, the Shell will clear the error handler.
       ($.trx/precat `(~trx-try
                        (do
                          ($.catch/drop)
                          $/*result*)))))))
