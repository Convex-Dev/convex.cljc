(call *registry*
      (cns-update 'convex.shell.catch
                  *address*))


(call *registry*
      (register {:description ["Handling exceptions in a flexible way."
                               "When an exception is thrown, it is made accessible through `$/*result*`."
                               "Then, the shell uses `pop` to prepare a transaction for handling the error."
                               "Users can use `push` to register an error handler but most of the time, the `safe` idiom is rather used."]
                 :name        "Basic exception handling for the Convex Shell"}))


;;;;;;;;;; Importing libraries


(def $

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell)))



(def $.trx

  ^{:private? true}

  (call *registry*
        (cns-resolve 'convex.shell.trx)))


;;;;;;;;;; Static values


(def -self

  ^{:private? true}

  *address*)



(def *stack*

  ^{:doc {:description ["List of transactions used as error handlers."
                        "When an exception is thrown, the shell uses `pop`."
                        "If another exception occurs, the shell keeps popping."
                        "Always contains at least the default error handler which is unpoppable."]}}

  '(($.trx/set `(($.stream/!.err (quote ~$/*result*))
                 ($.stream/!.flush $.stream/*err*)
                 ($.process/!.exit 2)))))


;;;;;;;;;; API


(defn drop

  ^{:callable? true
    :doc       {:description ["Removes the next transaction from `*stack*`."
                              "Unlike `pop`, the tranaction is simply forgotten about."]
                :signature   [{:params []}]}}

  []

  (if (= *address*
         -self)
    (when (> (count *stack*)
             1)
      (let [trx (first *stack*)]
        (def *stack*
             (next *stack*))
        trx))
    (call -self
          (drop))))



(defn pop

  ^{:callable? true
    :doc       {:description ["Pops the next transaction from `*stack*` and prepends it to `$.trx/*list*`."
                              "Used by the shell when an exception is thrown."]
                :signatures [{:params []}]}}

  []

  (if (= *address*
         -self)
    (do
      ($.trx/prepend (first *stack*))
      (when (> (count *stack*)
               1)
        (def *stack*
             (next *stack*)))
      $/*result*)
    (call -self
          (pop))))



(defn push

  ^{:callable? true
    :doc       {:description ["Pushes `trx` onto `*stack*`."
                              "When an exception is thrown, the shell uses `pop`."]
                :examples    [{:code "($.catch/push '(when (= :NOBODY (:code $/*result*)) ...))"}]
                :signature   [{:params [trx]}]}}

  [trx]

  (if (= *address*
         -self)
    (do
      (def *stack*
           (conj *stack*
                 trx))
      trx)
    (call -self
          (push trx))))



(defn !.safe

  ^{:doc {:description ["Try-catch idiom."
                        "If `trx-try` transaction fails, `trx-catch` is executed."
                        "For any argument, `$.trx/precat`if more than one transaction must be executed."
                        ""
                        "In any case, `trx-finally` is finally executed if given."
                        "However, the end `$/*result*` will always come from `trx-try` in case of success or"
                        "`trx-catch` in case of failure."]
          :signature   [{:params [trx-try]}
                        {:params [trx-try trx-catch]}
                        {:params [trx-try trx-catch trx-finally]}]}}


  ([trx-try]

   (!.safe trx-try
           nil))


  ([trx-try trx-catch]

   (!.safe trx-try
           trx-catch
           nil))


  ([trx-try trx-catch trx-finally]

   (if (nil? trx-catch)
     (if (nil? trx-finally)
       ;; No 'catch' and no 'finally'.
       ($.trx/prepend trx-try)
       ;; No 'catch' with 'finally'.
       (do
         (push `(do
                  ($.trx/set (quote ~$.trx/*list*))
                  (let [trx-finally (quote ~trx-finally)]
                    ($.trx/precat `((quote ~$/*result*)
                                    ~trx-finally
                                    [:cvm.sreq :catch.rethrow (quote ~$/*result*)])))))
         ($.trx/prepend `(let [trx-finally (quote ~trx-finally)]
                           ($.trx/precat `((quote ~$/*result*)
                                           ~trx-finally
                                           (quote ~$/*result*)))))
         ($.trx/precat `((quote ~$/*result*)
                         ~trx-try
                         (do
                           ($.catch/drop)
                           $/*result*)))))
     (if (nil? trx-finally)
       ;; 'catch' without 'finally'.
       (do
         (push `(do
                  ($.trx/set (quote ~$.trx/*list*))
                  ~trx-catch))
         ($.trx/precat `((quote ~$/*result*)
                         ~trx-try
                         (do
                           ($.catch/drop)
                           $/*result*))))
       ;; 'catch' with 'finally'.
       (do
         (push `(do
                  ($.trx/set (quote ~$.trx/*list*))
                  ($.trx/prepend '(let [trx-finally (quote ~trx-finally)]
                                    ($.trx/precat `((quote ~$/*result*)
                                                    ~trx-finally
                                                    (quote ~$/*result*)))))
                  ($.trx/prepend (quote ~trx-catch))
                  ($.trx/prepend `(quote ~$/*result*))))
         ($.trx/prepend `(let [trx-finally (quote ~trx-finally)]
                           ($.trx/precat `((quote ~$/*result*)
                                           ~trx-finally
                                           (quote ~$/*result*)))))
         ($.trx/precat `((quote ~$/*result*)
                         ~trx-try
                         (do
                           ($.catch/drop)
                           $/*result*))))))))
